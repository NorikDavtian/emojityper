{"version":3,"sources":["src/polyfill.js","src/lib/event.js","src/lib/copier.js","src/buttons.js","src/lib/measurer.js","src/lib/cache.js","src/lib/modifier.js","src/lib/word.js","src/input.js","src/lib/prefixgen.js","src/lib/promises.js","src/lib/results.js","src/lib/provider.js","src/lib/worker.js","src/lib/valid.js","src/options.js","src/selection.js","src/page.js","src/adverts.js","src/sw.js","src/offline.js","src/bundle.js"],"names":["window","requestIdleCallback","callback","start","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","setTimeout","cancelIdleCallback","id","clearTimeout","navigator","sendBeacon","url","body","Promise","resolve","reject","xhr","XMLHttpRequest","open","onerror","onload","send","arrowKeys","arrowFromEvent","ev","key","startsWith","indexOf","isKeyboardClick","MouseEvent","screenX","detail","webkitForce","dummy","copyText","text","document","createElement","style","position","opacity","appendChild","value","hidden","focus","selectionStart","selectionEnd","length","execCommand","e","all","Array","from","buttons","querySelectorAll","handler","trim","hasValue","Boolean","forEach","button","disabled","typer","addEventListener","input","timeout","defaultText","textContent","wasInputEnter","maybeReleaseInputEnter","activeElement","repeat","click","preventDefault","dataset","replace","copier.copyText","console","warn","info","ga","copy","eventlib.isKeyboardClick","letterSpacing","fontSize","hider","overflow","width","m","display","whiteSpace","background","platform","fontFamily","invalidBoxWidth","getBoundingClientRect","isSingleEmoji","s","w","round","cacheFor","limit","cache","count","arg","result","undefined","measureText","context","getContext","font","fixedWidthEmoji","exec","isSingle","debugMode","location","search","emojiWidth","ok","debug","isExpectedLength","chars","splitEmoji","jsdecode","flags","reduce","total","char","isFlagPoint","point","expectedLength","ceil","floor","clen","i","buf","suffix","attach","push","String","fromCodePoint","basicDiversity","isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","unlikelyModifierBase","len","points","raw","charCodeAt","extra","genderFlip","list","Map","data","f","n","j","v","has","Error","set","out","get","single","neutral","curr","check","next","modify","opt_op","stats","tone","gender","double","record","some","first","genderable","family","ch","flip","isSinglePerson","candidate","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","map","allowOtherFlip","genderPoint","c","concat","letterAt","pos","code","match","at","to","substr","datasetSafeDelete","el","keys","d","upgraded","WeakMap","cursorPosition","upgrade","sel","helper","className","parentNode","insertBefore","underline","suggest","autocomplete","sizer","nonce","offsetLeft","mid","scrollLeft","readyState","classList","add","renderLine","remove","left","getElementById","transform","setRange","initialLength","state","end","previousDetail","mergedEventHandler","events","permitNextChange","setSelectionRange","alreadyAtState","dispatchEvent","CustomEvent","word.match","toLowerCase","changeHandler","name","emoji","renderAutocomplete","prefix","selection","hasPendingSpace","maybeReplace","expectSpace","rest","mustBeSpace","choice","word","frame","Set","dedup","clear","requestAnimationFrame","type","split","event","which","success","shiftKey","keyCode","dedupRenderLine","passive","replaceFocus","call","previousScrollLeft","dir","selectionDirection","update","prev","expected","drift","where","[object Object]","modifier.modify","build","prefixLength","maxSuggestions","prefixSuggest","values","k","slice","part","opts","typed","filter","idle","rAF","delay","microtask","ms","debouceMap","debounce","callable","r","then","delete","t","removeDuplicates","row","found","item","merge","existing","lookup","existingRow","updatedData","api","recentLimit","selectionDelay","loaderFor","expiry","promiseResults","localStorage","JSON","parse","Date","responseType","response","stringify","getPrefixGen","loader","working","results","getTrendingEmoji","request","more","recent","unshift","localPromise","encodeURIComponent","morePromise","fetch","json","both","local","results.merge","select","pending","runner","splice","join","promises.debounce","submit","FormData","append","method","mode","x","allowedWorkTime","maximumTaskFrame","Worker","this","fn_","queue_","waiting_","runner_","catch","err","promises.idle","chunk_","promises.rAF","done","shift","ls","known","worker","immediate","async","valid","task","findValidMatch","options","calledWithDelay","ButtonManager","holder","holder_","options_","buttons_","buttonTarget_","buttonPool_","modifierHolder","setModifier","genderOption","optionType_","toneOption","createModifierButton","genders","tones","updateStatus","yes","node","owner","active","contains","l","nextSibling","setAttribute","option","target","pop","isValid","replaceChild","createTextNode","previousActiveElement","optionForName_","children","b","addEmojiTo_","spaceFrame","chooser","localName","previousChooserLeft","duringNavigate","navigateChooserButtonVertical","cands","best","dist","Infinity","previousRect","targetTop","candidateRect","top","abs","isKeyboard","label","scrollTop","scrollingElement","metaKey","ctrlKey","provider.select","typerRect","input.cursorPosition","querySelector","arrow","eventlib.arrowFromEvent","buttonArray","delta","reverse","focusRect","height","innerHeight","manager","previous","previousQueryAt","previousResults","suggestInvoke","findSuggest","q","localSuggestInvoke","exactMatch","localResults","query","initialMore","provider.request","pow","error","advanced","form","namer","provider.submit","status","_","promises.delay","toggle","isExtentNode","Element","getSelection","anchorNode","a","focusNode","removeAllRanges","promises.microtask","resize","minHeight","deferredPrompt","cleanupPrompt","installEl","prompt","userChoice","adverts","refresh","nextElementSibling","firstElementChild","enqueue","serviceWorker","register","hadInitialController","controller","reload","prevOnLine","notifyStatus","onLine","msg","file","line","col","nonInteraction"],"mappings":"AAKKA,OAAOC,sBAEVD,OAAOC,oBAAsB,CAACC,IAC5B,MAAMC,EAAQC,YAAYC,MACpBC,EAAKJ,EAASK,KAAK,MACvBC,YAAY,EACZC,cAAe,IAAMC,KAAKC,IAAI,EAAG,IAAMP,YAAYC,MAAQF,MAE7D,OAAOH,OAAOY,WAAWN,EAAI,KAG/BN,OAAOa,mBAAqBC,CAAAA,GAAMd,OAAOe,aAAaD,KAGnDE,UAAUC,aACbD,UAAUC,WAAa,SAASC,EAAKC,GACnC,OAAO,IAAIC,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAM,IAAIC,eAChBD,EAAIE,KAAK,OAAQP,GAAK,GACtBK,EAAIG,QAAUJ,EACdC,EAAII,OAASN,EACbE,EAAIK,KAAKT,OCzBf,MAAMU,WAAa,OAAQ,QAAS,KAAM,QAM1C,SAAgBC,eAAeC,GAC7B,OAAKA,EAAGC,IAGJD,EAAGC,IAAIC,WAAW,SACbF,EAAGC,KAEuB,IAA/BH,UAAUK,QAAQH,EAAGC,KAChB,KAEF,QAAUD,EAAGC,IARX,KAeX,SAAgBG,gBAAgBJ,GAC9B,QAAMA,aAAcK,cAGG,IAAfL,EAAGM,SAA+B,IAAdN,EAAGO,QAAoC,IAAnBP,EAAGQ,aC3BrD,IAAIC,MAEJ,SAAgBC,SAASC,GAClBF,SACHA,MAAQG,SAASC,cAAc,UACzBC,MAAMC,SAAW,QACvBN,MAAMK,MAAME,QAAU,EACtBJ,SAASxB,KAAK6B,YAAYR,QAG5BA,MAAMS,MAAQP,EACd,IACEF,MAAMU,QAAS,EACfV,MAAMW,QACNX,MAAMY,eAAiB,EACvBZ,MAAMa,aAAeb,MAAMS,MAAMK,OACjCX,SAASY,YAAY,QACrB,MAAOC,GACP,OAAO,UAEPhB,MAAMU,QAAS,EAGjB,OAAO,ECnBT,MAGMO,IAAMC,MAAMC,KAAKC,QAAQC,iBAAiB,WAE1CC,QAAW/B,IACf,MAAMW,EAAOX,EAAGO,OAAOyB,OACjBC,EAAWC,QAAQvB,GACzBe,IAAIS,QAASC,GAAWA,EAAOC,UAAYJ,IAE7CK,MAAMC,iBAAiB,QAASR,SAChCA,SAASxB,OAAQ+B,MAAMpB,QAGtB,SAASkB,EAAQI,GAChB,IAAIC,EACJ,MAAMC,EAAcN,EAAOO,YAuB3B,IAAIC,GAAgB,EA4BpB,SAASC,IACHD,IACEhC,SAASkC,gBAAkBV,GAC7BI,EAAMpB,QAERwB,GAAgB,GAhCpBJ,EAAMD,iBAAiB,UAAYvC,IAC7B4C,GAEkB,UAAX5C,EAAGC,KAAoBD,EAAG+C,SACnCX,EAAOY,QACPZ,EAAOhB,QACPwB,GAAgB,EAChB5C,EAAGiD,oBAGPrC,SAASxB,KAAKmD,iBAAiB,QAAUvC,IACxB,UAAXA,EAAGC,KACL4C,MAGJT,EAAOG,iBAAiB,QAAUvC,IAChCA,EAAGiD,iBACCL,GAAiB5C,EAAG+C,SAtCb,MACX,MAAMpC,EAAO6B,EAAMU,QAAc,KAAElB,OAAOmB,QAAQ,MAAO,KACzD,IAAKC,SAAgBzC,GAEnB,OADA0C,QAAQC,KAAK,iBAAkB3C,IACxB,EAET0C,QAAQE,KAAK,SAAU5C,GAGvB6C,GAAG,OAAQ,QAAS,OAAQ,QAG5BpB,EAAOO,YAAcP,EAAOc,QAAgB,OAC5CjF,OAAOe,aAAayD,GACpBA,EAAUxE,OAAOY,WAAYmB,IAC3BoC,EAAOO,YAAcD,EACrBG,KACC,MAwBHY,GACIC,gBAAyB1D,IAE3BoC,EAAOhB,WAjDb,CA8DEqC,KAAMnB,OChFR,MAAMqB,cAAgB,KAChBC,SAAW,GAEXC,MAAQjD,SAASC,cAAc,OACrCgD,MAAM/C,MAAMgD,SAAW,SACvBD,MAAM/C,MAAMiD,MAAQ,MACpBF,MAAM/C,MAAMC,SAAW,WAEvB,MAAMiD,EAAIpD,SAASC,cAAc,OACjCgD,MAAM5C,YAAY+C,GAClBA,EAAElD,MAAMmD,QAAU,eAClBD,EAAElD,MAAMoD,WAAa,SACrBF,EAAElD,MAAM8C,YAAcA,aACtBI,EAAElD,MAAMqD,WAAa,MAEjBlF,UAAUmF,SAASlE,WAAW,OAChC8D,EAAElD,MAAMuD,WAAa,gEAErBL,EAAElD,MAAMuD,WAAa,oDAEvBzD,SAASxB,KAAK6B,YAAY4C,OAE1BG,EAAErB,YAAc,YAChB,MAAM2B,gBAAkBN,EAAEO,wBAAwBR,MAUlD,SAAgBS,cAAcC,GAC5BT,EAAErB,YAAc8B,EAChB,MAAMC,EAAIV,EAAEO,wBAAwBR,MAGpC,OAAc,IADApF,KAAKgG,MAAMD,GAAKf,cAAgBC,YAK1Cc,EAAIf,gBAAkBW,gBC1CrB,SAASM,SAASrG,EAAIsG,EAAM,KACjC,IAAIC,KACAC,EAAQ,EAEZ,OAAQC,IACN,IAAIC,EAASH,EAAME,GAQnB,YAPeE,IAAXD,IACFH,EAAME,GAAOC,EAAS1G,EAAGyG,KACnBD,EAAQF,IACZC,KACAC,EAAQ,IAGLE,GDaXjB,EAAElD,MAAM6C,iBAAmBA,kBEnB3B,MAAMwB,YAAe,WACnB,MACMC,EADSxE,SAASC,cAAc,UACfwE,WAAW,MAOlC,OAJAD,EAAQE,KAAO,oEAIRV,SAAUH,GAAMW,EAAQD,YAAYV,GAAGV,UAM1CwB,gBAAkBrD,QAAQ,6BAA6BsD,KAAKvG,UAAUmF,WAMtEqB,SAAY,WAChB,MAAMC,GAAyD,IAA7CzH,OAAO0H,SAASC,OAAOzF,QAAQ,SAG3C0F,EAAaV,YAAY,aAC/B,OAAII,gBACEG,GACFrC,QAAQE,KAAK,uBAAwBsC,EAAY,iBACzCpB,IACN,MAAMqB,EAAKX,YAAYV,KAAOoB,EAI9B,OAHKC,GACHzC,QAAQ0C,MAAM,wBAA0BtB,EAAG,QAASU,YAAYV,IAE3DqB,IAIHrB,GAAMU,YAAYV,KAAOoB,EAI5BjB,SAASJ,kBAgBLwB,iBAAoB,WAI/B,GAAIT,gBAAiB,CAEnB,MAAMM,EAAaV,YAAY,aAC/B,OAAQV,IAEN,MACMwB,EAAQC,WADCC,SAAS1B,IAIlB2B,EAAQH,EAAMI,OAAO,CAACC,EAAOC,IAASD,GAASE,YAAYD,EAAK,GAAGE,OAAS,EAAI,EAAG,GACnFC,EAAiBT,EAAM1E,OAAS5C,KAAKgI,KAAKP,EAAQ,GAElDrC,EAAQoB,YAAYV,GAAKoB,EAG/B,OAAIlH,KAAKiI,MAAM7C,KAAWA,GAGnBA,GAAS2C,GAIpB,OAAQjC,IAIN,MACMwB,EAAQC,WADCC,SAAS1B,IAElBoC,EAAOZ,EAAM1E,OACnB,IAAK,IAAIuF,EAAI,EAAGA,EAAID,IAAQC,EAAG,CAC7B,MAAMP,EAAON,EAAMa,GACnB,GAAIN,YAAYD,EAAK,GAAGE,OAGtB,SAGF,MAAMM,KACNR,EAAKpE,QAAQ,EAAEsE,MAAAA,EAAOO,OAAAA,EAAQC,OAAAA,GAASH,KACjCA,IAAMG,GACRF,EAAIG,KAAK,MAEXH,EAAIG,KAAKT,GACTO,GAAUD,EAAIG,KAAKF,KAErB,MAAMvC,EAAI0C,OAAOC,iBAAiBL,GAClC,IAAKtB,SAAShB,GACZ,OAAO,EAIX,OAAO,MAUL4C,eAAkBlC,YAAY,wBAA0BA,YAAY,aAM1E,SAASmC,cAAcC,GACrB,OAAa,OAANA,GAAsB,OAANA,EAOzB,SAASC,eAAeD,GACtB,OAAa,SAANA,GAAuB,SAANA,EAO1B,SAASE,eAAeF,GACtB,OAAa,SAANA,GAAuB,SAANA,GAAuB,SAANA,EAO3C,SAASG,oBAAoBH,GAC3B,OAAQA,GAAK,OAAUA,GAAK,OAAYA,GAAK,QAAWA,GAAK,OAO/D,SAASI,oBAAoBJ,GAC3B,OAAOA,GAAK,QAAWA,GAAK,OAO9B,SAASf,YAAYe,GACnB,OAAOA,GAAK,QAAWA,GAAK,OAO9B,SAASK,qBAAqBL,GAC5B,OAAOA,EAAI,MAAUD,cAAcC,IAAMG,oBAAoBH,IAAMI,oBAAoBJ,IACnFf,YAAYe,GASlB,SAAgBpB,SAAS1B,GACvB,MAAMoD,EAAMpD,EAAElD,OACRuG,KAEN,IAAK,IAAIhB,EAAI,EAAGA,EAAIe,GAAM,CACxB,MAAME,EAAMtD,EAAEuD,WAAWlB,MAAQ,EACjC,GAAIiB,EAAM,OAAUA,EAAM,OAAUjB,IAAMe,OAEnC,CACL,MAAMI,EAAQxD,EAAEuD,WAAWlB,IAAM,EACjC,GAAyB,QAAZ,MAARmB,GAA4B,GAE7BnB,EACFgB,EAAOZ,KAAK,OAAmB,KAARe,KAAyB,KAANF,IAAgB,KAC1D,UAGJD,EAAOZ,KAAKa,GAGd,OAAOD,EAWT,MAAMI,WAAc,WAElB,MAAMC,GACJ,OAAS,OAAS,EAClB,OAAS,OAAS,EAClB,OAAS,OAAS,EAClB,OAAS,OAAS,OAClB,OAAS,OAAS,OAClB,OAAS,OAAS,EAClB,OAAS,OAAS,GAIdzG,EAAM,IAAI0G,IAChB,IAAK,IAAItB,EAAI,EAAGA,EAAIqB,EAAK5G,OAAQuF,GAAK,EAAG,CACvC,MAAMuB,GACJP,QAASQ,EAAGH,EAAKrB,GAAI9C,EAAGmE,EAAKrB,EAAE,GAAIyB,EAAGJ,EAAKrB,EAAE,KAE/C,IAAK,IAAI0B,EAAI,EAAGA,EAAI,IAAKA,EAAG,CAC1B,MAAMC,EAAIN,EAAKrB,EAAE0B,GACjB,GAAIC,EAAG,CACL,GAAI/G,EAAIgH,IAAID,GACV,MAAM,IAAIE,MAAM,6BAA+BF,GAEjD/G,EAAIkH,IAAIH,EAAGJ,KAMjB,OAAQ5B,IACN,MAAMoC,EAAMnH,EAAIoH,IAAIrC,IAAU,KAO9B,OANIoC,QAAsB3D,IAAf2D,EAAIE,SAEbF,EAAIE,OAAStD,SAAS0B,OAAOC,cAAcyB,EAAIf,OAAOQ,KAClD7C,SAAS0B,OAAOC,cAAcyB,EAAIf,OAAO9D,IAC7C6E,EAAIG,QAAUH,EAAIf,OAAOS,GAAK9C,SAAS0B,OAAOC,cAAcyB,EAAIf,OAAOS,KAElEM,MAaX,SAAgB3C,WAAW4B,GACzB,IAAKA,EAAOvG,OACV,SAEF,IAAI0H,IAASxC,MAAOqB,EAAO,GAAId,OAAQ,EAAGC,QAAQ,IAClD,MAAM4B,GAAOI,GAOb,IAAK,IAAInC,EAAI,EAAGA,EAAIgB,EAAOvG,SAAUuF,EAAG,CACtC,MAAMoC,EAAQpB,EAAOhB,GAErB,GAAIN,YAAYyC,EAAKA,EAAK1H,OAAO,GAAGkF,YAE7B,CAAA,GAAIkB,oBAAoBuB,IAAUxB,oBAAoBwB,GAAQ,CAEnED,EAAKA,EAAK1H,OAAO,GAAGyF,OAASkC,EAC7B,SACK,GAAc,OAAVA,EAAkB,CAE3BD,EAAK/B,MAAMT,MAAOyC,EAAOlC,OAAQ,EAAGC,QAAQ,IAC5C,SACK,GAAc,OAAViC,EAAkB,CAE3B,MAAMC,EAAOrB,IAAShB,GACtBqC,GAAQF,EAAK/B,MAAMT,MAAO0C,EAAMnC,OAAQ,EAAGC,QAAQ,IACnD,UAIFgC,IAASxC,MAAOyC,EAAOlC,OAAQ,EAAGC,QAAQ,IAC1C4B,EAAI3B,KAAK+B,GAEX,OAAOJ,EAYT,SAAgBO,OAAO3E,EAAG4E,GACxB,MAAMC,GAASC,MAAM,EAAOC,QAAST,QAAQ,EAAOU,QAAQ,EAAOT,SAAS,IAC5E,IAAKvE,EACH,OAAO6E,EAET,MAGMrD,EAAQC,WAHCC,SAAS1B,IAIlBiF,EAAUL,KAAc,KAmE9B,GAlEApD,EAAM0D,KAAK,CAACpD,EAAMO,KAChB,MAAM8C,EAAQrD,EAAK,GAAGE,MACtB,IAAIoD,EAAa,EACbC,GAAS,EAGbvD,EAAKpE,QAAS4H,IACZ,MAAMxC,EAAIwC,EAAGtD,MACb,GAAIa,cAAcC,GAEhB+B,EAAME,OAAOT,QAAS,EACtBO,EAAME,OAAOR,SAAU,OAClB,GAAIxB,eAAeD,GAExB+B,EAAME,OAAOT,QAAS,IAChBc,GAAc,IAClBP,EAAME,OAAOC,QAAS,QAEnB,GAAIhC,eAAeF,IAAMsC,EAE9BC,GAAS,MACJ,CAEL,MAAME,EAAO9B,WAAWX,GACpByC,IACFV,EAAME,OAAOT,QAAUiB,EAAKjB,OAC5BO,EAAME,OAAOR,SAAWgB,EAAKhB,YAMnC,MAAMiB,EACFJ,EAAcrC,eAAeoC,IAAyB,IAAfC,IAAqBC,OAAU5E,EAY1E,GAXI+E,IACFX,EAAMC,KAAOlC,gBAEXqC,IAIFA,EAAO5C,GAAKmD,IAITX,EAAMC,OAASlC,iBAAmBiC,EAAME,OAAOR,QAElD,OAAQU,GAAUJ,EAAME,OAAOT,QAAUO,EAAME,OAAOC,OAIxD,IAAuB,IAAnBQ,GAA4BrC,qBAAqBgC,GAAU,OAI/D,MAAMM,EAAY/C,OAAOC,cAAcwC,GACnCvC,iBAAmBiC,EAAMC,MAAQ9D,SAASyE,EAAY,eACxDZ,EAAMC,MAAO,IAEVD,EAAME,OAAOR,SAAWvD,SAASyE,EAAY,qBAA4BA,KAC5EZ,EAAME,OAAOR,SAAU,EACvBM,EAAME,OAAOT,QAAS,MAKrBM,EACH,OAAOC,EAIT,MAAMa,EAAmB,WACvB,MAAMC,EAAIf,EAAOG,QAAU,GAC3B,IAAIa,EACAC,EACJ,MAAO,CAACC,EAAQC,EAAWC,UACFvF,IAAnBmF,GAAgCE,IAAWF,GAC7CA,EAAiBE,EACjBD,EAAQ,KAENA,EAEJ,MAAMnB,EAAOiB,EAAIA,EAAEE,EAAQF,EAAE7I,QAAU,GACjCkF,EAAQ+D,GAAa,EAC3B,GAAIhD,eAAef,GAEjB,OAAO0C,EAAiB,MAATA,EAAe,OAAU,OAAW1C,EAC9C,IAAKA,GAASa,cAAcb,GAEjC,OAAO0C,EAAiB,MAATA,EAAe,KAAS,KAAU,EAC5C,GAAIsB,EAAoB,CAE7B,MAAMT,EAAO9B,WAAWzB,GACxB,GAAIuD,EAAM,CACR,IAAKb,GAAQa,EAAKhB,QAChB,OAAOgB,EAAKlC,OAAOS,EACd,GAAIY,GAAQa,EAAKjB,OACtB,MAAgB,MAATI,EAAea,EAAKlC,OAAO9D,EAAIgG,EAAKlC,OAAOQ,GAMxD,QADEgC,EACK7D,MAKLoC,EAAM5C,EAAMyE,IAAI,CAACnE,EAAMO,KAC3B,MAAMgB,KACAmC,EAAiBP,EAAO5C,GACxB8C,EAAQrD,EAAK,GAAGE,MAEtB,QAAsBvB,IAAlBmE,EAAOG,OAAsB,CAG/B,MAAMmB,OAAqCzF,IAAnB+E,EAIxB,GAHA1D,EAAKpE,QAAS4H,GAAOA,EAAGtD,MAAQ0D,EAAgBrC,EAAQiC,EAAGtD,MAAOkE,SAG3CzF,IAAnB+E,GAAgD,IAAhB1D,EAAKhF,SAAiB+F,cAAcsC,GAAQ,CAC9E,MAAMgB,EAAcT,EAAgBrC,GAC9B+C,EAAI1D,OAAOC,cAAcwC,GAC3BgB,GAAenF,SAASoF,EAAI,qBAA4BA,IAC1DtE,EAAKW,MAAMF,OAAQ,MAAQP,MAAOmE,KA4BxC,YAtBoB1F,IAAhBmE,EAAOE,MACThD,EAAKpE,QAAQ,CAAC4H,EAAIjD,KACZa,oBAAoBoC,EAAG/C,QAEzB+C,EAAG/C,OAASqC,EAAOE,KACJ,IAANzC,GAAWO,iBAAqC,IAAnB4C,IAElCA,GAAkBxE,SAAS0B,OAAOC,cAAcwC,GAAS,gBAC3DG,EAAG/C,OAASqC,EAAOE,QAO3BhD,EAAKpE,QAAS4H,IACRA,EAAGtD,QACLqB,EAAOvG,QAAUuG,EAAOZ,KAAK,MAC7BY,EAAOZ,KAAK6C,EAAGtD,OACfsD,EAAG/C,QAAUc,EAAOZ,KAAK6C,EAAG/C,WAGzBc,IACNzB,OAAO,CAAC3E,EAAKoG,IAAWpG,EAAIoJ,OAAOhD,OAGtC,OADAwB,EAAMT,IAAM1B,OAAOC,iBAAiByB,GAC7BS,ECxeT,SAASyB,SAASpK,EAAMqK,GACtB,MAAMC,EAAOtK,EAAKqH,WAAWgD,GAG7B,OAAc,QAFArK,EAAKqH,WAAWgD,EAAM,KAO7BC,EAAO,KAAQA,EAAO,IAG/B,SAAgBC,MAAMvK,EAAMwK,GAC1B,IAAIvJ,EAAOuJ,EACPC,EAAKD,EAMT,GAH2C,KAA3BxK,EAAK0K,OAAOF,GAAInJ,SACG+I,SAASpK,EAAMwK,GAE9B,CAClB,KAAOC,EAAK,KACNzK,EAAKqH,WAAWoD,EAAK,GAAK,MADfA,GAKbA,EAAKxJ,IACPA,EAAOwJ,GAKX,KAAOxJ,EAAO,GACPmJ,SAASpK,EAAMiB,EAAO,KADVA,GAOnB,KAAOwJ,EAAKzK,EAAKY,QACVwJ,SAASpK,EAAMyK,KADKA,GAS3B,OAHIxJ,EAAOwJ,IACTxJ,EAAOwJ,IAEDxJ,KAAAA,EAAMwJ,GAAAA,GChDhB,SAASE,kBAAkBC,KAAOC,GAChC,MAAMC,EAAIF,EAAGrI,QACbsI,EAAKrJ,QAASlC,IACRA,KAAOwL,UACFA,EAAExL,KAKf,MAAMyL,SAAW,IAAIC,QAErB,SAAgBC,eAAeL,GAC7B,MAAMhN,EAAKmN,SAAS5C,IAAIyC,GACxB,QAAWrG,IAAP3G,EACF,OAAOA,IAMX,SAASsN,QAAQN,GACf,GAAIG,SAAShD,IAAI6C,GACf,OAAO,EAIT,MAAMO,GACJlK,KAAM2J,EAAGlK,eACT+J,GAAIG,EAAGjK,cAGHyK,EAASnL,SAASC,cAAc,OACtCkL,EAAOC,UAAY,kBACnBT,EAAGU,WAAWC,aAAaH,EAAQR,GAEnC,MAAMY,EAAYvL,SAASC,cAAc,OACzCsL,EAAUH,UAAY,YACtBD,EAAO9K,YAAYkL,GAEnB,IAAIC,EAAU,KACd,MAAMC,EAAezL,SAASC,cAAc,OAC5CwL,EAAaL,UAAY,qBACzBD,EAAO9K,YAAYoL,GAGnB,MAAMlH,EAAe,WACnB,MAAMmH,EAAQ1L,SAASC,cAAc,OACrCyL,EAAMN,UAAY,QAClBD,EAAO9K,YAAYqL,GAEnB,MAAMC,EAAQ3L,SAASC,cAAc,OAGrC,OAFA0L,EAAMP,UAAY,QAEVrL,IACN2L,EAAM3J,YAAchC,EACpB2L,EAAMrL,YAAYsL,GACXA,EAAMC,eAKjBd,SAAS9C,IAAI2C,EAAI,KACf,MAAMkB,MAAUlB,EAAGlK,eAAiBkK,EAAGjK,cAAgB,GACvD,OAAO6D,EAAYoG,EAAGrK,MAAMmK,OAAO,EAAGoB,IAAQlB,EAAGmB,aAIvB,aAAxB9L,SAAS+L,aACXR,EAAUS,UAAUC,IAAI,WACxB5O,OAAOsE,iBAAiB,OAASvC,IAC/B8M,IACAX,EAAUS,UAAUG,OAAO,cAI/B,MAAMD,EAAa,KACjB,GAAIhB,EAAIlK,MAAQkK,EAAIV,GAElB,OADAe,EAAUhL,QAAS,GACZ,EAET,MAAMS,KAACA,EAAIwJ,GAAEA,GAAMU,EAGbkB,EAAO7H,EAAYoG,EAAGrK,MAAMmK,OAAO,EAAGzJ,IACtCmC,EAAQoB,EAAYoG,EAAGrK,MAAMmK,OAAOzJ,EAAMwJ,EAAKxJ,IAEjDmC,EAAQ,IAAMnD,SAASqM,eAAe,SAExC5J,QAAQC,KAAK,sBAAuBS,EAAO,WAAYuI,MAAM3J,aAG/DwJ,EAAUhL,OAAS4C,GAAS,EAC5BoI,EAAUrL,MAAMkM,KAAOA,EAAO,KAC9Bb,EAAUrL,MAAMiD,MAAQA,EAAQ,KAChCoI,EAAUrL,MAAMoM,yBAA2B3B,EAAGmB,gBAG9CL,EAAavL,MAAMoM,yBAA2B3B,EAAGmB,WAAaM,EAAOjJ,QAIjEoJ,EAAW,CAACvL,EAAMwJ,KACtBU,EAAIlK,KAAOA,EACXkK,EAAIV,GAAKzM,KAAKC,IAAIgD,EAAMwJ,GACpBxJ,GAAQwJ,GACVE,kBAAkBC,EAAI,SAAU,OAAQ,SACxCY,EAAUhL,QAAS,GACZ,IAEToK,EAAGrI,QAAe,MAAIqI,EAAGrK,MAAMmK,OAAOzJ,EAAMwJ,EAAKxJ,GACjDkL,KACO,IAoBHM,EAAgB7B,EAAGrK,MAAMK,OACzB8L,GAASjP,MAAOgP,EAAeE,IAAKF,EAAelM,WAAOgE,GAyChE,IAAIqI,KACJ,MAAMC,EAAqB,CAACC,EAAQC,KAE9BD,EAAO/E,IAAI,cAEb6C,EAAGoC,kBAAkB,EAAGpC,EAAGrK,MAAMK,QACxBkM,EAAO/E,IAAI,cAEpB6C,EAAGoC,kBAAkBpC,EAAGrK,MAAMK,OAAQgK,EAAGrK,MAAMK,QACtCkM,EAAO/E,IAAI,UAEpB6C,EAAGoC,kBAAkBN,EAAMjP,MAAOiP,EAAMC,KAK1C,MAAMM,EAxDc,CAACF,IACrB,IAAyB,IAArBA,GACAnC,EAAGlK,iBAAmBgM,EAAMjP,OAC5BmN,EAAGjK,eAAiB+L,EAAMC,KAC1B/B,EAAGrK,QAAUmM,EAAMnM,MACrB,OAAO,EAST,IAPCmM,EAAMjP,MAAOiP,EAAMC,MAAQ/B,EAAGlK,eAAgBkK,EAAGjK,cAC9C+L,EAAMnM,QAAUqK,EAAGrK,QACrBqK,EAAGsC,cAAc,IAAIC,YAAY,SAAUvN,OAAQgL,EAAGrK,SACtDmM,EAAMnM,MAAQqK,EAAGrK,OAIfmM,EAAMjP,QAAUiP,EAAMC,IAOxB,OANAhC,kBAAkBC,EAAI,SAAU,QAEhC4B,EAASE,EAAMjP,MAAOiP,EAAMC,KAE5BnB,EAAUS,UAAUC,IAAI,SACxBtB,EAAGqB,UAAUC,IAAI,UACV,EAETV,EAAUS,UAAUG,OAAO,SAC3BxB,EAAGqB,UAAUG,OAAO,SAGpB,MAAMnL,KAACA,EAAIwJ,GAAEA,GAAM2C,MAAWxC,EAAGrK,MAAOmM,EAAMjP,OAC9C,QAAIwD,GAAQwJ,GAAMsC,IAGdP,EAASvL,EAAMwJ,KAEjBG,EAAGrI,QAAe,MAAIqI,EAAGrI,QAAgB,OAAIqI,EAAGrK,MAAMmK,OAAOzJ,EAAMwJ,EAAKxJ,GAAMoM,cAC9E1C,kBAAkBC,EAAI,SAEjB,KAoBgB0C,CAAcP,GAkBrC,GA5FyB,MACzB,MAAMjJ,EAAI8G,EAAGrI,QAAgB,QAAK,GAKlC,GAJ0B,OAAZkJ,GACG,IAAb3H,EAAElD,QACF6K,EAAQ8B,KAAK7C,OAAO,EAAG5G,EAAElD,UAAYkD,GACK,IAA1C8G,EAAGrK,MAAMmK,OAAOS,EAAIV,IAAIpJ,OAAOT,OAGjC,OADA8K,EAAa1J,YAAc,IACpB,EAET,MAAMsB,EAAUmI,EAAQ8B,KAAK7C,OAAO5G,EAAElD,QAAU6K,EAAQ+B,MAExD,OADA9B,EAAa1J,YAAcsB,GACpB,GAiEFmK,KACHhC,EAAU,MAKRb,EAAGlK,iBAAmBkK,EAAGjK,aAC3BiK,EAAGrI,QAAc,KAAIqI,EAAGrK,MAAMmK,OAAOE,EAAGlK,eAAgBkK,EAAGjK,aAAeiK,EAAGlK,gBAE7EkK,EAAGrI,QAAc,KADI,OAAZkJ,EACYb,EAAGrK,MAAMmK,OAAO,EAAGS,EAAIlK,MAAQ2J,EAAGrK,MAAMmK,OAAOS,EAAIV,IAAMgB,EAAQ+B,MAEjE5C,EAAGrK,MAItB0M,EAAkB,OAGtB,MACMrN,GACJI,KAFW4K,EAAGrI,QAAe,MAAIqI,EAAGrI,QAAgB,QAAKqI,EAAGrI,QAAc,MAAK,KAAO,GAGtFmL,OAAQ,WAAY9C,EAAGrI,QACvB9B,MAAOmK,EAAGrI,QAAe,MACzBoL,UAAY/C,EAAGlK,iBAAmBkK,EAAGjK,cAInCf,EAAOI,OAAS4M,EAAe5M,MAC/BJ,EAAO8N,SAAWd,EAAec,QACjC9N,EAAOa,QAAUmM,EAAenM,OAChCb,EAAO+N,YAAcf,EAAee,YACtCf,EAAiBhN,EACjBgL,EAAGsC,cAAc,IAAIC,YAAY,SAAUvN,OAAAA,OAK/C,IAGImN,EAHAa,GAAkB,EAiDtB,SAASC,EAAaC,GAAc,GAClC,GAAIlD,EAAGjK,aAAewK,EAAIV,GAExB,OAAO,EAGT,MAAMzK,EAAO4K,EAAGrI,QAAgB,QAAK,GACrC,GAAoB,IAAhBvC,EAAKY,SAAiB6K,IAAYA,EAAQ8B,KAAKhO,WAAWS,GAE5D,OAAO,EAGT,MAAM+N,EAAOnD,EAAGrK,MAAMmK,OAAOS,EAAIV,IAC3BuD,EAAcD,EAAKrD,OAAO,EAAGE,EAAGlK,eAAiByK,EAAIV,IAE3D,GAAuB,IADPuD,EAAY3M,OAChBT,OAEV,OAAO,EACF,GAAIkN,IAAgBE,EAAYpN,OAErC,OAAO,EAGT,GAA2B,IAAvBmN,EAAK1M,OAAOT,QAAgB6K,EAAQ8B,OAASvN,EAE/C,OAAO,EAIT6C,GAAG,OAAQ,QAAS,UAAW,UAC/B,MAAMjD,GACJqO,OAAQxC,EAAQ+B,MAChBU,KAAMzC,EAAQ8B,MAGhB,OADA5L,MAAMuL,cAAc,IAAIC,YAAY,SAAUvN,OAAAA,MACvC,GAhFR,WACC,IAAIuO,EACArB,EAAS,IAAIsB,IACjB,MAAMC,EAAShP,IACR8O,IACHpB,OAAmBxI,EACnBuI,EAAOwB,QACPH,EAAQ7Q,OAAOiR,sBAAsB,KACnCJ,EAAQ,KACRtB,EAAmBC,EAAQC,MAG/B1N,GAAMyN,EAAOZ,IAAI7M,EAAGmP,OAIT,mFACRC,MAAM,OAAOjN,QAASkN,GAAU9D,EAAGhJ,iBAAiB8M,EAAOL,IAChEA,IAGAzD,EAAGhJ,iBAAiB,UAAYvC,IAC9BoM,EAAUpM,EAAGO,OACTgO,GACFC,IAEFQ,MAIFzD,EAAGhJ,iBAAiB,YAAcvC,IAC5BA,EAAGsP,OACLN,MAMJpO,SAAS2B,iBAAiB,kBAAoBvC,IACxCY,SAASkC,gBAAkByI,GAC7ByD,MAxCN,GAoFAzD,EAAGhJ,iBAAiB,UAAYvC,IAE9B,OADAuO,GAAkB,EACVvO,EAAGC,KACX,IAAK,SACHyN,GAAmB,EACnB,MAEF,IAAK,YACL,IAAK,OACL,IAAK,UACL,IAAK,KAEH,YADA1N,EAAGiD,iBAGL,IAAK,IACH,MAAMsM,EAAUf,IACZxO,EAAGwP,UACLxP,EAAGiD,iBAEAsM,IAEHhB,GAAkB,MAOxBhD,EAAGhJ,iBAAiB,QAAUvC,IAET,MAAfA,EAAGyP,SAAoBzP,EAAGyP,SAE5BjB,GAAa,KAKhB,WACC,IAAIM,EACJ,MAAMY,EAAkB,KACjBZ,IACHA,EAAQ7Q,OAAOiR,sBAAsB,KACnCJ,EAAQ,KACRhC,QAIN7O,OAAOsE,iBAAiB,SAAUmN,GAClCnE,EAAGhJ,iBAAiB,QAASmN,GAAkBC,SAAS,IAX1D,GAeA,MAAMC,EAAgBC,IACpB,MAAMC,EAAqBvE,EAAGmB,YACxB9K,KAACA,EAAIwJ,GAAEA,GAAMU,EACb5K,EAAQqK,EAAGrK,MAAMmK,OAAOzJ,EAAMwJ,EAAKxJ,GACzC,IAAKxD,EAAOkP,IAAQhL,MAAMjB,eAAgBiB,MAAMhB,cAChD,MAAMyO,EAAMzN,MAAM0N,mBAEZC,EAASJ,EAAK3O,GACpB,GAAc,MAAV+O,EAAkB,OAAO,EAE7B,MAAMC,EAAOtP,SAASkC,cAItBR,MAAMlB,QACNkB,MAAMjB,eAAiBO,EACvBU,MAAMhB,aAAe8J,EACrB,MAAM+E,EAAW7N,MAAMpB,MAAMmK,OAAO,EAAGzJ,GAAQqO,EAAS3N,MAAMpB,MAAMmK,OAAOD,GACtExK,SAASY,YAAY,cAAc,EAAOyO,IAAW3N,MAAMpB,QAAUiP,IAExE7N,MAAMpB,MAAQoB,MAAMpB,MAAMmK,OAAO,EAAGzJ,GAAQqO,EAAS3N,MAAMpB,MAAMmK,OAAOD,IAE1E9I,MAAMuL,cAAc,IAAIC,YAAY,WAEpC,MAAMsC,EAASC,IACTA,GAASjF,EAEXiF,EAAQA,GAASjF,EAAKxJ,GAAQqO,EAAO1O,OAC5B8O,EAAQzO,IAEjByO,EAAQzO,EAAOqO,EAAO1O,QAIjB8O,GAaT,OATChD,EAAMjP,MAAOiP,EAAMC,MAAQ8C,EAAMhS,GAAQgS,EAAM9C,IAChDhL,MAAMqL,kBAAkBN,EAAMjP,MAAOiP,EAAMC,IAAKyC,GAGhDG,GAAQA,EAAK9O,QAEbsM,GAAmB,EACnBnC,EAAGmB,WAAaoD,EAChB3C,EAASvL,EAAMA,EAAOqO,EAAO1O,SACtB,GAITgK,EAAGhJ,iBAAiB,WAAavC,IAC/B,MAAMgF,GAAOsL,CAACtQ,EAAGO,OAAO4O,MAAOnP,EAAGO,OAAO0K,MACzC2E,EAAc1O,GAAUqP,OAAgBrP,EAAO8D,GAAK6D,OAItD0C,EAAGhJ,iBAAiB,QAAUvC,IAC5B,MAAMmO,EAAQnO,EAAGO,OAAOqO,OACnBgB,EAAa,IAAMzB,KAGxB5C,EAAGrI,QAAc,KAAIlD,EAAGO,OAAOsO,MAAQ,GACvCvD,kBAAkBC,EAAI,aCnbX,SAASiF,MAAMzI,EAAK0I,EAAa,EAAGC,EAAe,IAChE,MAAMC,KAEAC,KAkBN,OAjBA7I,EAAI5F,QAAQkG,IACV,MAAMwI,EAAIxI,EAAK,GACfuI,EAAOC,GAAKxI,EAAKyI,MAAM,GAEvB,MAAMzC,EAASwC,EAAExF,OAAO,EAAGoF,GAC3B,IAAK,IAAI3J,EAAI,EAAGA,GAAKuH,EAAO9M,SAAUuF,EAAG,CACvC,MAAMiK,EAAO1C,EAAOhD,OAAO,EAAGvE,GAC9B,IAAIkK,EAAOL,EAAcI,GACpBC,IACHA,EAAOL,EAAcI,OAEnBC,EAAKzP,OAASmP,GAChBM,EAAK9J,KAAK2J,MAKT,SAASI,EAAO5C,GAErB,MAAMK,GADNuC,EAAQA,EAAMjD,eACK3C,OAAOoF,GAC1B,IAAI/O,EAAMiP,EAAcM,EAAM5F,OAAO,EAAGoF,QAUxC,OARI/B,IACFhN,EAAMA,EAAIwP,OAAOrC,GAAQA,EAAKxD,OAAOoF,GAAcvQ,WAAWwO,KAE3DL,IACH3M,EAAMA,EAAIwP,OAAOrC,GAAQA,IAASoC,KAEpCvP,EAAMA,EAAIgJ,IAAImE,IAASA,KAAS+B,EAAO/B,MAE5BtN,OAASG,MC3BxB,SAAgByP,OACd,OAAO,IAAI9R,QAASC,GAAYrB,OAAOC,oBAAoBoB,IAS7D,SAAgB8R,IAAIC,GAClB,YAAcnM,IAAVmM,EACK,IAAIhS,QAASC,IAClBrB,OAAOY,WAAW,IAAMZ,OAAOiR,sBAAsB5P,GAAU+R,KAG5D,IAAIhS,QAASC,GAAYrB,OAAOiR,sBAAsB5P,IAQ/D,SAAgBgS,YACd,OAAOjS,QAAQC,UAejB,SAAgB+R,MAAME,EAAG,GACvB,OAAO,IAAIlS,QAASC,GAAYrB,OAAOY,WAAWS,EAASiS,IFuY7D1F,QAAQvJ,OEpYR,MAAMkP,WAAa,IAAIpJ,IAUvB,SAAgBqJ,SAASC,EAAUL,EAAM,GACvC,IAAIhE,EAAQmE,WAAW1I,IAAI4I,GAC3B,IAAKrE,EAAO,CACVA,GAASxC,EAAG6G,GACZ,MAAMnK,EAAI,IAAIlI,QAASC,GAAY+N,EAAMsE,EAAIrS,GAC7C+N,EAAM9F,EAAIA,EAAEqK,KAAK,KACfJ,WAAWK,OAAOH,GACXrE,EAAMxC,MAEf2G,WAAW5I,IAAI8I,EAAUrE,GAM3B,OAHApP,OAAOe,aAAaqO,EAAMyE,GAC1BzE,EAAMyE,EAAI7T,OAAOY,WAAWwO,EAAMsE,EAAGhT,KAAKC,IAAI,EAAGyS,IAE1ChE,EAAM9F,ECtEf,SAASwK,iBAAiBC,GACxB,MAAMC,EAAQ,IAAIlD,IAClB,OAAOiD,EAAId,OAAO,CAACgB,EAAMpL,KACvB,GAAU,IAANA,EAAS,CACX,GAAImL,EAAMvJ,IAAIwJ,GAAS,OAAO,EAC9BD,EAAMpF,IAAIqF,GAEZ,OAAO,IAaX,SAAgBC,MAAMC,EAAUnC,GAC9B,MAAMoC,KACND,EAASjQ,QAAQ,CAAC6P,EAAKlL,IAAMuL,EAAOL,EAAI,IAAMlL,GAE9CmJ,EAAO9N,QAAS6P,IACd,MAAM1H,EAAQ+H,EAAOL,EAAI,IACzB,QAAc9M,IAAVoF,EAGF,OAFA+H,EAAOL,EAAI,IAAMI,EAAS7Q,YAC1B6Q,EAASlL,KAAK8K,GAKhB,MAAMM,EAAcF,EAAS9H,GACvBiI,EAAcP,EAAIlB,MAAM,GAC9BsB,EAAS9H,GAASyH,iBAAiBO,EAAYxH,OAAOyH,MC1C1D,MAAMC,IAAM,oCACNC,YAAc,EACdC,eAAiB,IAYvB,SAASC,UAAU1S,EAAK2S,EAAO,GAAIzU,EAAS,UAC1C,IAAI0U,EAIJ,MAAM9K,EAAM9J,OAAO6U,aAAa7S,GAChC,GAAI8H,EAAK,CACP,IAAIc,EACJ,IACEA,EAAMkK,KAAKC,MAAMjL,GACjB,MAAOtG,GACP4B,QAAQ0C,MAAM,8BAAgC9F,EAAKwB,GACnDoH,EAAM,KAER,GAAIA,GAAOA,EAAa,UACtBgK,EAAiBxT,QAAQC,QAAQuJ,EAAa,SAC1CA,EAAa,UAAM,IAAIoK,KAAQ,KAAiBL,GAElD,MAAO,IAAMC,EAOnB,MAAMvK,EAAI,IAAIjJ,QAAQ,CAACC,EAASC,KAC9B,MAAMC,EAAM,IAAIC,eAChBD,EAAIE,KAAK,SAAU8S,OAAOvS,KAC1BT,EAAIG,QAAUJ,EACdC,EAAI0T,aAAe,OACnB1T,EAAII,OAAS,KAAMN,EAAQE,EAAI2T,WAC/B3T,EAAIK,SACH+R,KAAM7J,GAEe,iBAARA,EAAmBgL,KAAKC,MAAMjL,GAAOA,GAClD6J,KAAM3B,IACP4C,EAAiBvK,EAGjB2H,EAAgB,SAAK,IAAIgD,KACzBhV,OAAO6U,aAAa7S,GAAO8S,KAAKK,UAAUnD,GAGnCA,EAAgB,UAIzB,OAAK4C,EAME,IAAMA,GALX1U,GAAS,GACTmK,EAAEsJ,KAAK,IAAMzT,GAAS,IACf,IAAMmK,GAWjB,MAAM+K,aAAgB,WACpB,MAAMC,EAASX,UAAU,UAAW,GAAKY,IAEvCtV,OAAOqV,OAAOnS,QAAUoS,IAE1B,MAAO,IACED,IAAS1B,KAAM4B,GAAYhD,MAAMgD,OAStCC,iBAAoB,WACxB,MAAMH,EAASX,UAAU,MAAO,GAChC,MAAO,IACEW,IAAS1B,KAAM4B,IACpB,IAAI3K,KAIJ,OAHA2K,EAAQrR,QAASkG,IACfQ,EAAMA,EAAIiC,OAAOzC,EAAKyI,MAAM,MAEvBjI,OAab,SAAgB6K,QAAQ/S,EAAM0N,EAAQsF,GAAK,GACzC,IAAKhT,EAAM,CACT,GAAIgT,GAAiB,KAAThT,EAAa,CACvB,MAAMgR,EAAIiC,SAGV,OAFAjC,EAAEkC,QAAQ,WAEHJ,mBAAmB7B,KAAMrK,IAC9BA,EAAEsM,QAAQ,cACFlC,EAAGpK,KAIf,OAAOlI,QAAQC,YAGjB,MAAMwU,EAAeT,eAAezB,KAAMxF,GAAYA,EAAQzL,EAAM0N,IACpE,IAAKsF,EACH,OAAOG,EAIT,IAAI3U,KAASqT,WAAWvU,OAAO8V,mBAAmBpT,KAC7C0N,IACHlP,GAAO,UAET,MAAM6U,EAAc/V,OAAOgW,MAAM9U,GAAKyS,KAAM/I,GAAQA,EAAIqL,QAAQtC,KAAM/I,GAAQA,EAAa,SAC3F,OAAOxJ,QAAQqC,KAAKoS,EAAcE,IAAcpC,KAAMuC,IACpD,MAAOC,EAAOT,GAAQQ,EAEtB,OADAE,MAAcD,EAAOT,GACdS,IAWX,MAAaE,OAAU,WACrB,IAAIC,KAEJ,MAAMC,EAAS,KACb,MAAMpV,EAAO2T,KAAKK,UAAUmB,GAE5B,OADAA,KACOtV,UAAUC,WAAWsT,IAAM,OAAQpT,IAG5C,OAAO,SAAgB8O,EAAMC,GAC3B,GAAgB,MAAZD,EAAK,GACP,OAGF,MAAMyD,EAAIiC,SACJtJ,EAAQqH,EAAExR,QAAQgO,GAUxB,OATe,IAAX7D,GACFqH,EAAE8C,OAAOnK,EAAO,GAElBqH,EAAEkC,QAAQ1F,GACVwD,EAAE8C,OA1Kc,GA2KhBxW,OAAO6U,aAAqB,OAAInB,EAAE+C,KAAK,KAGvCH,EAAQrG,GAAQC,EACTwG,SAAkBH,EA9KN,SAyLvB,SAAgBI,OAAO1G,EAAMC,GAC3B,MAAM/O,EAAO,IAAIyV,SAGjB,OAFAzV,EAAK0V,OAAO,OAAQ5G,GACpB9O,EAAK0V,OAAO,QAAS3G,GACdlQ,OAAOgW,MAAMzB,IAAM,SAAUuC,OAAQ,OAAQC,KAAM,OAAQ5V,KAAAA,IAQpE,SAAgBwU,SACd,OAAQ3V,OAAO6U,aAAqB,QAAK,IAAI1D,MAAM,KAAK8B,OAAQ+D,GAAMA,GCnMxE,MAEMC,gBAAkB,EAClBC,iBAAmB,UAEJC,OACnB9E,YAAY/R,GACV8W,KAAKC,IAAM/W,EACX8W,KAAKE,UACLF,KAAKG,SAAW,KAEhBH,KAAKI,UAAUC,MAAOC,IAEpB,MADAtS,QAAQE,KAAK,uBAAwBoS,GAC/BA,IAIVrF,gBAKE,UAJM,IAAIjR,QAASC,GAAY+V,KAAKG,SAAWlW,GAC/C+V,KAAKG,SAAW,WACVI,SAEG,CACP,GAAIP,KAAKQ,SACP,OAAOR,KAAKI,gBAERK,OASVxF,SACE,MAAMlS,EAAQH,OAAOI,YAAYC,MAEjC,IAAIyX,EAAO,EACX,KAAOV,KAAKE,OAAOhU,QAAQ,CACzB,MAAM4H,EAAOkM,KAAKE,OAAOS,QAIzB,GAHA7M,EAAK7J,QAAQ+V,KAAKC,IAAInM,EAAKnE,QACzB+Q,GAEUZ,kBAAoBlX,OAAOI,YAAYC,MAAQF,EAAQ8W,gBACjE,MAIJ,OAAQG,KAAKE,OAAOhU,OAGtB+O,KAAKtL,GACH,OAAO,IAAI3F,QAASC,IAClB+V,KAAKE,OAAOrO,MAAM5H,QAAAA,EAAS0F,IAAAA,IAC3BqQ,KAAKG,UAAYH,KAAKG,cCvD5B,MAGMnH,OAAS,OACT4H,GAAKhY,OAAO6U,aACZoD,MAAQ,IAAI9N,IAElB,SAASoM,OAAOrG,GACd,MAAMtF,EAAM7C,iBAAiBmI,GAK7B,OAJA+H,MAAMtN,IAAIuF,EAAOtF,GACbA,IACFoN,GAAG5H,OAASF,GAAS,KAEhBtF,EAGT,MAAMsN,OAAS,IAAIf,OAAOZ,QAE1B,SAAS4B,UAAUjI,GACjB,MAAMiI,EAAYF,MAAMpN,IAAIqF,GAC5B,YAAkBjJ,IAAdkR,EACKA,EAEFH,GAAG5H,OAASF,GASrBkI,eAAsBC,MAAMnI,GAC1B,MAAMlJ,EAASmR,UAAUjI,GACzB,YAAejJ,IAAXD,EACKA,EAEFkR,OAAOI,KAAKpI,GAWrBkI,eAAsBG,eAAeC,EAAStY,GAC5C,IAAIuY,GAAkB,EAEtB,IAAK,IAAI5P,EAAI,EAAGA,EAAI2P,EAAQlV,SAAUuF,EAAG,CACvC,MAAMkL,EAAMyE,EAAQ3P,GACpB,IAAK,IAAI0B,EAAI,EAAGA,EAAIwJ,EAAIzQ,SAAUiH,EAAG,CACnC,MAAM2F,EAAQ6D,EAAIxJ,GAClB,IAAIvD,EAASmR,UAAUjI,GAUvB,QATejJ,IAAXD,IAEGyR,IACHvY,EAAS,MACTuY,GAAkB,GAEpBzR,QAAekR,OAAOI,KAAKpI,IAGzBlJ,EACF,OAAO9G,GAAU+P,KAAM8D,EAAI,GAAI7D,MAAAA,KAKhCuI,GACHvY,EAAS,YC5DPwY,cACJrG,YAAYsG,GACVvB,KAAKwB,QAAUD,EAGfvB,KAAKyB,SAAW,IAAI1O,IAGpBiN,KAAK0B,SAAW,IAAI3O,IAGpBiN,KAAK2B,cAAgB,IAAIrL,QAGzB0J,KAAK4B,eAELhZ,OAAOC,oBAAoB,KACzB,IAAK,IAAI4I,EAAI,EAAGA,EAAI,KAAMA,EACxBuO,KAAK4B,YAAY/P,KAAKtG,SAASC,cAAc,aAIjD,MAAMqW,EAAiBtW,SAASC,cAAc,OAC9CwU,KAAKwB,QAAQ5V,YAAYiW,GAGzB7B,KAAK8B,YAAc,MACjB,MAAMC,EAAeT,cAAcU,YAAY,WAAY,UACrDC,EAAaX,cAAcU,YAAY,WAAY,QACzDH,EAAejW,YAAYmW,GAC3BF,EAAejW,YAAYqW,GAG3B,MAAMC,EAAuB,CAAC5W,EAAMO,EAAM,QACxC,MAAMkB,EAASxB,SAASC,cAAc,UAGtC,OAFAuB,EAAOO,YAAchC,EACrByB,EAAOc,QAAe,MAAIhC,EACnBkB,GAIHoV,GACJD,EAAqB,SAAY,IACjCA,EAAqB,SAAY,KACjCA,EAAqB,eAAoB,MACzCA,EAAqB,SAAY,KACjCA,EAAqB,eAAoB,OAIrCE,GACJF,EAAqB,SAAY,KAEnC,IAAK,IAAIzQ,EAAI,OAASA,GAAK,SAAWA,EACpC2Q,EAAMvQ,KAAKqQ,EAAqBpQ,OAAOC,cAAcN,GAAIA,IAI3D,MAAM4Q,EAAe,CAACC,EAAKC,EAAMC,KAC/BF,EAAME,EAAM5W,YAAY2W,GAAQA,EAAK7K,UAEvC,OAAO,SAASxJ,GACd,MAAMuU,EACFZ,EAAea,SAASnX,SAASkC,eAAiBlC,SAASkC,cAAgB,KAC/E0U,EAAQrV,QAASyV,IACf,MAAMI,EAAIJ,EAAK1U,QAAe,MAAE3B,OAC1BoW,GAAQK,GAAKzU,EAAKiG,OAAOR,SACjB,IAANgP,GAAWzU,EAAKiG,OAAOT,QACjB,IAANiP,GAAWzU,EAAKiG,OAAOC,OAC/BiO,EAAaC,EAAKC,EAAMR,KAE1BK,EAAMtV,QAASyV,GAASF,EAAanU,EAAKgG,KAAMqO,EAAMN,IAGtDJ,EAAehL,aAAakL,EAAcA,EAAaa,aACvDf,EAAehL,aAAaoL,EAAYA,EAAWW,aAGnDH,GAAUA,EAAO1W,UApDF,GAyDrBkP,mBAAmBnB,EAAMjO,GACvB,MAAM0W,EAAOhX,SAASC,cAAc,OAIpC,OAHA+W,EAAK5L,UAAY,WAAamD,EAC9ByI,EAAK1U,QAAQiM,GAAQjO,EACrB0W,EAAK1U,QAAc,KAAIhC,EAChB0W,EAGTtH,eAAepC,GACb,MAAMgC,EAAOmF,KAAKyB,SAAShO,IAAIoF,GAC/B,GAAIgC,EACF,OAAOA,EAET,MAAM0H,EAAOhX,SAASC,cAAc,OASpC,OARA+W,EAAK5L,UAAY,UACjB4L,EAAKM,aAAa,cAAehK,GAEjB,MAAZA,EAAK,KACP0J,EAAKhL,UAAUC,IAAI,WACnBqB,EAAOA,EAAK7C,OAAO,IAErBuM,EAAKM,aAAa,YAAahK,GACxB0J,EAWTtH,YAAY6H,EAAQhK,GAClB,IAAI/L,EAASiT,KAAK0B,SAASjO,IAAIqF,GAC/B,GAAI/L,EAAQ,CAGV,MAAMgW,EAAS/C,KAAK2B,cAAclO,IAAI1G,GACtC,GAAe,OAAXgW,EACF,OAAOhW,EACF,QAAe8C,IAAXkT,EAET,OADAD,EAAOlX,YAAYmB,GACZA,OAIPA,EAD8B,IAA5BiT,KAAK4B,YAAY1V,OACV8T,KAAK4B,YAAYoB,MAEjBzX,SAASC,cAAc,WAE3B8B,YAAcwL,EACrBkH,KAAK0B,SAASnO,IAAIuF,EAAO/L,GAEzBkU,MAAMnI,GAAOyD,KAAM0G,IACjB,IAAKA,EACH,OAAOjD,KAAK2B,cAAcpO,IAAIxG,EAAQ,MAGxC,MAAMwV,EAAOvC,KAAK2B,cAAclO,IAAI1G,GACpCwV,EAAK3L,WAAWsM,aAAanW,EAAQwV,GACrCvC,KAAK2B,cAAcnF,OAAOzP,KAI9B,MAAMwV,EAAOhX,SAAS4X,eAAe,IAIrC,OAHAnD,KAAK2B,cAAcpO,IAAIxG,EAAQwV,GAC/BO,EAAOlX,YAAY2W,GAEZxV,EAWTkO,OAAOkD,GACL,MAAMiD,EAAU,IAAIrO,IACdvG,EAAU,IAAIuG,IACdqQ,EACFpD,KAAKwB,QAAQkB,SAASnX,SAASkC,eAAiBlC,SAASkC,cAAgB,KAE7E0Q,EAAQrR,QAAS8C,IACf,MAAMiJ,EAAOjJ,EAAO,GAEdkT,EAAS9C,KAAKqD,eAAexK,GACnCuI,EAAQ7N,IAAIsF,EAAMiK,GAClB9C,KAAKyB,SAASjF,OAAO3D,GACrBmH,KAAKwB,QAAQ5V,YAAYkX,GAIzB,IAAK,IAAIrR,EAAI,EAAGA,EAAIqR,EAAOQ,SAASpX,SAAUuF,EAAG,CAC/C,MAAM8R,EAAIT,EAAOQ,SAAS7R,GACpBqH,EAAQyK,EAAEjW,YACZd,EAAQ6G,IAAIyF,IACdyK,EAAE7L,SACFsI,KAAK4B,YAAY/P,KAAK0R,KACpB9R,GAGJjF,EAAQ+G,IAAIuF,EAAOyK,GAGrB,IAAK,IAAWzK,EAAPrH,EAAI,EAAUqH,EAAQlJ,EAAO6B,KAAMA,EACtCjF,EAAQ6G,IAAIyF,IAIhBtM,EAAQ+G,IAAIuF,EAAOkH,KAAKwD,YAAYV,EAAQhK,MAIhDkH,KAAKyB,SAAS3U,QAASgW,IAErB,IAAK,IAAIrR,EAAI,EAAGA,EAAIqR,EAAOQ,SAASpX,SAAUuF,EAC5CuO,KAAK4B,YAAY/P,KAAKiR,EAAOQ,SAAS7R,IAExCqR,EAAOpL,WAETsI,KAAKyB,SAAWL,EAChBpB,KAAK0B,SAAWlV,EAEZ4W,IACE7X,SAASxB,KAAK2Y,SAASU,GACzBA,EAAsBrX,QAEtBkB,MAAMlB,UAOd,IAAI0X,WAAa,EACjBC,QAAQxW,iBAAiB,QAAUvC,IAClB,MAAXA,EAAGC,KAAuC,WAAxBD,EAAGoY,OAAOY,YAChCF,WAAa7a,OAAOY,WAAW,IAAMia,WAAa,EAAG,MAIvD,IAAIG,yBAAsB/T,EACtBgU,gBAAiB,EAerB,SAASC,8BAA8BC,GACrC,MAAMC,GAAQC,KAAMC,EAAAA,EAAUnX,OAAQ,MAEhCoX,EAAe5Y,SAASkC,cAAcyB,wBAEtCyI,OAAgC9H,IAAxB+T,oBAAoCA,oBAAsBO,EAAaxM,KAErF,IAAIyM,OAAYvU,EAChB,IAAK,IAAI4B,EAAI,EAAGA,EAAIsS,EAAM7X,SAAUuF,EAAG,CACrC,MAAM1E,EAASgX,EAAMtS,GACf4S,EAAgBtX,EAAOmC,wBAE7B,GAAIiV,EAAaG,MAAQD,EAAcC,IAAO,SAC9C,QAAkBzU,IAAduU,EACFA,EAAYC,EAAcC,SACrB,GAAID,EAAcC,MAAQF,EAC/B,MAGF,MAAMH,EAAO3a,KAAKib,IAAIF,EAAc1M,KAAOA,GACvCsM,EAAOD,EAAKC,QACbD,EAAKC,KAAMD,EAAKjX,SAAWkX,EAAMlX,IAItC,IAAKiX,EAAKjX,OACR,OAAO,EAET8W,gBAAiB,EACjB,IACEG,EAAKjX,OAAOhB,gBAEZ8X,gBAAiB,EAEnB,OAAO,EA9CTH,QAAQxW,iBAAiB,QAAUvC,IAC5BkZ,iBACHD,oBAAsBrY,SAASkC,cAAcyB,wBAAwByI,QAEtE,GA8CH+L,QAAQxW,iBAAiB,QAAUvC,IACjCiZ,yBAAsB/T,EACtB,MAAM2U,EAAanW,gBAAyB1D,GAE5C,IAAI8Z,OAAQ5U,EACZ,MAAM0T,EAAI5Y,EAAGoY,OACb,GAAoB,WAAhBQ,EAAEI,gBAEC,GAAIJ,EAAE3M,WAAW/I,QAAkB,SAAG,CAC3C,GAAIlD,EAAGwP,SACL,OAGF,MAAMtO,EAAQ,UAAW0X,EAAE1V,SAAY0V,EAAE1V,QAAe,OAAK0V,EAAE1V,QAAe,MAAK,KAC7E3C,GAAU4O,KAAMyJ,EAAE3M,WAAW/I,QAAkB,SAAG+H,KAAM/J,GAC9DoB,MAAMuL,cAAc,IAAIC,YAAY,YAAavN,OAAAA,KACjDuZ,EAAQ,gBACH,GAAIlB,EAAE3M,WAAW/I,QAAgB,OAAG,CACzC,GAAIlD,EAAGwP,SAAU,CACXpM,SAAgBwV,EAAEjW,cACpBa,GAAG,OAAQ,QAAS,UAAW,QAIjC,MAAMuW,EAAYnZ,SAASoZ,iBAAiBD,UAG5C,OAFAF,EAAajB,EAAExX,QAAUkB,MAAMlB,aAC/BR,SAASoZ,iBAAiBD,UAAYA,GAMxC,MACMlL,EAD6B,IAAfiK,YAAoB9Y,EAAGia,SAAWja,EAAGka,QAC/BtB,EAAE3M,WAAW/I,QAAgB,OAAI,KAErD3C,GAAUqO,OAAQgK,EAAEjW,YAAakM,KAAAA,GACvCvM,MAAMuL,cAAc,IAAIC,YAAY,SAAUvN,OAAAA,KAC9C4Z,OAAgBvB,EAAE3M,WAAW/I,QAAgB,OAAG3C,EAAOqO,QACvDkL,EAAQ,QAILA,IAELtW,GAAG,OAAQ,QAAS,UAAW,QAASsW,GAEnCD,GACHvX,MAAMlB,WAKVkB,MAAMC,iBAAiB,UAAYvC,IACjC,GAAe,cAAXA,EAAGC,KAAkC,SAAXD,EAAGC,IAAgB,CAC/C,MAAMma,EAAY9X,MAAMiC,wBACxB0U,oBAAsBmB,EAAUpN,KAAOqN,eAAqB/X,OAExD6W,8BAA8BJ,QAAQjX,iBAAiB,YACzD0B,GAAG,OAAQ,QAAS,UAAW,oBAE5B,GAAe,eAAXxD,EAAGC,KAAmC,UAAXD,EAAGC,IAAiB,CACxD,MAAM+X,EAAI1V,MAAMpB,MAAMK,OACtB,GAAIe,MAAMhB,eAAiB0W,GAAK1V,MAAMjB,iBAAmB2W,EAAG,CAC1D,MAAMpO,EAAQmP,QAAQuB,cAAc,UACpC1Q,GAASA,EAAMxI,YAMrB2X,QAAQxW,iBAAiB,UAAYvC,IACnC,MAAMua,EAAQC,eAAwBxa,GACtC,IAAKua,EAAS,OAEd,IAAKxB,QAAQhB,SAASnX,SAASkC,eAAkB,OAGjD,MAAM2X,EAAc9Y,MAAMC,KAAKmX,QAAQjX,iBAAiB,WAClDwI,EAAQmQ,EAAYta,QAAQS,SAASkC,eAC3C,IAAe,IAAXwH,EAAgB,OAGpB,IAAIoQ,EAkBAtB,EAZJ,GALc,cAAVmB,EACFG,GAAS,EACU,eAAVH,IACTG,EAAQ,GAENA,EAAJ,CACE,MAAMtC,EAAS9N,EAAQoQ,EACnBtC,GAAU,GAAKA,EAASqC,EAAYlZ,OACtCkZ,EAAYrC,GAAQhX,QACXgX,EAAS,IAClB9V,MAAMlB,QACNkB,MAAMuL,cAAc,IAAIC,YAAY,oBANxC,CAaA,GAAc,YAAVyM,GACFnB,EAAQqB,EAAY3J,MAAM,EAAGxG,IACvBqQ,cACD,CAAA,GAAc,cAAVJ,EAGT,OAFAnB,EAAQqB,EAAY3J,MAAMxG,GAU5B,GALK6O,8BAA8BC,IACnB,YAAVmB,GACFjY,MAAMlB,QAGI,cAAVmZ,EAAuB,CAEzB,MAAMK,EAAYha,SAASkC,cAAcyB,wBACnC3F,EAAMgc,EAAUjB,IAAMiB,EAAUC,OAClC5c,OAAO6c,YAAclc,EAAM,IAC7BoB,EAAGiD,qBAKR,WACC,MAEM8X,EAAU,IAAIpE,cAAcoC,SAElC,IAAIiC,KACAC,EAAkB5c,YAAYC,MAC9B4c,KAEAC,EAAgB,EACpB,SAASC,EAAYC,GACnB,MAAMC,IAAuBH,EAC7B,IAAKE,EAEH,YADA/Y,MAAMuL,cAAc,IAAIC,YAAY,WAAYvN,OAAQ,QAI1D,IAAIgb,EAAa,KACjB,MAAMC,EAAeN,EAAgBpK,QAAQI,OAAQc,GAC/CqJ,EAAE9Z,OAAS,GAAKyQ,EAAI,KAAOqJ,GAC7BE,EAAavJ,GACN,GAEFA,EAAI,GAAG9R,WAAWmb,IAE3BE,GAAcC,EAAa3H,QAAQ0H,GAOnC/E,eAAegF,EALGvW,IACZqW,IAAuBH,GACzB7Y,MAAMuL,cAAc,IAAIC,YAAY,WAAYvN,OAAQ0E,OAO9D3C,MAAMC,iBAAiB,QAAUvC,IAC/B,MAAMyb,EAAQzb,EAAGO,OACXjC,EAAMD,YAAYC,MAGlBiF,EAAOgN,QAAiBvQ,EAAGO,OAAO8N,QAAUrO,EAAGO,OAAOa,OAAS,IACrE2Z,EAAQ5D,YAAY5T,GAEhByX,EAASra,OAAS8a,EAAM9a,MAE1Bya,EAAYK,EAAM9a,MAMpB,MAAM+a,EAAcV,EAASra,MAAQ8a,EAAM9a,MAAiC,IAAzBqa,EAASra,KAAKY,QAC7DyZ,EAASra,KAAKT,WAAWub,EAAM9a,KAAK0K,OAAO,EAAG2P,EAASra,KAAKY,WAAY,EAE5E,IAAI6U,GAAY,EACX4E,EAASra,MAAQqa,EAAS3M,SAAWoN,EAAMpN,OAErC/P,EAAM2c,EAzDF,MA0Db7E,GAAY,GAFZA,GAAY,EAId4E,EAAWS,EACXR,EAAkB3c,EAElB,MAAMoV,EAAU2C,MAAO5T,EAAQ,EAAGkR,GAAK,KACrC,GAAIlR,UACIqT,IAAarT,GACfuY,IAAaS,GAAS,OAAQ,EAEpC,MAAMjI,QAAgBmI,QAAiBF,EAAM9a,KAAM8a,EAAMpN,OAAQsF,GACjE,OAAIqH,IAAaS,GAAiB,GAGlCP,EAAkB1H,EAClB4H,EAAYK,EAAM9a,MAEXoa,EAAQ9K,OAAOuD,KAGdE,EAAQ0C,EAAY,EA7Ed,IA6E6BsF,GAAa9J,KAAM0E,IAC9D,GAAIA,EAAQ,EAAK,OAAQ,EAEzB,IAAKmF,EAAM9a,KAET,OAAO+S,EAAQ,MAAM,GAGvB,MAAMjR,EAAU9D,KAAKC,IAAI,IAAM,IAAMD,KAAKid,IAAItF,EAAO,MACrD,OAAO5C,EAAQjR,GAAS,KACvBiT,MAAOC,IACRtS,QAAQwY,MAAM,sBAAuBlG,OA1F3C,GCnaC,SAASnT,EAAOsZ,GACf,MAAMC,EAAOD,EAASxB,cAAc,QAC9B0B,EAAQD,EAAKzB,cAAc,SAC3BlY,EAAS2Z,EAAKzB,cAAc,UAElC,IAAIpZ,EAAQ,GACRqT,EAAU,KAEd/R,EAAMD,iBAAiB,QAAUvC,IAC/B,MAAMyb,EAAQzb,EAAGO,OACX+N,EAA4B,OAAfmN,EAAM9a,WAAiCuE,IAAhBuW,EAAMra,OAAuBqa,EAAMnN,UAE7E,GADApN,EAAQua,EAAMra,OACTkN,EAKH,OAJKiG,IACHyH,EAAM9a,MAAQ,GACd4a,EAAS3a,QAAS,IAEb,EAGT2a,EAAS3a,QAAS,IAGpB,MAAMY,EAAU/B,IACdoC,EAAOC,UAAY2Z,EAAM9a,OAE3B,eAAekO,MAAM,OAAOjN,QAAQgN,GAAQ6M,EAAMzZ,iBAAiB4M,EAAMpN,IAEzEga,EAAKxZ,iBAAiB,SAAWvC,IAE/B,GADAA,EAAGiD,iBACCsR,EACF,OAAO,EAGTwH,EAAKnP,UAAUC,IAAI,WACnBmP,EAAM3Z,UAAW,EACjBD,EAAOC,UAAW,GAclBkS,EAAU0H,OAAgBD,EAAM9a,MAAOA,GAAO0Q,KAAMuB,IAClD,IAAKA,EAASrN,GACZ,MAAM,IAAI6C,MAAMwK,EAAS+I,QAG3B,OADA9Z,EAAOwK,UAAUC,IAAI,YACd,IACN6I,MAAMC,IACPvT,EAAOwK,UAAUC,IAAI,WACrBxJ,QAAQC,KAAK,yBAA0BqS,IAChC,IACN/D,KAtBauK,IACdJ,EAAKnP,UAAUG,OAAO,WACtBiP,EAAM3Z,UAAW,EACjB2Z,EAAM9a,MAAQ,GACd8a,EAAMnO,cAAc,IAAIC,YAAY,WAEpCyG,EAAU,KACLrT,IACH4a,EAAS3a,QAAS,MAgBdyQ,KAAK,IAAMwK,MAAe,MAAOxK,KAAK,KAC5CxP,EAAO4J,UAAY,OA/DzB,CAkEE1J,MAAOwZ,UClET,MAEM5a,MAASlB,IACb,MAAMW,EAAOX,EAAGO,OAAOyB,OACvBpB,SAASxB,KAAKwN,UAAUyP,OAAO,YAAana,QAAQvB,KAgCtD,SAAS2b,aAAa1E,GACpB,OAAOA,aAAgB2E,SAAW3E,EAAKhL,UAAUmL,SAAS,UA/B5DzV,MAAMC,iBAAiB,QAASrB,OAChCA,OAAOX,OAAQ+B,MAAMpB,QAGrBN,SAASxB,KAAKmD,iBAAiB,UAAYvC,IACzC,OAAQA,EAAGC,KACX,IAAK,SAEH,GAAIW,SAASkC,gBAAkBR,MAAO,CACpCA,MAAMlB,QACN,MAIF,GAAIkB,MAAMjB,iBAAmBiB,MAAMhB,aAAc,CACd,aAA7BgB,MAAM0N,mBACR1N,MAAMjB,eAAiBiB,MAAMhB,aAE7BgB,MAAMhB,aAAegB,MAAMjB,eAE7B,MAIF,MAAM2W,EAAI1V,MAAMpB,MAAMK,OACtBe,MAAMqL,kBAAkBqK,EAAGA,MAS/BpX,SAAS2B,iBAAiB,kBAAoBvC,IAC5C,MAAMyE,EAAIxG,OAAOue,gBACVC,WAAYC,EAAGC,UAAW/D,GAAKnU,EAClCiY,IAAM9D,GAAK0D,aAAaI,IAAMJ,aAAa1D,KAC7CnU,EAAEmY,kBACFta,MAAMlB,QACNkB,MAAMuL,cAAc,IAAIC,YAAY,kBAErC,GAEHlN,SAAS2B,iBAAiB,UAAYvC,IACpC6c,YAAqBjL,KAAK,KACpBhR,SAASkC,gBAAkBlC,SAASxB,MACtCkD,MAAMlB,YAMZ,MAAM0b,OAAU9c,IACd,MAAM6a,EAAS5c,OAAO6c,YACtBla,SAASxB,KAAK0B,MAAMic,aAAelC,OAErC5c,OAAOsE,iBAAiB,SAAUua,QAClC7e,OAAOsE,iBAAiB,OAAQua,QAChCA,SAGA,IAAIE,eAAiB,KAErB,SAASC,gBACPrc,SAASxB,KAAKwN,UAAUG,OAAO,eAC/BiQ,eAAiB,KAGnB/e,OAAOsE,iBAAiB,sBAAwBvC,IAC9CwD,GAAG,OAAQ,QAAS,UAAW,aAC/B5C,SAASxB,KAAKwN,UAAUC,IAAI,eAC5BmQ,eAAiBhd,EACjBA,EAAGiD,kBACI,IAGThF,OAAOsE,iBAAiB,eAAiBvC,IACvCwD,GAAG,OAAQ,QAAS,UAAW,aAC/ByZ,kBAGF,MAAMC,UAAYtc,SAASqM,eAAe,WAC1CiQ,UAAU3a,iBAAiB,QAAUvC,IAC9Bgd,iBAGLA,eAAeG,SAEVH,eAAeI,YAIpBJ,eAAeI,WAAWxL,KAAM3M,IAC9BzB,GAAG,OAAQ,QAAS,UAAWyB,KAE9ByQ,MAAOC,IACRtS,QAAQC,KAAK,6BAA8BqS,KAC1C/D,KAAKqL,kBCxGV,MAAMI,QAAUzc,SAASqM,eAAe,WAExC,SAASqQ,UACP,MAAMxF,EAASuF,QAAQ/C,cAAc,WAC/BnR,EAAQ2O,GAAUA,EAAOyF,oBAAsBF,QAAQG,kBACxDrU,GAKL2O,GAAUA,EAAOlL,UAAUG,OAAO,UAClC5D,EAAKyD,UAAUC,IAAI,UAEnB4Q,WAPEpa,QAAQC,KAAK,6BAUjB,IAAIb,QACJ,SAASgb,UACPxf,OAAOe,aAAayD,SACpBA,QAAUxE,OAAOY,WAAW,KAC1BZ,OAAOiR,sBAAsBoO,UAC5B,KCzBL,GD4BAG,UC5BIxe,UAAUye,cAAe,CAC3Bze,UAAUye,cAAcC,SAAS,WAAWjI,MAAOC,IACjDtS,QAAQC,KAAK,wBAAyBqS,KAGxC,MAAMiI,EAAuB1b,QAAQjD,UAAUye,cAAcG,YAC7D5e,UAAUye,cAAcnb,iBAAiB,mBAAoB,KACvDqb,IAEFva,QAAQ0C,MAAM,mCACd9H,OAAO0H,SAASmY,YCRtB,IAAIC,YAAa,EAEjB,SAASC,eACH,WAAY/e,WAAa8e,aAAe9e,UAAUgf,SACpDza,GAAG,OAAQ,QAAS,UAAWvE,UAAUgf,OAAS,SAAW,WAC7DF,WAAa9e,UAAUgf,QAI3BD,eACA/f,OAAOsE,iBAAiB,SAAU,IAAMkP,SAASuM,eACjD/f,OAAOsE,iBAAiB,UAAW,IAAMkP,SAASuM,eCFlD/f,OAAO0B,QAAU,EAACue,EAAKC,EAAMC,EAAMC,EAAKxC,KACtCxY,QAAQE,KAAK,UAAW4D,OAAO+W,IAC/B,IACE1a,GAAG,OAAQ,QAAS,WAAY2a,KAAQC,KAAQC,IAAOlX,OAAO+W,IAAOI,gBAAgB,IACrF,MAAO7c","file":"bundle-1412334fdb.js","sourcesContent":["\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nif (!window.requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = (callback) => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\nif (!navigator.sendBeacon) {\n  navigator.sendBeacon = function(url, body) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', url, true);\n      xhr.onerror = reject;\n      xhr.onload = resolve;\n      xhr.send(body);\n    });\n  };\n}\n","\nconst arrowKeys = ['Left', 'Right', 'Up', 'Down'];\n\n/**\n * @param {!Event} ev\n * @return {?string} one of \"Arrow{Left,Right,Up,Down}\" if this is a keyboard event of that arrow\n */\nexport function arrowFromEvent(ev) {\n  if (!ev.key) {\n    return null;\n  }\n  if (ev.key.startsWith('Arrow')) {\n    return ev.key;\n  }\n  if (arrowKeys.indexOf(ev.key) === -1) {\n    return null;\n  }\n  return 'Arrow' + ev.key;\n}\n\n/**\n * @param {!Event} ev\n * @return {boolean} whether this is probably a keyboard/non-mouse click\n */\nexport function isKeyboardClick(ev) {\n  if (!(ev instanceof MouseEvent)) {\n    return true;\n  }\n  return (ev.screenX === 0 && ev.detail === 0) || ev.webkitForce === 0;\n}","\nlet dummy;\n\nexport function copyText(text) {\n  if (!dummy) {\n    dummy = document.createElement('input');\n    dummy.style.position = 'fixed';\n    dummy.style.opacity = 0;\n    document.body.appendChild(dummy);\n  }\n\n  dummy.value = text;\n  try {\n    dummy.hidden = false;\n    dummy.focus();\n    dummy.selectionStart = 0;\n    dummy.selectionEnd = dummy.value.length;\n    document.execCommand('copy');\n  } catch (e) {\n    return false;\n  } finally {\n    dummy.hidden = true;\n  }\n\n  return true;\n}","\n/**\n * @fileoverview Handles the buttons in the top-right of the page (currently just Copy).\n */\n\nimport * as eventlib from './lib/event.js';\nimport * as copier from './lib/copier.js';\n\nconst all = Array.from(buttons.querySelectorAll('button'));\n\nconst handler = (ev) => {\n  const text = ev.detail.trim();\n  const hasValue = Boolean(text);\n  all.forEach((button) => button.disabled = !hasValue);\n};\ntyper.addEventListener('value', handler);\nhandler({detail: typer.value});\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = () => {\n    const text = input.dataset['copy'].trim().replace(/\\s+/, ' ');\n    if (!copier.copyText(text)) {\n      console.warn('could not copy', text)\n      return true;\n    }\n    console.info('copied', text);\n\n    // analytics\n    ga('send', 'event', 'text', 'copy');\n\n    // show 'Copied!' message\n    button.textContent = button.dataset['copied'];\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout((ev) => {\n      button.textContent = defaultText;\n      maybeReleaseInputEnter();\n    }, 500);\n  };\n\n  let wasInputEnter = false;\n  input.addEventListener('keydown', (ev) => {\n    if (wasInputEnter) {\n      // do nothing, enter is being _held_\n    } else if (ev.key === 'Enter' && !ev.repeat) {\n      button.click();\n      button.focus();\n      wasInputEnter = true;\n      ev.preventDefault();\n    }\n  });\n  document.body.addEventListener('keyup', (ev) => {\n    if (ev.key === 'Enter') {\n      maybeReleaseInputEnter();\n    }\n  });\n  button.addEventListener('click', (ev) => {\n    ev.preventDefault();\n    if (wasInputEnter || ev.repeat) {\n      return;  // click is generated as the user holds enter\n    }\n    copy();\n    if (eventlib.isKeyboardClick(ev)) {\n      // if the user tabbed here, keep focus\n      button.focus();\n    }\n  });\n\n  function maybeReleaseInputEnter() {\n    if (wasInputEnter) {\n      if (document.activeElement === button) {\n        input.focus();  // maybe focus moved\n      }\n      wasInputEnter = false;\n    }\n  }\n\n}(copy, typer));\n\n","\nconst letterSpacing = 1024;  // must be sensibly large enough so we round over emoji\nconst fontSize = 12;\n\nconst hider = document.createElement('div');\nhider.style.overflow = 'hidden';\nhider.style.width = '0px';\nhider.style.position = 'absolute';\n\nconst m = document.createElement('div');\nhider.appendChild(m);\nm.style.display = 'inline-block';\nm.style.whiteSpace = 'nowrap';\nm.style.fontSize = `${fontSize}px`;\nm.style.background = 'red';\n\nif (navigator.platform.startsWith('Win')) {\n  m.style.fontFamily = `'Segoe UI Emoji', 'Segoe UI Symbol', 'Courier New', monospace`;\n} else {\n  m.style.fontFamily = `'Lato', 'Helvetica Neue', 'Helvetica', sans-serif`;\n}\ndocument.body.appendChild(hider);\n\nm.textContent = '\\u{ffffd}';\nconst invalidBoxWidth = m.getBoundingClientRect().width;\n\n// _now_ set letterSpacing for rest\nm.style.letterSpacing = `${letterSpacing}px`;\n\nexport function measureDOMChars(s) {\n  m.textContent = s;\n  return Math.floor(m.offsetWidth / (letterSpacing + fontSize));\n}\n\nexport function isSingleEmoji(s) {\n  m.textContent = s;\n  const w = m.getBoundingClientRect().width;\n\n  const chars = Math.round(w / (letterSpacing + fontSize));\n  if (chars !== 1) {\n    return false;\n  }\n\n  if (w - letterSpacing === invalidBoxWidth) {\n    return false;\n  }\n  return true;\n}","\nexport function cacheFor(fn, limit=4000) {\n  let cache = {};\n  let count = 0;\n\n  return (arg) => {\n    let result = cache[arg];\n    if (result === undefined) {\n      cache[arg] = result = fn(arg);\n      if (++count > limit) {\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}","\nimport {isSingleEmoji} from './measurer.js';\nimport {cacheFor} from './cache.js';\n\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n\n  // Windows needs specified fonts (and Courier New, as monospace doesn't work?)\n  context.font = '1px \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Courier New\", monospace';\n\n  // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n  // probably greater than we'll ever use: still, empty if it's too big (limit=4000)\n  return cacheFor((s) => context.measureText(s).width);\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/.exec(navigator.platform));\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single emoji long\n */\nconst isSingle = (function() {\n  const debugMode = window.location.search.indexOf('debug') !== -1;\n\n  // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n  const emojiWidth = measureText('\\u{1f602}');\n  if (fixedWidthEmoji) {\n    if (debugMode) {\n      console.info('fixed emoji width is', emojiWidth, 'for \\u{1f602}');\n      return (s) => {\n        const ok = measureText(s) === emojiWidth;\n        if (!ok) {\n          console.debug('isSingle can\\'t render', s, 'width', measureText(s));\n        }\n        return ok;\n      };\n    }\n    // great! We can quickly check this!\n    return (s) => measureText(s) === emojiWidth;\n  }\n\n  // use the DOM rounding approach\n  return cacheFor(isSingleEmoji);\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emoji? On variable width\n * platforms, this can take O(n).\n *\n * This is only used by emoji returned by the API, which we know are valid emoji#, and have no\n * gender or diversity markers. It's also cached in `valid.js`.\n *\n * FIXME(samthor): # except for shruggie etc, but the mainpath is broken right now anyway\n * TODO(samthor): Mark shruggie etc with a magic char on the API side\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  // FIXME: This treats ZWJ'ed characters that aren't a single char as invalid. Maybe it's not\n  // worth worrying, but instead just checking that all the points are valid emoji.\n\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return (s) => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  return (s) => {\n    // TODO(samthor): We could do a 1st pass to check expected number of chars, and a 2nd pass\n    // to determine whether the parts are valid.\n\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n    const clen = chars.length;\n    for (let i = 0; i < clen; ++i) {\n      const char = chars[i];\n      if (isFlagPoint(char[0].point)) {\n        // Since we have to check individual chars, it's hard to know whether flags are supported.\n        // Assume any flag point is fine.\n        continue;\n      }\n      // measure this particular point and ensure it's single.\n      const buf = [];\n      char.forEach(({point, suffix, attach}, i) => {\n        if (i && !attach) {\n          buf.push(0x200d);\n        }\n        buf.push(point);\n        suffix && buf.push(suffix);\n      });\n      const s = String.fromCodePoint(...buf);\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nexport function jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0x1f9d2,  // girl, boy, child\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return (point) => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * FIXME(samthor): \"attach\" is a temporary hack to allow keycaps.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number, attach: boolean}>>}\n */\nexport function splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0, attach: false}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x20e3) {\n      // keycap, push onto last\n      curr.push({point: check, suffix: 0, attach: true});\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0, attach: false});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0, attach: false}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{tone: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), tone: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const stats = {tone: false, gender: {single: false, double: false, neutral: false}};\n  if (!s) {\n    return stats;\n  }\n  const points = jsdecode(s);\n\n  // split out gender modifiers and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach((ch) => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.tone = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.tone || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.tone && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.tone = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}', candidate)) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach((ch) => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        const c = String.fromCodePoint(first);\n        if (genderPoint && isSingle(c + '\\u{200d}\\u{2640}\\u{fe0f}', c)) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.tone !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.tone;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.tone;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach((ch) => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","\n// TODO(samthor): Just use this on supported browsers.\n// const re = new RegExp(/(?:[\\p{Letter}\\p{Number}])/u);\n\nfunction letterAt(text, pos) {\n  const code = text.charCodeAt(pos);\n  const after = text.charCodeAt(pos + 1);\n\n  if (after === 0xfe0f) {\n    return false;  // VS16 follows\n  }\n\n  // return Boolean(re.exec(text.substr(pos, 1)));\n  return code < 5000 && code > 32;\n}\n\nexport function match(text, at) {\n  let from = at;\n  let to = at;\n\n  // are we at the end (only have spaces until end)?\n  const isAtEnd = text.substr(at).trim() === '';\n  const isNotWordAfter = isAtEnd || !letterAt(text, at);\n\n  if (isNotWordAfter) {\n    for (; to > 0; --to) {\n      if (text.charCodeAt(to - 1) > 32) {\n        break;\n      }\n    }\n    if (to < from) {\n      from = to;\n    }\n  }\n\n  // walk backwards while the previous character is a word\n  for (; from > 0; --from) {\n    if (!letterAt(text, from - 1)) {\n      break;\n    }\n  }\n\n  // walk forwards while the next char is not a space\n  for (; to < text.length; ++to) {\n    if (!letterAt(text, to)) {\n      break;\n    }\n  }\n\n  if (from > to) {\n    from = to;\n  }\n  return {from, to};\n}","\nimport * as modifier from './lib/modifier.js';\nimport * as word from './lib/word.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach((key) => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\nconst upgraded = new WeakMap();\n\nexport function cursorPosition(el) {\n  const fn = upgraded.get(el);\n  if (fn !== undefined) {\n    return fn();\n  }\n  return undefined;\n}\n\n// word focus handler\nfunction upgrade(el) {\n  if (upgraded.has(el)) {\n    return false;\n  }\n\n  // stores the faux-selection shown (different from actual selection in 'state')\n  const sel = {\n    from: el.selectionStart,\n    to: el.selectionEnd,\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  let suggest = null;\n  const autocomplete = document.createElement('div');\n  autocomplete.className = 'autocomplete sizer';\n  helper.appendChild(autocomplete);\n\n  // measures the width of text\n  const measureText = (function() {\n    const sizer = document.createElement('div');\n    sizer.className = 'sizer';\n    helper.appendChild(sizer);\n\n    const nonce = document.createElement('div');\n    nonce.className = 'nonce';\n\n    return (text) => {\n      sizer.textContent = text;\n      sizer.appendChild(nonce);\n      return nonce.offsetLeft;\n    }\n  }());\n\n  // record upgraded measurer for callers to find our pixel position\n  upgraded.set(el, () => {\n    const mid = ~~((el.selectionStart + el.selectionEnd) / 2)\n    return measureText(el.value.substr(0, mid)) - el.scrollLeft;\n  });\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', (ev) => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = () => {\n    if (sel.from >= sel.to) {\n      underline.hidden = true;\n      return false;\n    }\n    const {from, to} = sel;\n\n    // otherwise, record and draw the line\n    const left = measureText(el.value.substr(0, from));\n    const width = measureText(el.value.substr(from, to - from));\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = `translateX(${-el.scrollLeft}px)`;\n\n    // TODO(samthor): put in div with underline so alignment is free?\n    autocomplete.style.transform = `translateX(${-el.scrollLeft + left + width}px)`;\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    sel.from = from;\n    sel.to = Math.max(from, to);\n    if (from >= to) {\n      datasetSafeDelete(el, 'prefix', 'word', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // rerender autocomplete word if valid\n  const renderAutocomplete = () => {\n    const s = el.dataset['prefix'] || '';\n    const valid = suggest !== null &&\n        s.length !== 0 &&\n        suggest.name.substr(0, s.length) === s &&\n        el.value.substr(sel.to).trim().length === 0;\n    if (!valid) {\n      autocomplete.textContent = '';\n      return false;\n    }\n    const display = suggest.name.substr(s.length) + suggest.emoji;\n    autocomplete.textContent = display;\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = (permitNextChange) => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // we're pretending to be the user's selection\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix', 'word');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // if it's invalid and we were permitted (this is used for faux-highlights), ignore\n    const {from, to} = word.match(el.value, state.start);\n    if (from >= to && permitNextChange) {\n      return false;  // we just got an emoji, retain implicit selection until next change\n    }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from).toLowerCase();\n      datasetSafeDelete(el, 'word');\n    }\n    return false;\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  let previousDetail = {};\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('select-all')) {\n      // custom event generated by page.js\n      el.setSelectionRange(0, el.value.length);\n    } else if (events.has('select-end')) {\n      // custom event generated by options.js\n      el.setSelectionRange(el.value.length, el.value.length);\n    } else if (events.has('focus')) {\n      // TODO: this sets on initial load, even though it probably doesn't need to\n      el.setSelectionRange(state.start, state.end);\n    }\n\n    // run change handler: if true, nothing changed\n    // (nb. the logic before return is because autocompletes don't count for alreadyAtState)\n    const alreadyAtState = changeHandler(permitNextChange);\n\n    // clear suggestion if we tried to render it and it wasn't valid\n    if (!renderAutocomplete()) {\n      suggest = null;\n    }\n\n    // set dataset['copy'] to the value you'd copy if you hit enter right now\n    // TODO(samthor): Generate this only when we run a copy?\n    if (el.selectionStart !== el.selectionEnd) {\n      el.dataset['copy'] = el.value.substr(el.selectionStart, el.selectionEnd - el.selectionStart);\n    } else if (suggest !== null) {\n      el.dataset['copy'] = el.value.substr(0, sel.from) + el.value.substr(sel.to) + suggest.emoji;\n    } else {\n      el.dataset['copy'] = el.value;\n    }\n\n    // if nothing changed, don't trigger any option callbacks\n    if (alreadyAtState) { return; }\n\n    // send query: prefix or whole-word (unless nothing is focused)\n    const text = el.dataset['focus'] ? el.dataset['prefix'] || el.dataset['word'] || null : '';\n    const detail = {\n      text,\n      prefix: 'prefix' in el.dataset,\n      focus: el.dataset['focus'],\n      selection: (el.selectionStart !== el.selectionEnd),\n    };\n\n    // send event only if something has changed\n    if (detail.text !== previousDetail.text ||\n        detail.prefix !== previousDetail.prefix ||\n        detail.focus !== previousDetail.focus ||\n        detail.selection !== previousDetail.selection) {\n      previousDetail = detail;\n      el.dispatchEvent(new CustomEvent('query', {detail}));\n    }\n  };\n\n  // whether user typed space and nothing came out\n  let hasPendingSpace = false;\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = (ev) => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input select-all select-end';\n    rest.split(/\\s+/).forEach((event) => el.addEventListener(event, dedup));\n    dedup();\n\n    // handle 'suggest' event: show default autocomplete option\n    el.addEventListener('suggest', (ev) => {\n      suggest = ev.detail;\n      if (hasPendingSpace) {\n        maybeReplace();\n      }\n      dedup();\n    });\n\n    // if a user is dragging around, this might be changing the offsetLeft (dragging input l/r)\n    el.addEventListener('mousemove', (ev) => {\n      if (ev.which) {\n        dedup();\n      }\n    });\n\n    // add 'selectionchange' (only valid on document) to listen to the initial long-press selection\n    // on Chrome (possibly others?) mobile: it doesn't generate 'select'.\n    document.addEventListener('selectionchange', (ev) => {\n      if (document.activeElement === el) {\n        dedup();\n      }\n    });\n  }());\n\n  function maybeReplace(expectSpace = false) {\n    if (el.selectionEnd < sel.to) {\n      // this was before the end of the selection, don't autocomplete\n      return false;\n    }\n\n    const text = el.dataset['prefix'] || '';\n    if (text.length === 0 || !suggest || !suggest.name.startsWith(text)) {\n      // no valid sugestion or no text anyway\n      return false;\n    }\n\n    const rest = el.value.substr(sel.to);\n    const mustBeSpace = rest.substr(0, el.selectionStart - sel.to);\n    const trimmed = mustBeSpace.trim();\n    if (trimmed.length !== 0) {\n      // this wasn't blank or space chars\n      return false;\n    } else if (expectSpace && !mustBeSpace.length) {\n      // there wasn't a space and we expected one\n      return false;\n    }\n\n    if (rest.trim().length !== 0 && suggest.name !== text) {\n      // we're not the end of the string, so only autocomplete if it's entirely typed\n      return false;\n    }\n\n    // dispatch change request on ourselves\n    ga('send', 'event', 'options', 'typing');\n    const detail = {\n      choice: suggest.emoji,\n      word: suggest.name,\n    };\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    return true;\n  }\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', (ev) => {\n    hasPendingSpace = false;\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case 'ArrowDown':\n    case 'Down':\n    case 'ArrowUp':\n    case 'Up':\n      ev.preventDefault();  // disable normal up/down behavior to change focus\n      return;\n\n    case ' ':\n      const success = maybeReplace();\n      if (ev.shiftKey) {\n        ev.preventDefault();  // don't type space if shift held\n      }\n      if (!success) {\n        // hold this for when autocompletes arrive\n        hasPendingSpace = true;\n      }\n      break;\n    }\n  });\n\n  // add a non-deduped keyup handler, for space on mobile browsers ('dreaded keycode 229')\n  el.addEventListener('keyup', (ev) => {\n    // was it a 229 or no code, and was the typed character a space?\n    if (ev.keyCode === 229 || !ev.keyCode) {\n      // TODO: possibly record hasPendingSpace for future arriving suggestions\n      maybeReplace(true);\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = () => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = (call) => {\n    const previousScrollLeft = el.scrollLeft;\n    const {from, to} = sel;\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n    const dir = typer.selectionDirection;\n\n    const update = call(value);\n    if (update == null) { return false; }\n\n    const prev = document.activeElement;\n\n    // select the region and 'type' it with insertText to provide undo/redo history\n    // nb. selecting the typer means that undo will always make us selected; probably fine\n    typer.focus();\n    typer.selectionStart = from;\n    typer.selectionEnd = to;\n    const expected = typer.value.substr(0, from) + update + typer.value.substr(to);\n    if (!document.execCommand('insertText', false, update) || typer.value !== expected) {\n      // set manually: this is fallback / Firefox mode\n      typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n    }\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n\n    const drift = (where) => {\n      if (where >= to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    // pretend we were like this all along\n    [state.start, state.end] = [drift(start), drift(end)];\n    typer.setSelectionRange(state.start, state.end, dir);\n\n    // TODO(samthor): Safari refuses to make this focus after the first above.\n    prev && prev.focus();\n\n    permitNextChange = true;\n    el.scrollLeft = previousScrollLeft;  // before setRange, so the underline is correct\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus emoji, if any\n  el.addEventListener('modifier', (ev) => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus((value) => modifier.modify(value, arg).out);\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', (ev) => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(() => emoji)) { return; }\n\n    // listen to the caller's view on what word we should pretend this emoji is\n    el.dataset['word'] = ev.detail.word || '';\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed, prefix) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    if (!prefix) {\n      all = all.filter(word => word === typed);\n    }\n    all = all.map(word => [word, ...values[word]]);\n\n    return all.length ? all : [];\n  }\n}\n","\nconst resolved = Promise.resolve();\n\n/**\n * Returns a Promise that resolves on `requestIdleCallback`.\n *\n * @return {!Promise<!IdleDeadline>}\n */\nexport function idle() {\n  return new Promise((resolve) => window.requestIdleCallback(resolve));\n}\n\n/**\n * Returns a Promise that resolves on `requestAnimationFrame`.\n *\n * @param {number=} delay whether to also delay by `setTimeout`\n * @return {!Promise<!IdleDeadline>}\n */\nexport function rAF(delay=undefined) {\n  if (delay !== undefined) {\n    return new Promise((resolve) => {\n      window.setTimeout(() => window.requestAnimationFrame(resolve), delay);\n    });\n  }\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n\n/**\n * Returns a Promise that resolves after a microtask.\n *\n * @return {!Promise<void>}\n */\nexport function microtask() {\n  return Promise.resolve();\n}\n\n/**\n * @return {{promise: !Promise<void>, resolver: function(): void}}\n */\nexport function resolver() {\n  let resolver;\n  const promise = new Promise((resolve) => resolver = resolve);\n  return {resolver, promise};\n}\n\n/**\n * @return {!Promise<void>}\n */\nexport function delay(ms=0) {\n  return new Promise((resolve) => window.setTimeout(resolve, ms));\n}\n\nconst debouceMap = new Map();\n\n/**\n * Returns a Promise that debounces a call to the passed callable.\n *\n * @template T\n * @param {function(): T} callable\n * @param {number=} delay\n * @return {!Promise<T>}\n */\nexport function debounce(callable, delay=0) {\n  let state = debouceMap.get(callable);\n  if (!state) {\n    state = {c: callable};\n    const p = new Promise((resolve) => state.r = resolve);\n    state.p = p.then(() => {\n      debouceMap.delete(callable);\n      return state.c();\n    });\n    debouceMap.set(callable, state);\n  }\n\n  window.clearTimeout(state.t);\n  state.t = window.setTimeout(state.r, Math.max(0, delay));\n\n  return state.p;\n}","\n/**\n * Remove duplicate entries from the passed array, only from the 1th index.\n *\n * @param {!Array<string>}\n * @return {!Array<string>}\n */\nfunction removeDuplicates(row) {\n  const found = new Set();\n  return row.filter((item, i) => {\n    if (i !== 0) {\n      if (found.has(item)) { return false; }\n      found.add(item);\n    }\n    return true;\n  });\n}\n\n/**\n * Merge the given results arrays. These will both be in the form of:\n *   [[name, emoji1, emoji2,....], ...]\n *\n * The first argument will be updated with the data from the second argument.\n *\n * @param {!Array<!Array<string>>} existing\n * @param {!Array<!Array<string>>} update\n */\nexport function merge(existing, update) {\n  const lookup = {};\n  existing.forEach((row, i) => lookup[row[0]] = i);\n\n  update.forEach((row) => {\n    const index = lookup[row[0]];\n    if (index === undefined) {\n      lookup[row[0]] = existing.length;  // in case there's dup data\n      existing.push(row);\n      return;\n    }\n\n    // otherwise, just append all new data and place back into array\n    const existingRow = existing[index];\n    const updatedData = row.slice(1);\n    existing[index] = removeDuplicates(existingRow.concat(updatedData));\n  });\n}","const api = 'https://emojibuff.appspot.com/api';\nconst recentLimit = 8;\nconst selectionDelay = 5 * 1000;\n\nimport build from './prefixgen.js';\nimport * as promises from './promises.js';\nimport * as results from './results.js';\n\n/**\n * @param {string} key for endpoint/cache\n * @param {number} expiry in hours\n * @param {(function(boolean): void)=} callback to call with true then false (for loading work)\n * @return {function(): !Promise<!Array<!Array<string>>}\n */\nfunction loaderFor(key, expiry=24, callback=() => {}) {\n  let promiseResults;\n\n  // TODO: refetch after >expiry, don't just invalidate\n\n  const raw = window.localStorage[key];\n  if (raw) {\n    let out;\n    try {\n      out = JSON.parse(raw);\n    } catch (e) {\n      console.debug('couldn\\'t parse localStorage', key, e);\n      out = null;\n    }\n    if (out && out['results']) {\n      promiseResults = Promise.resolve(out['results']);\n      if (out['created'] >= +new Date - (60 * 60 * 1000 * expiry)) {\n        // return immediately, it's less than one day old\n        return () => promiseResults;\n      }\n    }\n  }\n\n  // we don't have data or it's >1day old, refetch\n  // TODO(samthor): Break into retryable fetch.\n  const f = new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${api}/${key}`);\n    xhr.onerror = reject;\n    xhr.responseType = 'json';\n    xhr.onload = () => resolve(xhr.response);\n    xhr.send();\n  }).then((raw) => {\n    // IE11 doesn't respect responseType, and we always return an Object\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }).then((update) => {\n    promiseResults = f;  // can return real results now\n\n    // store in localStorage for next time\n    update['created'] = +new Date();\n    window.localStorage[key] = JSON.stringify(update);\n\n    // return updated results\n    return update['results'];\n  });\n\n  // no local data, wait for data\n  if (!promiseResults) {\n    callback(true);                 // indicate working\n    f.then(() => callback(false));  // done\n    return () => f;\n  }\n\n  return () => promiseResults;\n}\n\n/**\n * Returns the local prefix search tool.\n *\n * @return {!Promise<function(string, boolean): !Array<!Array<string>>>}\n */\nconst getPrefixGen = (function() {\n  const loader = loaderFor('popular', 24, (working) => {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = !working;\n  });\n  return () => {\n    return loader().then((results) => build(results))\n  };\n}());\n\n/**\n * Returns the trending emoji.\n *\n * @return {!Promise<!Array<string>>}\n */\nconst getTrendingEmoji = (function() {\n  const loader = loaderFor('hot', 1);\n  return () => {\n    return loader().then((results) => {\n      let out = [];\n      results.forEach((data) => {\n        out = out.concat(data.slice(1));  // drop name\n      });\n      return out;\n    });\n  };\n}());\n\n/**\n * Requests emoji completion.\n *\n * @param {string} text user has typed\n * @param {boolean} prefix is this a prefix search, or is it a definite whole word?\n * @param {boolean=} more whether to return lots more results for this query\n * @return {!Promise<!Array<!Array>>}\n */\nexport function request(text, prefix, more=false) {\n  if (!text) {\n    if (more && text === '') {\n      const r = recent();\n      r.unshift('^recent');\n\n      return getTrendingEmoji().then((p) => {\n        p.unshift('^trending');\n        return [r, p];\n      });\n    }\n\n    return Promise.resolve([]);\n  }\n\n  const localPromise = getPrefixGen().then((suggest) => suggest(text, prefix));\n  if (!more) {\n    return localPromise;\n  }\n\n  // TODO: At some point, the 'more' data should go into a local cache. For now, just fetch.\n  let url = `${api}/q?q=${window.encodeURIComponent(text)}`;\n  if (!prefix) {\n    url += '&exact';\n  }\n  const morePromise = window.fetch(url).then((out) => out.json()).then((out) => out['results']);\n  return Promise.all([localPromise, morePromise]).then((both) => {\n    const [local, more] = both;\n    results.merge(local, more);\n    return local;\n  });\n}\n\n/**\n * Records use of name/emoji pairs.\n *\n * @param {string} name used to select emoji\n * @param {string} emoji selected\n * @param {!Promise<!Response>} eventual response after delay\n */\nexport const select = (function() {\n  let pending = {};\n\n  const runner = () => {\n    const body = JSON.stringify(pending);\n    pending = {};  // clear pending for next time\n    return navigator.sendBeacon(api + '/sel', body);\n  };\n\n  return function select(name, emoji) {\n    if (name[0] === '^') {\n      return;  // do nothing\n    }\n\n    const r = recent();\n    const index = r.indexOf(emoji);\n    if (index !== -1) {\n      r.splice(index, 1);\n    }\n    r.unshift(emoji);\n    r.splice(recentLimit);\n    window.localStorage['recent'] = r.join(',');\n    // TODO: do something with recent emoji use\n\n    pending[name] = emoji;\n    return promises.debounce(runner, selectionDelay);\n  }\n}());\n\n/**\n * Submit the name of an emoji.\n *\n * @param {string} name\n * @param {string} emoji\n * @return {!Promise<Response>}\n */\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n\n/**\n * Gets recently used emoji.\n *\n * @return {!Array<string>}\n */\nexport function recent() {\n  return (window.localStorage['recent'] || '').split(',').filter((x) => x);\n}","\n/**\n * @fileoverview Async worker.\n */\n\nimport * as promises from './promises.js';\n\nconst allowedWorkTime = 4;\nconst maximumTaskFrame = 100;\n\nexport default class Worker {\n  constructor(fn) {\n    this.fn_ = fn;\n    this.queue_ = [];\n    this.waiting_ = null;\n\n    this.runner_().catch((err) => {\n      console.info('worker runner failed', err);\n      throw err;\n    });\n  }\n\n  async runner_() {\n    await new Promise((resolve) => this.waiting_ = resolve);\n    this.waiting_ = null;\n    await promises.idle();\n\n    for (;;) {\n      if (this.chunk_()) {\n        return this.runner_();\n      }\n      await promises.rAF();\n    }\n  }\n\n  /**\n   * Completes a chunk of work.\n   *\n   * @return {boolean} Whether work is done.\n   */\n  chunk_() {\n    const start = window.performance.now();\n\n    let done = 0;\n    while (this.queue_.length) {\n      const next = this.queue_.shift();\n      next.resolve(this.fn_(next.arg));\n      ++done;\n\n      if (done == maximumTaskFrame || window.performance.now() - start > allowedWorkTime) {\n        break;\n      }\n    }\n\n    return !this.queue_.length;\n  }\n\n  task(arg) {\n    return new Promise((resolve) => {\n      this.queue_.push({resolve, arg});\n      this.waiting_ && this.waiting_();\n    });\n  }\n}\n","\n/**\n * @fileoverview The validator runs constantly and validates emoji rendering.\n */\n\nimport {isExpectedLength} from './modifier.js';\nimport Worker from './worker.js';\n\nconst prefix = '-ok_';\nconst ls = window.localStorage;\nconst known = new Map();\n\nfunction runner(emoji) {\n  const out = isExpectedLength(emoji);\n  known.set(emoji, out);\n  if (out) {\n    ls[prefix + emoji] = 't';  // use dummy small string\n  }\n  return out;\n}\n\nconst worker = new Worker(runner);\n\nfunction immediate(emoji) {\n  const immediate = known.get(emoji);\n  if (immediate !== undefined) {\n    return immediate;\n  }\n  return ls[prefix + emoji];\n}\n\n/**\n * As per isExpectedLength, but caches successful results.\n *\n * @param {string} string to check\n * @return {!Promise<boolean>} whether this is probably an emoji\n */\nexport async function valid(emoji) {\n  const result = immediate(emoji);\n  if (result !== undefined) {\n    return result;\n  }\n  return worker.task(emoji);\n}\n\n/**\n * Async helper that finds the first valid autocomplete option. Uses a callback in order to hint\n * whether the result is coming in the current frame (before any await) or after (calls callback\n * with null first).\n *\n * @param {!Array<!Array<string>>} options\n * @param {function(?{name: string, emoji: string})} callback\n */\nexport async function findValidMatch(options, callback) {\n  let calledWithDelay = false;\n\n  for (let i = 0; i < options.length; ++i) {\n    const row = options[i];\n    for (let j = 1; j < row.length; ++j) {\n      const emoji = row[j];\n      let result = immediate(emoji);\n      if (result === undefined) {\n        // we have to wait for the runner, so call with a delay\n        if (!calledWithDelay) {\n          callback(null);\n          calledWithDelay = true;\n        }\n        result = await worker.task(emoji);\n      }\n\n      if (result) {\n        return callback({name: row[0], emoji});\n      }\n    }\n  }\n\n  if (!calledWithDelay) {\n    callback(null);\n  }\n}\n","\n/**\n * @fileoverview Emojityper's suggestion handler. Handles creation, showing etc of autocomplete\n * buttons in the UI.\n */\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\nimport {valid, findValidMatch} from './lib/valid.js';\nimport * as promises from './lib/promises.js';\nimport * as eventlib from './lib/event.js';\nimport * as input from './input.js';\nimport * as copier from './lib/copier.js';\n\n/**\n * ButtonManager helps create and show emoji buttons in the UI.\n */\nclass ButtonManager {\n  constructor(holder) {\n    this.holder_ = holder;\n\n    /** @type {!Map<string, !HTMLElement>} */\n    this.options_ = new Map();\n\n    /** @type {!Map<string, !HTMLButtonElement>} */\n    this.buttons_ = new Map();\n\n    /** @type {!WeakMap<!HTMLButtonElement, !DocumentFragment>} */\n    this.buttonTarget_ = new WeakMap();\n\n    /** @type {!Array<!HTMLButtonElement} */\n    this.buttonPool_ = [];\n\n    window.requestIdleCallback(() => {\n      for (let i = 0; i < 10; ++i) {\n        this.buttonPool_.push(document.createElement('button'));\n      }\n    });\n\n    const modifierHolder = document.createElement('div');\n    this.holder_.appendChild(modifierHolder);\n\n    /** @type {function(this:ButtonManager, !Object): void} */\n    this.setModifier = (() => {\n      const genderOption = ButtonManager.optionType_('modifier', 'gender');\n      const toneOption = ButtonManager.optionType_('modifier', 'tone');\n      modifierHolder.appendChild(genderOption);\n      modifierHolder.appendChild(toneOption);\n\n      // helper to create buttons\n      const createModifierButton = (text, value=null) => {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.dataset['value'] = value;\n        return button;\n      };\n\n      // create gender options\n      const genders = [\n        createModifierButton('\\u{26AC}', ''),\n        createModifierButton('\\u{2640}', 'f'),\n        createModifierButton('\\u{2640}\\u{2642}', 'fm'),\n        createModifierButton('\\u{2642}', 'm'),\n        createModifierButton('\\u{2642}\\u{2640}', 'mf'),\n      ];\n\n      // create tone options\n      const tones = [\n        createModifierButton('\\u{2014}', ''),\n      ];\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        tones.push(createModifierButton(String.fromCodePoint(i), i));\n      }\n\n      // helper to add/remove\n      const updateStatus = (yes, node, owner) => {\n        yes ? owner.appendChild(node) : node.remove();\n      };\n      return function(info) {\n        const active =\n            modifierHolder.contains(document.activeElement) ? document.activeElement : null;\n        genders.forEach((node) => {\n          const l = node.dataset['value'].length;\n          const yes = (!l && info.gender.neutral)\n              || (l === 1 && info.gender.single)\n              || (l === 2 && info.gender.double);\n          updateStatus(yes, node, genderOption);\n        });\n        tones.forEach((node) => updateStatus(info.tone, node, toneOption));\n\n        // kick the elements: Safari needs this otherwise sometimes they remain hidden (!)\n        modifierHolder.insertBefore(genderOption, genderOption.nextSibling);\n        modifierHolder.insertBefore(toneOption, toneOption.nextSibling);\n\n        // refocus if one was focused\n        active && active.focus();\n      }\n    })();\n  }\n\n  static optionType_(type, value) {\n    const node = document.createElement('div');\n    node.className = 'options ' + type;\n    node.dataset[type] = value;\n    node.dataset['name'] = value;\n    return node;\n  }\n\n  optionForName_(name) {\n    const prev = this.options_.get(name);\n    if (prev) {\n      return prev;\n    }\n    const node = document.createElement('div');\n    node.className = 'options';\n    node.setAttribute('data-option', name);\n\n    if (name[0] === '^') {\n      node.classList.add('special');\n      name = name.substr(1);\n    }\n    node.setAttribute('data-name', name);  // presentation only\n    return node;\n  }\n\n  /**\n   * Creates a `button` with the textContent of the passed emoji. Starts removed from the page,\n   * but will (when valid) be placed in-order inside the specified `option`.\n   *\n   * @param {!HTMLElement} option to place inside\n   * @param {string} emoji\n   * @return {!HTMLButtonElement}\n   */\n  addEmojiTo_(option, emoji) {\n    let button = this.buttons_.get(emoji);\n    if (button) {\n      // if the button was known, check buttonTarget_: either it's the eventual placement, which\n      // we must replace, or it's a known good/bad already\n      const target = this.buttonTarget_.get(button);\n      if (target === null) {\n        return button;  // known invalid\n      } else if (target === undefined) {\n        option.appendChild(button);  // known good\n        return button;\n      }\n    } else {\n      if (this.buttonPool_.length !== 0) {\n        button = this.buttonPool_.pop();\n      } else {\n        button = document.createElement('button');\n      }\n      button.textContent = emoji;\n      this.buttons_.set(emoji, button);\n\n      valid(emoji).then((isValid) => {\n        if (!isValid) {\n          return this.buttonTarget_.set(button, null);\n        }\n\n        const node = this.buttonTarget_.get(button);\n        node.parentNode.replaceChild(button, node);\n        this.buttonTarget_.delete(button);\n      });\n    }\n\n    const node = document.createTextNode('');  // empty placeholder to replace\n    this.buttonTarget_.set(button, node);\n    option.appendChild(node);\n\n    return button;\n  }\n\n  /**\n   * Updated displayed options with real results. These are expected the API format:\n   *    [[name,emoji,emoji,...],[name,emoji,...],...]\n   *\n   * This retains existing options if they are included in the named results.\n   *\n   * @param {!Array<!Array<string>>}\n   */\n  update(results) {\n    const options = new Map();\n    const buttons = new Map();\n    const previousActiveElement =\n        this.holder_.contains(document.activeElement) ? document.activeElement : null;\n\n    results.forEach((result) => {\n      const name = result[0];\n\n      const option = this.optionForName_(name);\n      options.set(name, option);\n      this.options_.delete(name);\n      this.holder_.appendChild(option);  // reinsert in better order\n\n      // TODO(samthor): This is a bit hacky. This saves buttons that are part of these options,\n      // even if they haven't been sent to us again in results.\n      for (let i = 0; i < option.children.length; ++i) {\n        const b = option.children[i];\n        const emoji = b.textContent;\n        if (buttons.has(emoji)) {\n          b.remove();\n          this.buttonPool_.push(b);\n          --i;\n          continue;\n        }\n        buttons.set(emoji, b);\n      }\n\n      for (let i = 1, emoji; emoji = result[i]; ++i) {\n        if (buttons.has(emoji)) {\n          continue;  // already stolen by something above us\n        }\n        // nb. addEmojiTo_ pulls old buttons from this.buttons_\n        buttons.set(emoji, this.addEmojiTo_(option, emoji));\n      }\n    });\n\n    this.options_.forEach((option) => {\n      // TODO(samthor): Edge doesn't like ...HTMLCollection\n      for (let i = 0; i < option.children.length; ++i) {\n        this.buttonPool_.push(option.children[i]);\n      }\n      option.remove();\n    });\n    this.options_ = options;\n    this.buttons_ = buttons;\n\n    if (previousActiveElement) {\n      if (document.body.contains(previousActiveElement)) {\n        previousActiveElement.focus();\n      } else {\n        typer.focus();  // restore to main input\n      }\n    }\n  }\n}\n\n// key overrides to recognize spacebar causing 'click'\nlet spaceFrame = 0;\nchooser.addEventListener('keyup', (ev) => {\n  if (ev.key !== ' ' || ev.target.localName !== 'button') { return; }\n  spaceFrame = window.setTimeout(() => spaceFrame = 0, 0);\n});\n\n// stores the previous user-driven l/r position\nlet previousChooserLeft = undefined;\nlet duringNavigate = false;\n\n// if a button was focused, reset chooser unless we were going u/d\nchooser.addEventListener('focus', (ev) => {\n  if (!duringNavigate) {\n    previousChooserLeft = document.activeElement.getBoundingClientRect().left;\n  }\n}, true);\n\n/**\n * Navigates through candidates until we find the best not on our current row, and focuses it.\n *\n * @param {!IArrayLike<!Node>} cands\n * @return {boolean} true if we focused something new\n */\nfunction navigateChooserButtonVertical(cands) {\n  const best = {dist: Infinity, button: null};\n\n  const previousRect = document.activeElement.getBoundingClientRect();\n  // did we have a previous explicit l/r position?\n  const left = (previousChooserLeft !== undefined ? previousChooserLeft : previousRect.left);\n\n  let targetTop = undefined;\n  for (let i = 0; i < cands.length; ++i) {\n    const button = cands[i];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    } else if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (!best.button) {\n    return false;\n  }\n  duringNavigate = true;\n  try {\n    best.button.focus();\n  } finally {\n    duringNavigate = false;\n  }\n  return true;\n}\n\n// button click handler\nchooser.addEventListener('click', (ev) => {\n  previousChooserLeft = undefined;  // used a mouse or chose something\n  const isKeyboard = eventlib.isKeyboardClick(ev);\n\n  let label = undefined;\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    if (ev.shiftKey) {\n      return;  // don't do anything\n    }\n\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n    label = 'modifier';\n  } else if (b.parentNode.dataset['option']) {\n    if (ev.shiftKey) {\n      if (copier.copyText(b.textContent)) {\n        ga('send', 'event', 'options', 'copy');\n      }\n\n      // retain scroll position while refocusing on the suitable target\n      const scrollTop = document.scrollingElement.scrollTop;\n      isKeyboard ? b.focus() : typer.focus();\n      document.scrollingElement.scrollTop = scrollTop;\n      return;\n    }\n\n    // nb. we typically clear the word on choice (as it confuses @nickyringland), but if you hit\n    // space or ctrl-click the button, keep it around.\n    const retainWord = (spaceFrame !== 0 || ev.metaKey || ev.ctrlKey);\n    const word = retainWord ? b.parentNode.dataset['option'] : null;\n\n    const detail = {choice: b.textContent, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(b.parentNode.dataset['option'], detail.choice);\n    label = 'emoji';\n  } else {\n    // unknown\n  }\n  if (!label) { return; }\n\n  ga('send', 'event', 'options', 'click', label);\n\n  if (!isKeyboard) {\n    typer.focus();  // nb. we're actually double-refocusing\n  }\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', (ev) => {\n  if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    const typerRect = typer.getBoundingClientRect();\n    previousChooserLeft = typerRect.left + input.cursorPosition(typer);\n\n    if (navigateChooserButtonVertical(chooser.querySelectorAll('button'))) {\n      ga('send', 'event', 'options', 'keyboardnav');\n    }\n  } else if (ev.key === 'ArrowRight' || ev.key === 'Right') {\n    const l = typer.value.length;\n    if (typer.selectionEnd === l && typer.selectionStart === l) {\n      const first = chooser.querySelector('button');\n      first && first.focus();\n    }\n  }\n});\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', (ev) => {\n  const arrow = eventlib.arrowFromEvent(ev);\n  if (!arrow) { return; }\n\n  if (!chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (arrow === 'ArrowLeft') {\n    delta = -1;\n  } else if (arrow === 'ArrowRight') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    } else if (target < 0) {\n      typer.focus();\n      typer.dispatchEvent(new CustomEvent('select-end'));\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  let cands;\n  if (arrow === 'ArrowUp') {\n    cands = buttonArray.slice(0, index);\n    cands.reverse();\n  } else if (arrow === 'ArrowDown') {\n    cands = buttonArray.slice(index);\n  } else {\n    return;\n  }\n\n  if (!navigateChooserButtonVertical(cands)) {\n    if (arrow === 'ArrowUp') {\n      typer.focus();\n    }\n  }\n  if (arrow === 'ArrowDown') {\n    // don't allow arrow scrolling unless we're within 64 pixels of the screen end\n    const focusRect = document.activeElement.getBoundingClientRect();\n    const max = focusRect.top + focusRect.height;\n    if (window.innerHeight - max > 64) {\n      ev.preventDefault();\n    }\n  }\n});\n\n(function() {\n  const longTime = 2000;\n  const delayTime = 250;\n  const manager = new ButtonManager(chooser);\n\n  let previous = {};\n  let previousQueryAt = performance.now();\n  let previousResults = [];\n\n  let suggestInvoke = 0;\n  function findSuggest(q) {\n    const localSuggestInvoke = ++suggestInvoke;\n    if (!q) {\n      typer.dispatchEvent(new CustomEvent('suggest', {detail: null}));\n      return;\n    }\n\n    let exactMatch = null;\n    const localResults = previousResults.slice().filter((row) => {\n      if (q.length > 1 && row[0] === q) {\n        exactMatch = row;\n        return false;\n      }\n      return row[0].startsWith(q);\n    });\n    exactMatch && localResults.unshift(exactMatch);\n\n    const callback = (result) => {\n      if (localSuggestInvoke === suggestInvoke) {\n        typer.dispatchEvent(new CustomEvent('suggest', {detail: result}));\n      }\n    };\n    findValidMatch(localResults, callback);\n  }\n\n  // handler for a prefix search\n  typer.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const now = performance.now();\n\n    // immediately inform manager of modifier buttons (gender, tone), if it's a full word search\n    const info = modifier.modify(!ev.detail.prefix && ev.detail.focus || '');\n    manager.setModifier(info);\n\n    if (previous.text !== query.text) {\n      // text changed, immediately run suggest code\n      findSuggest(query.text);\n    }\n\n    // TODO(samthor): This delays further requests. Ideally we want to 'subscribe' to a topic\n    // from the provider and just be fed updates as fast as we have them (including if we have\n    // a local cache). This way we avoid awkward delays and filtering oddities.\n    const initialMore = previous.text && query.text && previous.text.length !== 0 &&\n        previous.text.startsWith(query.text.substr(0, previous.text.length)) || false;\n\n    let immediate = false;\n    if (!previous.text || previous.prefix !== query.prefix) {\n      immediate = true;  // type changed, user expects snappiness\n    } else if (now - previousQueryAt > longTime) {\n      immediate = true;  // it's been a while\n    }\n    previous = query;\n    previousQueryAt = now;\n\n    const request = async (timeout=0, more=false) => {\n      if (timeout) {\n        await promises.rAF(timeout);\n        if (previous !== query) { return -1; }\n      }\n      const results = await provider.request(query.text, query.prefix, more);\n      if (previous !== query) { return -1; }\n\n      // find the first matching thing and suggest it as autocomplete\n      previousResults = results;\n      findSuggest(query.text);\n\n      return manager.update(results);\n    };\n\n    const p = request(immediate ? 0 : delayTime, initialMore).then((valid) => {\n      if (valid < 0) { return -2; }  // query changed\n\n      if (!query.text) {\n        // TODO: delay empty data by a decent time\n        return request(1500, true);\n      }\n\n      const timeout = Math.max(1000, 100 * Math.pow(valid, 0.75));\n      return request(timeout, true);\n    }).catch((err) => {\n      console.error('error doing request', err);\n    });\n  });\n}());\n","\nimport * as provider from './lib/provider.js';\nimport * as promises from './lib/promises.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let value = '';\n  let pending = null;\n\n  input.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined && query.selection);\n    value = query.focus;\n    if (!selection) {\n      if (!pending) {\n        namer.value = '';  // clear on done if not pending\n        advanced.hidden = true;\n      }\n      return false;\n    }\n    // TODO: round trip to confirm validity of emoji?\n    advanced.hidden = false;\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', (ev) => {\n    ev.preventDefault();\n    if (pending) {\n      return false;  // can't submit while running\n    }\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n\n      pending = null;\n      if (!value) {\n        advanced.hidden = true;\n      }\n    };\n\n    pending = provider.submit(namer.value, value).then((response) => {\n      if (!response.ok) {\n        throw new Error(response.status);\n      }\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err);\n      return true;\n    }).then(cleanup);\n\n    pending.then(() => promises.delay(2000)).then(() => {\n      button.className = '';\n    });\n  });\n}(typer, advanced));\n","\n/**\n * @fileoverview Controls the size and `has-value` class of the body itself based on current input.\n */\n\nimport * as promises from './lib/promises.js';\n\nconst value = (ev) => {\n  const text = ev.detail.trim();\n  document.body.classList.toggle('has-value', Boolean(text));\n};\ntyper.addEventListener('value', value);\nvalue({detail: typer.value});\n\n// global return-to-typer\ndocument.body.addEventListener('keydown', (ev) => {\n  switch (ev.key) {\n  case 'Escape':\n    // #1: focus on typer\n    if (document.activeElement !== typer) {\n      typer.focus();\n      break;\n    }\n\n    // #2: clear selection\n    if (typer.selectionStart !== typer.selectionEnd) {\n      if (typer.selectionDirection === 'backward') {\n        typer.selectionStart = typer.selectionEnd;\n      } else {\n        typer.selectionEnd = typer.selectionStart;\n      }\n      break;\n    }\n\n    // #3: move to end of input\n    const l = typer.value.length;\n    typer.setSelectionRange(l, l);\n    break;\n  }\n});\n\nfunction isExtentNode(node) {\n  return node instanceof Element && node.classList.contains('extent');\n}\n\ndocument.addEventListener('selectionchange', (ev) => {\n  const s = window.getSelection();\n  const {anchorNode: a, focusNode: b} = s;\n  if (a !== b && isExtentNode(a) && isExtentNode(b)) {\n    s.removeAllRanges();  // remove immediately to prevent flash\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('select-all'));\n  }\n}, true);\n\ndocument.addEventListener('focusin', (ev) => {\n  promises.microtask().then(() => {\n    if (document.activeElement === document.body) {\n      typer.focus();\n    }\n  });\n});\n\n// set minHeight to actual viewport height, but allow for keyboard etc\nconst resize = (ev) => {\n  const height = window.innerHeight;\n  document.body.style.minHeight = `${height}px`;\n};\nwindow.addEventListener('resize', resize);\nwindow.addEventListener('load', resize);\nresize();\n\n\nlet deferredPrompt = null;\n\nfunction cleanupPrompt() {\n  document.body.classList.remove('has-install');\n  deferredPrompt = null;\n}\n\nwindow.addEventListener('beforeinstallprompt', (ev) => {\n  ga('send', 'event', 'install', 'available');\n  document.body.classList.add('has-install');\n  deferredPrompt = ev;\n  ev.preventDefault();\n  return false;\n});\n\nwindow.addEventListener('appinstalled', (ev) => {\n  ga('send', 'event', 'install', 'installed');\n  cleanupPrompt();\n});\n\nconst installEl = document.getElementById('install');\ninstallEl.addEventListener('click', (ev) => {\n  if (!deferredPrompt) {\n    return;\n  }\n  deferredPrompt.prompt();\n\n  if (!deferredPrompt.userChoice) {\n    return;  // older Chrome\n  }\n\n  deferredPrompt.userChoice.then((result) => {\n    ga('send', 'event', 'install', result);\n    // TODO: should we listen to appinstalled? I suppose we don't know what the user said.\n  }).catch((err) => {\n    console.warn('beforeinstallprompt prompt', err);\n  }).then(cleanupPrompt);\n});\n","\n/**\n * @fileoverview Rotates through various advertisements in Emojityper.\n */\n\nconst adverts = document.getElementById('adverts');\n\nfunction refresh() {\n  const active = adverts.querySelector('.active');\n  const next = (active && active.nextElementSibling || adverts.firstElementChild);\n  if (!next) {\n    console.warn('no adverts to choose from');\n    return;\n  }\n\n  active && active.classList.remove('active');\n  next.classList.add('active');\n\n  enqueue();\n}\n\nlet timeout;\nfunction enqueue() {\n  window.clearTimeout(timeout);\n  timeout = window.setTimeout(() => {\n    window.requestAnimationFrame(refresh);\n  }, 10 * 1000);\n}\n\nenqueue();\n","\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('./sw.js').catch((err) => {\n    console.warn('failed to register SW', err);\n  });\n\n  const hadInitialController = Boolean(navigator.serviceWorker.controller);\n  navigator.serviceWorker.addEventListener('controllerchange', () => {\n    if (hadInitialController) {\n      // only reload if we had a SW on load\n      console.debug('got SW controllerchange, reload');\n      window.location.reload();\n    } else {\n      // this is the very first SW, so reloading doesn't help us\n    }\n  });\n}\n","\nimport {debounce} from './lib/promises.js';\n\nlet prevOnLine = true;\n\nfunction notifyStatus() {\n  if ('onLine' in navigator && prevOnLine !== navigator.onLine) {\n    ga('send', 'event', 'network', navigator.onLine ? 'online' : 'offline');\n    prevOnLine = navigator.onLine;\n  }\n}\n\nnotifyStatus();\nwindow.addEventListener('online', () => debounce(notifyStatus));\nwindow.addEventListener('offline', () => debounce(notifyStatus));\n","\nimport './polyfill.js';\nimport './buttons.js';\nimport './input.js';\nimport './options.js';\nimport './selection.js';\nimport './page.js';\nimport './adverts.js';\nimport './sw.js';\nimport './offline.js';\n\n// global error handler for logs\nwindow.onerror = (msg, file, line, col, error) => {\n  console.info('got err', String(msg));\n  try {\n    ga('send', 'event', 'error', `${file},${line}:${col}`, String(msg), {nonInteraction: true});\n  } catch (e) {}\n};\n"]}