{"version":3,"sources":["src/polyfill.js","src/lib/event.js","src/lib/copier.js","src/buttons.js","src/lib/cache.js","node_modules/ok-emoji/src/string.js","node_modules/ok-emoji/src/emoji.js","node_modules/ok-emoji/src/measurer.js","src/lib/modifier.js","src/lib/word.js","src/input.js","src/lib/prefixgen.js","src/lib/promises.js","src/lib/results.js","src/lib/provider.js","src/lib/worker.js","src/lib/valid.js","src/options.js","src/selection.js","src/page.js","src/adverts.js","src/sw.js","src/offline.js","src/placeholders.js","src/bundle.js"],"names":["window","requestIdleCallback","callback","start","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","setTimeout","cancelIdleCallback","id","clearTimeout","navigator","sendBeacon","url","body","Promise","resolve","reject","xhr","XMLHttpRequest","open","onerror","onload","send","arrowKeys","arrowFromEvent","ev","key","startsWith","indexOf","isKeyboardClick","MouseEvent","screenX","detail","webkitForce","dummy","copyText","text","document","createElement","style","position","opacity","appendChild","value","hidden","focus","selectionStart","selectionEnd","length","execCommand","e","all","Array","from","input","querySelectorAll","handler","trim","hasValue","Boolean","forEach","button","disabled","typer","addEventListener","buttonTextShow","notifyParentCopy","parent","postMessage","cacheFor","limit","cache","count","arg","result","undefined","jsdecode","s","len","points","i","raw","charCodeAt","extra","push","timeout","defaultText","textContent","wasInputEnter","maybeReleaseInputEnter","activeElement","repeat","click","preventDefault","dataset","replace","copier.copyText","console","warn","info","ga","classList","add","remove","copy","eventlib.isKeyboardClick","runeZWJ","runeCap","runeVS16","runeTagCancel","isSkinTone","p","isFlagPoint","isTag","skippable","emojiPointCount","_emojiPointCount","halfCount","l","iterateEmoji","_iterateEmoji","curr","flag","v","pending","ensure","off","cand","shift","tail","fixedWidthEmoji","exec","platform","userAgent","needsManWomanHack","letterSpacing","fontSize","hider","overflow","width","setAttribute","measurer","measure","getBoundingClientRect","offsetWidth","height","offsetHeight","display","whiteSpace","lineHeight","fontFamily","invalidBoxSize","validEmojiSize","fixedWidthMeasure","context","getContext","font","expectedWidth","measureText","countRenderPoints","round","countExtraAllowed","index","isSingleValidEmoji","rect","expected","isExpectedLength","actual","part","String","fromCodePoint","isSingle","basicDiversity","skipDiversityList","skipDiversity","isPointGender","isPersonGender","isFamilyMember","genderFlip","list","Map","data","f","m","n","j","has","Error","set","point","out","get","single","neutral","reverseParts","last","lastIndexOf","emoji.runeZWJ","to","slice","trailer","splitPoints","modify","op","stats","tone","gender","double","outer","emoji.iterateEmoji","genderable","familyLike","first","emoji.isFlagPoint","localFamilyMember","localPersonGender","flip","emoji.runeVS16","valid","emoji.isSkinTone","splice","update","filter","map","parts","pop","localOp","foundAny","next","split","run","merged","join","letterAt","pos","code","match","at","substr","datasetSafeDelete","el","keys","d","upgraded","WeakMap","cursorPosition","upgrade","sel","helper","className","parentNode","insertBefore","underline","suggest","autocomplete","sizer","nonce","offsetLeft","mid","scrollLeft","readyState","renderLine","left","getElementById","transform","setRange","initialLength","state","end","previousDetail","heldScrollLeft","mergedEventHandler","events","permitNextChange","setSelectionRange","alreadyAtState","dispatchEvent","CustomEvent","word.match","toLowerCase","changeHandler","name","emoji","renderAutocomplete","prefix","selection","hasPendingSpace","maybeReplace","expectSpace","rest","mustBeSpace","choice","word","frame","Set","dedup","clear","requestAnimationFrame","type","event","which","success","shiftKey","keyCode","dedupRenderLine","passive","replaceFocus","call","previousScrollLeft","dir","selectionDirection","prev","drift","where","[object Object]","modifier.modify","build","prefixLength","maxSuggestions","prefixSuggest","values","k","opts","typed","idle","rAF","delay","microtask","ms","debouceMap","debounce","callable","c","r","then","delete","t","removeDuplicates","row","found","item","merge","existing","lookup","existingRow","updatedData","concat","api","recentLimit","selectionDelay","loaderFor","expiry","promiseResults","localStorage","JSON","parse","debug","Date","responseType","response","stringify","getPrefixGen","loader","working","results","getTrendingEmoji","request","more","recent","unshift","localPromise","encodeURIComponent","morePromise","fetch","json","both","local","results.merge","select","runner","promises.debounce","submit","FormData","append","method","mode","x","allowedWorkTime","maximumTaskFrame","Worker","this","fn_","queue_","waiting_","runner_","catch","err","promises.idle","chunk_","promises.rAF","done","dummyString","ls","known","ignoreValid","location","search","worker","task","immediate","async","findValidMatch","options","calledWithDelay","ButtonManager","holder","holder_","options_","buttons_","buttonTarget_","buttonPool_","modifierHolder","setModifier","genderOption","optionType_","toneOption","createModifierButton","genders","tones","updateStatus","yes","node","owner","active","contains","nextSibling","option","target","isValid","replaceChild","createTextNode","buttons","previousActiveElement","optionForName_","children","b","addEmojiTo_","spaceFrame","chooser","localName","previousChooserLeft","duringNavigate","navigateChooserButtonVertical","cands","best","dist","Infinity","previousRect","targetTop","candidateRect","top","abs","isKeyboard","label","scrollTop","scrollingElement","metaKey","ctrlKey","provider.select","typerRect","input.cursorPosition","querySelector","arrow","eventlib.arrowFromEvent","buttonArray","delta","reverse","focusRect","innerHeight","manager","previous","previousQueryAt","previousResults","suggestInvoke","findSuggest","q","localSuggestInvoke","exactMatch","localResults","query","initialMore","provider.request","pow","error","advanced","form","namer","provider.submit","ok","status","_","promises.delay","toggle","isExtentNode","Element","getSelection","anchorNode","a","focusNode","removeAllRanges","promises.microtask","resize","minHeight","closest","href","sources","removeAttribute","Windows","deferredPrompt","cleanupPrompt","prompt","userChoice","adverts","refresh","nextElementSibling","firstElementChild","enqueue","serviceWorker","register","hadInitialController","controller","reload","prevOnLine","notifyStatus","onLine","placeholders","floor","random","placeholder","msg","file","line","col","nonInteraction"],"mappings":"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","file":"bundle-6671f66b0d.js","sourcesContent":["\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nif (!window.requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = (callback) => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\nif (!navigator.sendBeacon) {\n  navigator.sendBeacon = function(url, body) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', url, true);\n      xhr.onerror = reject;\n      xhr.onload = resolve;\n      xhr.send(body);\n    });\n  };\n}\n","\nconst arrowKeys = ['Left', 'Right', 'Up', 'Down'];\n\n/**\n * @param {!Event} ev\n * @return {?string} one of \"Arrow{Left,Right,Up,Down}\" if this is a keyboard event of that arrow\n */\nexport function arrowFromEvent(ev) {\n  if (!ev.key) {\n    return null;\n  }\n  if (ev.key.startsWith('Arrow')) {\n    return ev.key;\n  }\n  if (arrowKeys.indexOf(ev.key) === -1) {\n    return null;\n  }\n  return 'Arrow' + ev.key;\n}\n\n/**\n * @param {!Event} ev\n * @return {boolean} whether this is probably a keyboard/non-mouse click\n */\nexport function isKeyboardClick(ev) {\n  if (!(ev instanceof MouseEvent)) {\n    return true;\n  }\n  return (ev.screenX === 0 && ev.detail === 0) || ev.webkitForce === 0;\n}","\nlet dummy;\n\nexport function copyText(text) {\n  if (!dummy) {\n    dummy = document.createElement('input');\n    dummy.style.position = 'fixed';\n    dummy.style.opacity = 0;\n    document.body.appendChild(dummy);\n  }\n\n  dummy.value = text;\n  try {\n    dummy.hidden = false;\n    dummy.focus();\n    dummy.selectionStart = 0;\n    dummy.selectionEnd = dummy.value.length;\n    document.execCommand('copy');\n  } catch (e) {\n    return false;\n  } finally {\n    dummy.hidden = true;\n  }\n\n  return true;\n}","\n/**\n * @fileoverview Handles the buttons in the top-right of the page (currently just Copy).\n */\n\nimport * as eventlib from './lib/event.js';\nimport * as copier from './lib/copier.js';\n\nconst all = Array.from(input.querySelectorAll('button'));\n\nconst handler = (ev) => {\n  const text = ev.detail.trim();\n  const hasValue = Boolean(text);\n  all.forEach((button) => button.disabled = !hasValue);\n};\ntyper.addEventListener('value', handler);\nhandler({detail: typer.value});\n\nconst buttonTextShow = 500;\n\nfunction notifyParentCopy() {\n  // notify parent (for ext)\n  if (window.parent) {\n    window.parent.postMessage('copy', '*');\n  }\n}\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = () => {\n    const text = input.dataset['copy'].trim().replace(/\\s+/, ' ');\n    if (!copier.copyText(text)) {\n      console.warn('could not copy', text)\n      return true;\n    }\n    console.info('copied', text);\n\n    // analytics\n    ga('send', 'event', 'text', 'copy');\n\n    // show 'Copied!' message\n    button.textContent = button.dataset['copied'];\n    button.classList.add('copied');\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout((ev) => {\n      button.textContent = defaultText;\n      button.classList.remove('copied');\n      maybeReleaseInputEnter();\n      notifyParentCopy();\n    }, buttonTextShow);\n  };\n\n  let wasInputEnter = false;\n  input.addEventListener('keydown', (ev) => {\n    if (wasInputEnter) {\n      // do nothing, enter is being _held_\n    } else if (ev.key === 'Enter' && !ev.repeat) {\n      button.click();\n      button.focus();\n      wasInputEnter = true;\n      ev.preventDefault();\n    }\n  });\n  document.body.addEventListener('keyup', (ev) => {\n    if (ev.key === 'Enter') {\n      maybeReleaseInputEnter();\n    }\n  });\n  button.addEventListener('click', (ev) => {\n    ev.preventDefault();\n    if (wasInputEnter || ev.repeat) {\n      return;  // click is generated as the user holds enter\n    }\n    copy();\n    if (eventlib.isKeyboardClick(ev)) {\n      // if the user tabbed here, keep focus\n      button.focus();\n    }\n  });\n\n  function maybeReleaseInputEnter() {\n    if (wasInputEnter) {\n      if (document.activeElement === button) {\n        input.focus();  // maybe focus moved\n      }\n      wasInputEnter = false;\n    }\n  }\n\n}(copy, typer));\n\n","\nexport function cacheFor(fn, limit=4000) {\n  let cache = {};\n  let count = 0;\n\n  return (arg) => {\n    let result = cache[arg];\n    if (result === undefined) {\n      cache[arg] = result = fn(arg);\n      if (++count > limit) {\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}","\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nexport function jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n","\nimport {jsdecode} from './string.js';\n\nexport const runeZWJ = 0x200d;\nexport const runeCap = 0x20e3;\nexport const runeVS16 = 0xfe0f;\nexport const runeTagCancel = 0xe007f;\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nexport function isSkinTone(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nexport function isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a tag character, for tag sequences\n */\nexport function isTag(p) {\n\treturn p >= 0xe0020 && p < 0xe007f\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune can appear before a keycap\n */\nexport function isBeforeCap(p) {\n  return p === 35 || p === 42 || (p >= 48 && p <= 57)  // #, * or 0-9\n}\n\n/**\n * @type {!Array<number>}\n */\nconst skippable = [runeVS16, runeCap, runeTagCancel];\n\n/**\n * Returns a count of the expected number of points displayed for the given valid emoji string.\n *\n * Assumes the emoji is normalized/well-formed: if not, the result will likely just be lower than\n * rendered, and it'll be considered invalid anyway.\n *\n * @param {string} s\n * @return {number} count\n */\nexport function emojiPointCount(s) {\n  const points = jsdecode(s);\n  return _emojiPointCount(points);\n}\n\n/**\n * @param {!Array<number>} points\n * @return {number} count\n */\nexport function _emojiPointCount(points) {\n  let halfCount = 0;\n  const l = points.length;\n  for (let i = 0; i < l; ++i) {\n    const p = points[i];\n    if (p === runeZWJ) {\n      halfCount -= 2;\n    } else if (skippable.indexOf(p) !== -1 || isTag(p) || isSkinTone(p)) {\n      // do nothing\n    } else if (isFlagPoint(p)) {\n      ++halfCount;\n    } else {\n      halfCount += 2;\n    }\n  }\n\n  if (points.length === 0) {\n    return 0;  // no points\n  } else if (halfCount <= 2) {\n    return 1;  // return minimum if string had content\n  } else {\n    return (halfCount + 1) >> 1;  // round up\n  }\n}\n\n/**\n * @param {string} s\n * @yield {?Array<number>}\n */\nexport function *iterateEmoji(s) {\n  const points = jsdecode(s);\n  yield *_iterateEmoji(points);\n}\n\n/**\n * @param {!Array<number>} points\n * @yield {?Array<number>}\n */\nexport function *_iterateEmoji(points) {\n  let curr = {flag: false, v: []};\n  const pending = [curr];\n\n  const ensure = (flag) => {\n    if (curr.flag !== flag) {\n      curr = {flag, v: []};\n      pending.push(curr);\n    }\n  };\n\n  const l = points.length;\n  for (let i = 0; i < l; ++i) {\n    const p = points[i];\n\n    if (isFlagPoint(p)) {\n      ensure(true);  // force flag mode\n      curr.v.push(p);\n    } else if (skippable.indexOf(p) !== -1 || isTag(p) || isSkinTone(p) || p === runeZWJ) {\n      ensure(false);  // force regular mode\n      curr.v.push(p);\n    } else {\n      // ensure new char unless we follow a ZWJ\n      const off = curr.v.length - 1;\n      if (off !== -1 && curr.v[off] !== runeZWJ) {\n        curr = {flag: false, v: [p]};\n        pending.push(curr);\n      } else {\n        curr.v.push(p);\n      }\n    }\n\n    while (pending.length > 1) {\n      const cand = pending.shift();\n      if (cand.v.length) {\n        yield cand.v;\n      }\n    }\n  }\n\n  const tail = pending[0];\n  if (tail.v.length) {\n    yield tail.v;\n  }\n}","\nimport {emojiPointCount, _emojiPointCount, _iterateEmoji, isFlagPoint} from './emoji.js';\nimport {jsdecode} from './string.js';\n\n// are we on a platform where emoji are all fixed width? This enables our fast-path.\nconst fixedWidthEmoji =\n    Boolean(/Mac|iP(hone|od|ad)/.exec(navigator.platform)) ||  // Mac and iOS\n    Boolean(/Android/.exec(navigator.userAgent))           ||  // Android\n    false;\n\n// on Windows, the initial Man or Woman of an emoji sequence gets a space after it\n// ...well, Edge struggles with couples/family, Chrome is _just_ couples\nconst needsManWomanHack = Boolean(/Win/.exec(navigator.platform));\n\nconst letterSpacing = 1024;  // must be sensibly large enough so we round over emoji\nconst fontSize = 100;        // large enough to unambiguate other wide chars\n\nconst hider = document.createElement('div');\nhider.style.overflow = 'hidden';\nhider.style.width = '0px';\nhider.style.position = 'absolute';\nhider.setAttribute('href', 'https://github.com/samthor/is-emoji');\n\nconst measurer = document.createElement('div');\nmeasurer.style.display = 'inline-block';\nmeasurer.style.whiteSpace = 'nowrap';\nmeasurer.style.fontSize = `${fontSize}px`;\nmeasurer.style.lineHeight = 'normal';\nmeasurer.style.fontFamily = 'sans-serif';\n\nhider.appendChild(measurer);\ndocument.body.appendChild(hider);\n\n/**\n * @return {{width: number, height: number}}\n */\nfunction measure() {\n  // use the height of the hider, as it grows to expand 'large' chars (the measurer itself doesn't)\n  // grow, it just renders 'outside'\n  const box = hider.getBoundingClientRect();\n  return {width: measurer.offsetWidth, height: hider.offsetHeight};\n}\n\n// render a char that will show up as an invalid Unicode square box\nmeasurer.textContent = '\\u{ffffd}';\nconst invalidBoxSize = measure();\n\n// render an emoji\nmeasurer.textContent = '\\u{1f602}';\nconst validEmojiSize = measure();\n\n// check invalid vs emoji\nexport const isSingleAmbig = (validEmojiSize.height === invalidBoxSize.height) && !fixedWidthEmoji;\nif (isSingleAmbig) {\n  // This is somewhat unlikely, but possible. In this case, we can't tell single characters from\n  // emoji, because everything has the same height.\n  // console.warn(`unable to tell single char from emoji char`);\n}\n// _now_ set letterSpacing for rest\nmeasurer.style.letterSpacing = `${letterSpacing}px`;\n\n/**\n * @type {(null|function(string): number)}\n */\nconst fixedWidthMeasure = (function() {\n  if (!fixedWidthEmoji) {\n    return null;\n  }\n\n  // nb. The choice of canvasFontSize leverages weird Mac quirks. Using e.g. 1 or 100 doesn't\n  // work; 10.5 seems to work well, because other fixed-width single-chars are different size.\n  // Ostensibly, emoji don't like to render on pixel widths, and on macOS 10.13 it rounds up to 14.\n  const canvasFontSize = 10.5;\n\n  const canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));\n  const context = /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n  context.font = `${canvasFontSize}px monospace`;\n  const expectedWidth = context.measureText('\\u{1f602}').width;  // fixed width of emoji\n\n  return function fixedWidthMeasure(s) {\n    const width = context.measureText(s).width;\n    return width / expectedWidth;\n  }\n}());\n\n/**\n * @param {string} s to measure\n * @return {number} the number (approx) of characters rendered\n */\nexport function countRenderPoints(s) {\n  measurer.textContent = s;\n  return Math.round(measurer.offsetWidth / (letterSpacing + fontSize));\n}\n\n/**\n * @param {string} s to examine\n * @return {number} the number of extra rendered chars to allow\n */\nconst countExtraAllowed = (function() {\n  if (!needsManWomanHack) {\n    return () => 0;\n  }\n\n  return (s) => {\n    let extra = 0;\n    let index = -1;\n    for (;;) {\n      index = s.indexOf('\\u{200d}\\u{d83d}', index+1);  // ZWJ plus first byte of person (man/woman)\n      if (index === -1) {\n        break;\n      }\n      const cand = s.charCodeAt(index+2);\n      if (cand === 56424 || cand === 56425) {\n        ++extra;\n      }\n    }\n    return extra;\n  }\n}());\n\n/**\n * @param {string} s\n * @return {boolean} whether this is a single valid emoji (width is single, and not an invalid box)\n */\nexport const isSingleValidEmoji = (function() {\n  if (fixedWidthEmoji) {\n    return function isSingleValidEmoji(s) {\n      return fixedWidthMeasure(s) === 1;\n    };\n  }\n\n  return function isSingleValidEmoji(s) {\n    measurer.textContent = s;\n    const rect = measure();\n\n    const expected = 1 + countExtraAllowed(s);\n    const len = Math.round(rect.width / (letterSpacing + fontSize));\n    if (len > expected) {\n      return false;  // expected single char\n    } else if (validEmojiSize.height !== rect.height) {\n      // nb. This isn't perfect, it's very plausible that there are some random Unicode points\n      // that on the user's system which have the same height as the emoji itself.\n      return false;  // not emoji height\n    }\n    return invalidBoxSize.width !== rect.width - letterSpacing;\n  }\n}());\n\n/**\n * @param {string} s\n * @return {boolean} whether this is the expected length of an emoji-only string\n */\nexport const isExpectedLength = (function() {\n  if (fixedWidthEmoji) {\n    return function isExpectedLength(s) {\n      const actual = fixedWidthMeasure(s);\n      const expected = emojiPointCount(s);\n      if (~~actual !== actual) {\n        return false;  // must be whole emoji chars\n      }\n      return actual <= expected;\n    };\n  }\n\n  // isExpectedLength implementation for variable width environments (anywhere but Apple or\n  // Android). Windows, Linux and others render emoji with variable width. But all platforms render\n  // emoji with fixed height.\n  // TODO: If we're wrong then remove the height checks.\n  return function isExpectedLength(s) {\n    measurer.textContent = s;\n    if (hider.offsetHeight !== validEmojiSize.height) {\n      return false;  // early out, text doesn't have emoji height\n    }\n\n    const points = jsdecode(s);\n    const expected = _emojiPointCount(points) + countExtraAllowed(s);\n    const renderPoints = countRenderPoints(s);\n    if (renderPoints > expected) {\n      return false;  // early out, catches uncombinables\n    }\n\n    // iterate through emoji parts, check all of them for validity\n    for (const part of _iterateEmoji(points)) {\n      if (part === null) {\n        return false;  // got invalid part\n      }\n\n      // special-case flags, which we get in bulk\n      if (isFlagPoint(part[0])) {\n        if (part.length % 2) {\n          return false;  // flags must be pairs\n        }\n        for (let i = 0; i < part.length; i += 2) {\n          const text = String.fromCodePoint(part[i], part[i+1]);\n          if (!isSingleValidEmoji(text)) {\n            return false;\n          }\n        }\n        continue;\n      }\n\n      // check is single char\n      const text = String.fromCodePoint(...part);\n      if (!isSingleValidEmoji(text)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n","\nimport {cacheFor} from './cache.js';\nimport {jsdecode} from '../../node_modules/ok-emoji/src/string.js';\nimport {isSingleValidEmoji} from '../../node_modules/ok-emoji/src/measurer.js';\nimport * as emoji from '../../node_modules/ok-emoji/src/emoji.js';\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single emoji long\n */\nconst isSingle = cacheFor(isSingleValidEmoji);\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = isSingle('\\u{1f468}\\u{1f3fb}');\n\n/**\n * @type {!Array<number>}\n */\nconst skipDiversityList = [\n  0x1f91d,  // handshake\n  0x1f46a,  // nuclear family\n  0x1f93c,  // people wrestling\n  0x1f46b,  // m+w hands\n  0x1f46c,  // m+m hands\n  0x1f46d,  // w+w hands\n];\n\n/**\n * @param {number} p\n * @return {boolean} whether to skip diversity for this point\n */\nfunction skipDiversity(p) {\n  return skipDiversityList.indexOf(p) !== -1;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emoji which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  const list = [\n    0x1f468, 0x1f469, 0,        // man, woman (normal case)\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0x1f9d2,  // girl, boy, child\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0x1f46b,  // women/men holding hands; note this has 'mixed' for neutral\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return (point) => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single =\n          isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n ? isSingle(String.fromCodePoint(out.points.n)) : false;\n    }\n    return out;\n  };\n}());\n\n/**\n * @param {!Array<number>} points\n * @yields {{part: !Array<number>, trailer: boolean}}\n */\nfunction *reverseParts(points) {\n  let last = -1;\n\n  // nb. this actually works in reverse\n  do {\n    // ugh so many off by ones\n    const index = points.lastIndexOf(emoji.runeZWJ, last);\n    const from = index + 1;\n    const to = (last === -1 ? points.length : last + 1);\n    last = index - 1;\n\n    const part = points.slice(from, to);\n    if (part.length === 0) {\n      continue;  // ignore empty char\n    }\n\n    const x = {part: points.slice(from, to), trailer: from !== 0};\n    yield x;\n  } while (last !== -2);\n}\n\n/**\n * @param {!Array<number>} points\n * @return {!Array<!Array<number>>}\n */\nfunction splitPoints(points) {\n  let last = 0;\n  const out = [];\n\n  for (;;) {\n    const index = points.indexOf(emoji.runeZWJ, last);\n    const to = (index === -1 ? points.length : index);\n\n    const part = points.slice(last, to);\n    if (part.length !== 0) {\n      out.push(part);\n    }\n\n    if (index === -1) {\n      break;\n    }\n    last = index + 1;\n  }\n\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), due to the cost of measuring every individual character on some platforms.\n *\n * @param {string} s\n * @param {{tone: (undefined|number), gender: (undefined|string)}=} op\n * @return {\n *   out: (string|undefined),\n *   tone: boolean,\n *   gender: {single: boolean, double: boolean, neutral: boolean},\n * }\n */\nexport function modify(s, op=undefined) {\n  const stats = {tone: false, gender: {single: false, double: false, neutral: false}};\n\n  const all = op !== undefined ? [] : null;\nouter:\n  for (const points of emoji.iterateEmoji(s)) {\n    if (all) {\n      all.push(points);  // store for 2nd round\n    }\n\n    let genderable = 0;\n    let familyLike = false;\n\n    for (const {part, trailer} of reverseParts(points)) {\n      // check for early exhaustive answer\n      if (op === undefined &&\n        (stats.tone || !basicDiversity) &&\n        stats.gender.neutral && stats.gender.single && stats.gender.double) {\n        break outer;\n      }\n\n      const first = part[0];\n\n      if (emoji.isFlagPoint(first)) {\n        continue;\n      }\n\n      const localFamilyMember = isFamilyMember(first)\n      if (trailer && localFamilyMember) {\n        familyLike = true;   // familyLike is family member in later part of char\n      }\n\n      const localPersonGender = isPersonGender(first)\n      if (localFamilyMember || localPersonGender) {\n        stats.tone = !familyLike && basicDiversity;\n        stats.gender.single = true;\n        if (localPersonGender && ++genderable >= 2) {\n          stats.gender.double = true;\n        }\n        continue;  // nothing more to find out here\n      }\n\n      if (familyLike) {\n        continue;  // no more checks to do\n      }\n\n      // check for prescribed gender flips\n      const flip = genderFlip(first);\n      if (flip !== null) {\n        stats.gender.single |= flip.single;\n        stats.gender.neutral |= flip.neutral;\n      }\n\n      // measure if diversity is possible (only on first char)\n      if (basicDiversity && !stats.tone && !trailer && !skipDiversity(first)) {\n        const cand = String.fromCodePoint(first, 0x1f3fb);\n        stats.tone = isSingle(cand);\n      }\n\n      // measure if gender is possible\n      if (!stats.gender.neutral) {\n        const cand = String.fromCodePoint(first, emoji.runeZWJ, 0x2640, emoji.runeVS16);\n        const valid = isSingle(cand);\n        stats.gender.neutral = valid;\n        stats.gender.single = stats.gender.single || valid;\n      }\n    }\n  }\n\n  if (op === undefined) {\n    return stats;\n  }\n\n  if (op.tone !== undefined && stats.tone) {\n    // nb. tones are only ever valid in position 1\n    all.forEach((points) => {\n      if (emoji.isSkinTone(points[1])) {\n        // found one, either replace or clear\n        if (op.tone) {\n          // great, save in place\n          points[1] = op.tone;\n        } else {\n          const cand = String.fromCodePoint(points[0]);\n          if (!isSingle(cand)) {\n            points[1] = emoji.runeVS16;  // tone was holding this as emoji\n          } else {\n            points.splice(1, 1);  // just remove\n          }\n        }\n        return;  // in-place update\n      }\n\n      if (!op.tone) {\n        // just remove in case one's in a weird place\n        const update = points.filter((point) => !emoji.isSkinTone(point));\n        points.splice(0, points.length, ...update);\n        return;  // in-place update\n      }\n\n      if (skipDiversity(points[0])) {\n        return;  // skip\n      }\n\n      const cand = String.fromCodePoint(points[0], op.tone, ...points.slice(1));\n      if (!isSingle(cand)) {\n        return;\n      }\n      points.splice(1, 0, op.tone);\n    });\n  }\n\n  if (op.gender !== undefined) {\n    const splitAll = all.map((points) => splitPoints(points));\n    const updateSplitAll = splitAll.map((parts, i) => {\n      // check last point first\n      const hadTrailingGender = isPointGender(parts[parts.length - 1][0]);\n\n      // look for gendered emoji at start of all and flip\n      if (!hadTrailingGender) {\n        let localOp = [];\n        let foundAny = false;\n        for (let i = 0; i < parts.length; ++i) {\n          const part = parts[i];\n          const first = part[0];\n\n          const flip = genderFlip(first);\n          if (!flip) {\n            if (i === 0) {\n              break;  // genderable will always be first, give up\n            }\n            continue;\n          }\n\n          // if we're out of ops, split for more (this might still be blank, but reset anyway)\n          localOp = localOp.length ? localOp : op.gender.split('');\n          const next = localOp.shift();\n          if (foundAny && (!next || isFamilyMember(first))) {\n            break;  // if we've already matched some, and now have no more data / is family, fail\n          }\n\n          if (!next && flip.neutral) {\n            part[0] = flip.points.n;\n          } else if (next && flip.single) {\n            part[0] = (next === 'm' ? flip.points.m : flip.points.f);\n          }\n          foundAny = true;\n        }\n        if (foundAny) {\n          return parts;  // don't try to add a gender modifier\n        }\n\n        // now, either change trailing gender or try to add one\n        if (!op.gender) {\n          return null;  // nothing to do\n        }\n\n        // we need to see if it's possible, clone _whole_ emoji\n        const run = all[i].slice();\n        run.push(emoji.runeZWJ, 0x2640, emoji.runeVS16);\n        const cand = String.fromCodePoint(...run);\n        if (!isSingle(cand)) {\n          return null;\n        }\n        parts.push([0x2640, emoji.runeVS16]);  // we change this below\n      } else if (!op.gender) {\n        parts.pop();\n        return parts;\n      }\n\n      const last = parts[parts.length - 1];\n      last[0] = (op.gender[0] === 'm' ? 0x2642 : 0x2640);\n      return parts;\n    });\n\n    // remerge changed parts\n    updateSplitAll.forEach((parts, i) => {\n      if (parts === null) {\n        return;  // nothing changed here\n      }\n      const merged = [];\n      parts.forEach((part) => {\n        merged.push(...part, emoji.runeZWJ);\n      });\n      merged.pop();  // remove trailing ZWJ\n      all[i] = merged;\n    });\n  }\n\n  stats.out = all.map((points) => String.fromCodePoint(...points)).join('');\n  return stats;\n}\n","\nimport * as emoji from '../../node_modules/ok-emoji/src/emoji.js';\n\n// TODO(samthor): Just use this on supported browsers.\n// const re = new RegExp(/(?:[\\p{Letter}\\p{Number}])/u);\n\nfunction letterAt(text, pos) {\n  const code = text.charCodeAt(pos);\n  const after = text.charCodeAt(pos + 1);\n\n  if (after === emoji.runeVS16) {\n    return false;  // VS16 follows\n  }\n\n  // return Boolean(re.exec(text.substr(pos, 1)));\n  return code < 5000 && code > 32;\n}\n\nexport function match(text, at) {\n  let from = at;\n  let to = at;\n\n  // are we at the end (only have spaces until end)?\n  const isAtEnd = text.substr(at).trim() === '';\n  const isNotWordAfter = isAtEnd || !letterAt(text, at);\n\n  if (isNotWordAfter) {\n    for (; to > 0; --to) {\n      if (text.charCodeAt(to - 1) > 32) {\n        break;\n      }\n    }\n    if (to < from) {\n      from = to;\n    }\n  }\n\n  // walk backwards while the previous character is a word\n  for (; from > 0; --from) {\n    if (!letterAt(text, from - 1)) {\n      break;\n    }\n  }\n\n  // walk forwards while the next char is not a space\n  for (; to < text.length; ++to) {\n    if (!letterAt(text, to)) {\n      break;\n    }\n  }\n\n  if (from > to) {\n    from = to;\n  }\n  return {from, to};\n}","\nimport * as modifier from './lib/modifier.js';\nimport * as word from './lib/word.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach((key) => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\nconst upgraded = new WeakMap();\n\nexport function cursorPosition(el) {\n  const fn = upgraded.get(el);\n  if (fn !== undefined) {\n    return fn();\n  }\n  return undefined;\n}\n\n// word focus handler\nfunction upgrade(el) {\n  if (upgraded.has(el)) {\n    return false;\n  }\n\n  // stores the faux-selection shown (different from actual selection in 'state')\n  const sel = {\n    from: el.selectionStart,\n    to: el.selectionEnd,\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  let suggest = null;\n  const autocomplete = document.createElement('div');\n  autocomplete.className = 'autocomplete sizer';\n  helper.appendChild(autocomplete);\n\n  // measures the width of text\n  const measureText = (function() {\n    const sizer = document.createElement('div');\n    sizer.className = 'sizer';\n    helper.appendChild(sizer);\n\n    const nonce = document.createElement('div');\n    nonce.className = 'nonce';\n\n    return (text) => {\n      sizer.textContent = text;\n      sizer.appendChild(nonce);\n      return nonce.offsetLeft;\n    }\n  }());\n\n  // record upgraded measurer for callers to find our pixel position\n  upgraded.set(el, () => {\n    const mid = ~~((el.selectionStart + el.selectionEnd) / 2)\n    return measureText(el.value.substr(0, mid)) - el.scrollLeft;\n  });\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', (ev) => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = () => {\n    if (sel.from >= sel.to) {\n      underline.hidden = true;\n      return false;\n    }\n    const {from, to} = sel;\n\n    // otherwise, record and draw the line\n    const left = measureText(el.value.substr(0, from));\n    const width = measureText(el.value.substr(from, to - from));\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = `translateX(${-el.scrollLeft}px)`;\n\n    // TODO(samthor): put in div with underline so alignment is free?\n    autocomplete.style.transform = `translateX(${-el.scrollLeft + left + width}px)`;\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    sel.from = from;\n    sel.to = Math.max(from, to);\n    if (from >= to) {\n      datasetSafeDelete(el, 'prefix', 'word', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // rerender autocomplete word if valid\n  const renderAutocomplete = () => {\n    const s = el.dataset['prefix'] || '';\n    const valid = suggest !== null &&\n        s.length !== 0 &&\n        suggest.name.substr(0, s.length) === s &&\n        el.value.substr(sel.to).trim().length === 0;\n    if (!valid) {\n      autocomplete.textContent = '';\n      return false;\n    }\n    const display = suggest.name.substr(s.length) + suggest.emoji;\n    autocomplete.textContent = display;\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = (permitNextChange) => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // we're pretending to be the user's selection\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix', 'word');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // if it's invalid and we were permitted (this is used for faux-highlights), ignore\n    const {from, to} = word.match(el.value, state.start);\n    if (from >= to && permitNextChange) {\n      return false;  // we just got an emoji, retain implicit selection until next change\n    }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from).toLowerCase();\n      datasetSafeDelete(el, 'word');\n    }\n    return false;\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  let previousDetail = {};\n  let heldScrollLeft = 0;\n  const mergedEventHandler = (events, permitNextChange) => {\n    if (events.has('select-all')) {\n      // custom event generated by page.js\n      el.setSelectionRange(0, el.value.length);\n    } else if (events.has('select-end')) {\n      // custom event generated by options.js\n      el.setSelectionRange(el.value.length, el.value.length);\n    } else if (events.has('focus') && !(events.has('mousedown') || events.has('touchstart'))) {\n      // if there was a focus event, don't let the browser take over: reset previous known good\n      // ... unless the user used their mouse/cursor to select something\n      // TODO: this sets on initial load, even though it probably doesn't need to\n      el.setSelectionRange(state.start, state.end);\n    }\n\n    // some browsers set this to zero when we leave, restore it\n    if (events.has('blur') || events.has('focus')) {\n      // TODO(samthor): Safari flashes L/R on this. We probably don't care.\n      el.scrollLeft = heldScrollLeft;\n    }\n    heldScrollLeft = el.scrollLeft;\n\n    // run change handler: if true, nothing changed\n    // (nb. the logic before return is because autocompletes don't count for alreadyAtState)\n    const alreadyAtState = changeHandler(permitNextChange);\n\n    // clear suggestion if we tried to render it and it wasn't valid\n    if (!renderAutocomplete()) {\n      suggest = null;\n    }\n\n    // set dataset['copy'] to the value you'd copy if you hit enter right now\n    // TODO(samthor): Generate this only when we run a copy?\n    if (el.selectionStart !== el.selectionEnd) {\n      el.dataset['copy'] = el.value.substr(el.selectionStart, el.selectionEnd - el.selectionStart);\n    } else if (suggest !== null) {\n      el.dataset['copy'] = el.value.substr(0, sel.from) + el.value.substr(sel.to) + suggest.emoji;\n    } else {\n      el.dataset['copy'] = el.value;\n    }\n\n    // if nothing changed, don't trigger any option callbacks\n    if (alreadyAtState) { return; }\n\n    // send query: prefix or whole-word (unless nothing is focused)\n    const text = el.dataset['focus'] ? el.dataset['prefix'] || el.dataset['word'] || null : '';\n    const detail = {\n      text,\n      prefix: 'prefix' in el.dataset,\n      focus: el.dataset['focus'],\n      selection: (el.selectionStart !== el.selectionEnd),\n    };\n\n    // send event only if something has changed\n    if (detail.text !== previousDetail.text ||\n        detail.prefix !== previousDetail.prefix ||\n        detail.focus !== previousDetail.focus ||\n        detail.selection !== previousDetail.selection) {\n      previousDetail = detail;\n      el.dispatchEvent(new CustomEvent('query', {detail}));\n    }\n  };\n\n  // whether user typed space and nothing came out\n  let hasPendingSpace = false;\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = (ev) => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown touchstart select input select-all select-end blur';\n    rest.split(/\\s+/).forEach((event) => el.addEventListener(event, dedup));\n    dedup();\n\n    // handle 'suggest' event: show default autocomplete option\n    el.addEventListener('suggest', (ev) => {\n      suggest = ev.detail;\n      if (hasPendingSpace) {\n        maybeReplace();\n      }\n      dedup();\n    });\n\n    // if a user is dragging around, this might be changing the offsetLeft (dragging input l/r)\n    el.addEventListener('mousemove', (ev) => {\n      if (ev.which) {\n        dedup();\n      }\n    });\n\n    // add 'selectionchange' (only valid on document) to listen to the initial long-press selection\n    // on Chrome (possibly others?) mobile: it doesn't generate 'select'.\n    document.addEventListener('selectionchange', (ev) => {\n      if (document.activeElement === el) {\n        dedup();\n      }\n    });\n  }());\n\n  function maybeReplace(expectSpace = false) {\n    if (el.selectionEnd < sel.to) {\n      // this was before the end of the selection, don't autocomplete\n      return false;\n    }\n\n    const text = el.dataset['prefix'] || '';\n    if (text.length === 0 || !suggest || !suggest.name.startsWith(text)) {\n      // no valid sugestion or no text anyway\n      return false;\n    }\n\n    const rest = el.value.substr(sel.to);\n    const mustBeSpace = rest.substr(0, el.selectionStart - sel.to);\n    const trimmed = mustBeSpace.trim();\n    if (trimmed.length !== 0) {\n      // this wasn't blank or space chars\n      return false;\n    } else if (expectSpace && !mustBeSpace.length) {\n      // there wasn't a space and we expected one\n      return false;\n    }\n\n    if (rest.trim().length !== 0 && suggest.name !== text) {\n      // we're not the end of the string, so only autocomplete if it's entirely typed\n      return false;\n    }\n\n    // dispatch change request on ourselves\n    ga('send', 'event', 'options', 'typing');\n    const detail = {\n      choice: suggest.emoji,\n      word: suggest.name,\n    };\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    return true;\n  }\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', (ev) => {\n    hasPendingSpace = false;\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case 'ArrowDown':\n    case 'Down':\n    case 'ArrowUp':\n    case 'Up':\n      ev.preventDefault();  // disable normal up/down behavior to change focus\n      return;\n\n    case ' ':\n      const success = maybeReplace();\n      if (ev.shiftKey) {\n        ev.preventDefault();  // don't type space if shift held\n      }\n      if (!success) {\n        // hold this for when autocompletes arrive\n        hasPendingSpace = true;\n      }\n      break;\n    }\n  });\n\n  // add a non-deduped keyup handler, for space on mobile browsers ('dreaded keycode 229')\n  el.addEventListener('keyup', (ev) => {\n    // was it a 229 or no code, and was the typed character a space?\n    if (ev.keyCode === 229 || !ev.keyCode) {\n      // TODO: possibly record hasPendingSpace for future arriving suggestions\n      maybeReplace(true);\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = () => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = (call) => {\n    const previousScrollLeft = el.scrollLeft;\n    const {from, to} = sel;\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n    const dir = typer.selectionDirection;\n\n    const update = call(value);\n    if (update == null) { return false; }\n\n    const prev = document.activeElement;\n\n    // select the region and 'type' it with insertText to provide undo/redo history\n    // nb. selecting the typer means that undo will always make us selected; probably fine\n    typer.focus();\n    typer.selectionStart = from;\n    typer.selectionEnd = to;\n    const expected = typer.value.substr(0, from) + update + typer.value.substr(to);\n    if (!document.execCommand('insertText', false, update) || typer.value !== expected) {\n      // set manually: this is fallback / Firefox mode\n      typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n    }\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n\n    const drift = (where) => {\n      if (where >= to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    // pretend we were like this all along\n    [state.start, state.end] = [drift(start), drift(end)];\n    typer.setSelectionRange(state.start, state.end, dir);\n\n    // TODO(samthor): Safari refuses to make this focus after the first above.\n    prev && prev.focus();\n\n    permitNextChange = true;\n    el.scrollLeft = previousScrollLeft;  // before setRange, so the underline is correct\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus emoji, if any\n  el.addEventListener('modifier', (ev) => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus((value) => modifier.modify(value, arg).out);\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', (ev) => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(() => emoji)) { return; }\n\n    // listen to the caller's view on what word we should pretend this emoji is\n    el.dataset['word'] = ev.detail.word || '';\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed, prefix) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    if (!prefix) {\n      all = all.filter(word => word === typed);\n    }\n    all = all.map(word => [word, ...values[word]]);\n\n    return all.length ? all : [];\n  }\n}\n","\nconst resolved = Promise.resolve();\n\n/**\n * Returns a Promise that resolves on `requestIdleCallback`.\n *\n * @return {!Promise<!IdleDeadline>}\n */\nexport function idle() {\n  return new Promise((resolve) => window.requestIdleCallback(resolve));\n}\n\n/**\n * Returns a Promise that resolves on `requestAnimationFrame`.\n *\n * @param {number=} delay whether to also delay by `setTimeout`\n * @return {!Promise<!IdleDeadline>}\n */\nexport function rAF(delay=undefined) {\n  if (delay !== undefined) {\n    return new Promise((resolve) => {\n      window.setTimeout(() => window.requestAnimationFrame(resolve), delay);\n    });\n  }\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n\n/**\n * Returns a Promise that resolves after a microtask.\n *\n * @return {!Promise<void>}\n */\nexport function microtask() {\n  return Promise.resolve();\n}\n\n/**\n * @return {{promise: !Promise<void>, resolver: function(): void}}\n */\nexport function resolver() {\n  let resolver;\n  const promise = new Promise((resolve) => resolver = resolve);\n  return {resolver, promise};\n}\n\n/**\n * @return {!Promise<void>}\n */\nexport function delay(ms=0) {\n  return new Promise((resolve) => window.setTimeout(resolve, ms));\n}\n\nconst debouceMap = new Map();\n\n/**\n * Returns a Promise that debounces a call to the passed callable.\n *\n * @template T\n * @param {function(): T} callable\n * @param {number=} delay\n * @return {!Promise<T>}\n */\nexport function debounce(callable, delay=0) {\n  let state = debouceMap.get(callable);\n  if (!state) {\n    state = {c: callable};\n    const p = new Promise((resolve) => state.r = resolve);\n    state.p = p.then(() => {\n      debouceMap.delete(callable);\n      return state.c();\n    });\n    debouceMap.set(callable, state);\n  }\n\n  window.clearTimeout(state.t);\n  state.t = window.setTimeout(state.r, Math.max(0, delay));\n\n  return state.p;\n}","\n/**\n * Remove duplicate entries from the passed array, only from the 1th index.\n *\n * @param {!Array<string>}\n * @return {!Array<string>}\n */\nfunction removeDuplicates(row) {\n  const found = new Set();\n  return row.filter((item, i) => {\n    if (i !== 0) {\n      if (found.has(item)) { return false; }\n      found.add(item);\n    }\n    return true;\n  });\n}\n\n/**\n * Merge the given results arrays. These will both be in the form of:\n *   [[name, emoji1, emoji2,....], ...]\n *\n * The first argument will be updated with the data from the second argument.\n *\n * @param {!Array<!Array<string>>} existing\n * @param {!Array<!Array<string>>} update\n */\nexport function merge(existing, update) {\n  const lookup = {};\n  existing.forEach((row, i) => lookup[row[0]] = i);\n\n  update.forEach((row) => {\n    const index = lookup[row[0]];\n    if (index === undefined) {\n      lookup[row[0]] = existing.length;  // in case there's dup data\n      existing.push(row);\n      return;\n    }\n\n    // otherwise, just append all new data and place back into array\n    const existingRow = existing[index];\n    const updatedData = row.slice(1);\n    existing[index] = removeDuplicates(existingRow.concat(updatedData));\n  });\n}","const api = 'https://emojibuff.appspot.com/api';\nconst recentLimit = 8;\nconst selectionDelay = 5 * 1000;\n\nimport build from './prefixgen.js';\nimport * as promises from './promises.js';\nimport * as results from './results.js';\n\n/**\n * @param {string} key for endpoint/cache\n * @param {number} expiry in hours\n * @param {(function(boolean): void)=} callback to call with true then false (for loading work)\n * @return {function(): !Promise<!Array<!Array<string>>}\n */\nfunction loaderFor(key, expiry=24, callback=() => {}) {\n  let promiseResults;\n\n  // TODO: refetch after >expiry, don't just invalidate\n\n  const raw = window.localStorage[key];\n  if (raw) {\n    let out;\n    try {\n      out = JSON.parse(raw);\n    } catch (e) {\n      console.debug('couldn\\'t parse localStorage', key, e);\n      out = null;\n    }\n    if (out && out['results']) {\n      promiseResults = Promise.resolve(out['results']);\n      if (out['created'] >= +new Date - (60 * 60 * 1000 * expiry)) {\n        // return immediately, it's less than one day old\n        return () => promiseResults;\n      }\n    }\n  }\n\n  // we don't have data or it's >1day old, refetch\n  // TODO(samthor): Break into retryable fetch.\n  const f = new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${api}/${key}`);\n    xhr.onerror = reject;\n    xhr.responseType = 'json';\n    xhr.onload = () => resolve(xhr.response);\n    xhr.send();\n  }).then((raw) => {\n    // IE11 doesn't respect responseType, and we always return an Object\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }).then((update) => {\n    promiseResults = f;  // can return real results now\n\n    // store in localStorage for next time\n    update['created'] = +new Date();\n    window.localStorage[key] = JSON.stringify(update);\n\n    // return updated results\n    return update['results'];\n  });\n\n  // no local data, wait for data\n  if (!promiseResults) {\n    callback(true);                 // indicate working\n    f.then(() => callback(false));  // done\n    return () => f;\n  }\n\n  return () => promiseResults;\n}\n\n/**\n * Returns the local prefix search tool.\n *\n * @return {!Promise<function(string, boolean): !Array<!Array<string>>>}\n */\nconst getPrefixGen = (function() {\n  const loader = loaderFor('popular', 24, (working) => {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = !working;\n  });\n  return () => {\n    return loader().then((results) => build(results))\n  };\n}());\n\n/**\n * Returns the trending emoji.\n *\n * @return {!Promise<!Array<string>>}\n */\nconst getTrendingEmoji = (function() {\n  const loader = loaderFor('hot', 1);\n  return () => {\n    return loader().then((results) => {\n      let out = [];\n      results.forEach((data) => {\n        out = out.concat(data.slice(1));  // drop name\n      });\n      return out;\n    });\n  };\n}());\n\n/**\n * Requests emoji completion.\n *\n * @param {string} text user has typed\n * @param {boolean} prefix is this a prefix search, or is it a definite whole word?\n * @param {boolean=} more whether to return lots more results for this query\n * @return {!Promise<!Array<!Array>>}\n */\nexport function request(text, prefix, more=false) {\n  if (!text) {\n    if (more && text === '') {\n      const r = recent();\n      r.unshift('^recent');\n\n      return getTrendingEmoji().then((p) => {\n        p.unshift('^trending');\n        return [r, p];\n      });\n    }\n\n    return Promise.resolve([]);\n  }\n\n  const localPromise = getPrefixGen().then((suggest) => suggest(text, prefix));\n  if (!more) {\n    return localPromise;\n  }\n\n  // TODO: At some point, the 'more' data should go into a local cache. For now, just fetch.\n  let url = `${api}/q?q=${window.encodeURIComponent(text)}`;\n  if (!prefix) {\n    url += '&exact';\n  }\n  const morePromise = window.fetch(url).then((out) => out.json()).then((out) => out['results']);\n  return Promise.all([localPromise, morePromise]).then((both) => {\n    const [local, more] = both;\n    results.merge(local, more);\n    return local;\n  });\n}\n\n/**\n * Records use of name/emoji pairs.\n *\n * @param {string} name used to select emoji\n * @param {string} emoji selected\n * @param {!Promise<!Response>} eventual response after delay\n */\nexport const select = (function() {\n  let pending = {};\n\n  const runner = () => {\n    const body = JSON.stringify(pending);\n    pending = {};  // clear pending for next time\n    return navigator.sendBeacon(api + '/sel', body);\n  };\n\n  return function select(name, emoji) {\n    if (name[0] === '^') {\n      return;  // do nothing\n    }\n\n    const r = recent();\n    const index = r.indexOf(emoji);\n    if (index !== -1) {\n      r.splice(index, 1);\n    }\n    r.unshift(emoji);\n    r.splice(recentLimit);\n    window.localStorage['recent'] = r.join(',');\n    // TODO: do something with recent emoji use\n\n    pending[name] = emoji;\n    return promises.debounce(runner, selectionDelay);\n  }\n}());\n\n/**\n * Submit the name of an emoji.\n *\n * @param {string} name\n * @param {string} emoji\n * @return {!Promise<Response>}\n */\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n\n/**\n * Gets recently used emoji.\n *\n * @return {!Array<string>}\n */\nexport function recent() {\n  return (window.localStorage['recent'] || '').split(',').filter((x) => x);\n}","\n/**\n * @fileoverview Async worker.\n */\n\nimport * as promises from './promises.js';\n\nconst allowedWorkTime = 4;\nconst maximumTaskFrame = 100;\n\nexport default class Worker {\n  constructor(fn) {\n    this.fn_ = fn;\n    this.queue_ = [];\n    this.waiting_ = null;\n\n    this.runner_().catch((err) => {\n      console.info('worker runner failed', err);\n      throw err;\n    });\n  }\n\n  async runner_() {\n    await new Promise((resolve) => this.waiting_ = resolve);\n    this.waiting_ = null;\n    await promises.idle();\n\n    for (;;) {\n      if (this.chunk_()) {\n        return this.runner_();\n      }\n      await promises.rAF();\n    }\n  }\n\n  /**\n   * Completes a chunk of work.\n   *\n   * @return {boolean} Whether work is done.\n   */\n  chunk_() {\n    const start = window.performance.now();\n\n    let done = 0;\n    while (this.queue_.length) {\n      const next = this.queue_.shift();\n      next.resolve(this.fn_(next.arg));\n      ++done;\n\n      if (done == maximumTaskFrame || window.performance.now() - start > allowedWorkTime) {\n        break;\n      }\n    }\n\n    return !this.queue_.length;\n  }\n\n  task(arg) {\n    return new Promise((resolve) => {\n      this.queue_.push({resolve, arg});\n      this.waiting_ && this.waiting_();\n    });\n  }\n}\n","\n/**\n * @fileoverview The validator runs constantly and validates emoji rendering.\n */\n\nimport {isExpectedLength} from '../../node_modules/ok-emoji/src/measurer.js';\nimport Worker from './worker.js';\n\nconst dummyString = 'a';  // change if we mess something up\n\nconst prefix = '-ok_';\nconst ls = window.localStorage;\nconst known = new Map();\n\nconst ignoreValid = (window.location.search.indexOf('ignore_valid') !== -1);\n\nfunction runner(emoji) {\n  // nb. Helper code for detecting text-only results from backend.\n  if (emoji.charCodeAt(0) === 0x200b) {\n    return true;\n  }\n  const out = isExpectedLength(emoji);\n  known.set(emoji, out);\n  if (out) {\n    ls[prefix + emoji] = dummyString;  // use dummy small string\n  }\n  return out;\n}\n\nconst worker = new Worker(runner);\nconst task = ignoreValid ? () => true : worker.task.bind(worker);\n\nfunction immediate(emoji) {\n  const immediate = known.get(emoji);\n  if (immediate !== undefined) {\n    return immediate;\n  }\n  if (ls[prefix + emoji] === dummyString) {\n    return true;\n  }\n  return undefined;\n}\n\n/**\n * As per isExpectedLength, but caches successful results.\n *\n * @param {string} string to check\n * @return {!Promise<boolean>} whether this is probably an emoji\n */\nexport async function valid(emoji) {\n  const result = immediate(emoji);\n  if (result !== undefined) {\n    return result;\n  }\n  return task(emoji);\n}\n\n/**\n * Async helper that finds the first valid autocomplete option. Uses a callback in order to hint\n * whether the result is coming in the current frame (before any await) or after (calls callback\n * with null first).\n *\n * @param {!Array<!Array<string>>} options\n * @param {function(?{name: string, emoji: string})} callback\n */\nexport async function findValidMatch(options, callback) {\n  let calledWithDelay = false;\n\n  for (let i = 0; i < options.length; ++i) {\n    const row = options[i];\n    for (let j = 1; j < row.length; ++j) {\n      const emoji = row[j];\n      let result = immediate(emoji);\n      if (result === undefined) {\n        // we have to wait for the runner, so call with a delay\n        if (!calledWithDelay) {\n          callback(null);\n          calledWithDelay = true;\n        }\n        result = await task(emoji);\n      }\n\n      if (result) {\n        return callback({name: row[0], emoji});\n      }\n    }\n  }\n\n  if (!calledWithDelay) {\n    callback(null);\n  }\n}\n","\n/**\n * @fileoverview Emojityper's suggestion handler. Handles creation, showing etc of autocomplete\n * buttons in the UI.\n */\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\nimport {valid, findValidMatch} from './lib/valid.js';\nimport * as promises from './lib/promises.js';\nimport * as eventlib from './lib/event.js';\nimport * as input from './input.js';\nimport * as copier from './lib/copier.js';\n\n/**\n * ButtonManager helps create and show emoji buttons in the UI.\n */\nclass ButtonManager {\n  constructor(holder) {\n    this.holder_ = holder;\n\n    /** @type {!Map<string, !HTMLElement>} */\n    this.options_ = new Map();\n\n    /** @type {!Map<string, !HTMLButtonElement>} */\n    this.buttons_ = new Map();\n\n    /** @type {!WeakMap<!HTMLButtonElement, !DocumentFragment>} */\n    this.buttonTarget_ = new WeakMap();\n\n    /** @type {!Array<!HTMLButtonElement} */\n    this.buttonPool_ = [];\n\n    window.requestIdleCallback(() => {\n      for (let i = 0; i < 10; ++i) {\n        this.buttonPool_.push(document.createElement('button'));\n      }\n    });\n\n    const modifierHolder = document.createElement('div');\n    this.holder_.appendChild(modifierHolder);\n\n    /** @type {function(this:ButtonManager, !Object): void} */\n    this.setModifier = (() => {\n      const genderOption = ButtonManager.optionType_('modifier', 'gender');\n      const toneOption = ButtonManager.optionType_('modifier', 'tone');\n      modifierHolder.appendChild(genderOption);\n      modifierHolder.appendChild(toneOption);\n\n      // helper to create buttons\n      const createModifierButton = (text, value=null) => {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.dataset['value'] = value;\n        return button;\n      };\n\n      // create gender options\n      const genders = [\n        createModifierButton('\\u{26AC}', ''),\n        createModifierButton('\\u{2640}', 'f'),\n        createModifierButton('\\u{2640}\\u{2642}', 'fm'),\n        createModifierButton('\\u{2642}', 'm'),\n        createModifierButton('\\u{2642}\\u{2640}', 'mf'),\n      ];\n\n      // create tone options\n      const tones = [\n        createModifierButton('\\u{2014}', ''),\n      ];\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        tones.push(createModifierButton(String.fromCodePoint(i), i));\n      }\n\n      // helper to add/remove\n      const updateStatus = (yes, node, owner) => {\n        yes ? owner.appendChild(node) : node.remove();\n      };\n      return function(info) {\n        const active =\n            modifierHolder.contains(document.activeElement) ? document.activeElement : null;\n        genders.forEach((node) => {\n          const l = node.dataset['value'].length;\n          const yes = (!l && info.gender.neutral)\n              || (l === 1 && info.gender.single)\n              || (l === 2 && info.gender.double);\n          updateStatus(yes, node, genderOption);\n        });\n        tones.forEach((node) => updateStatus(info.tone, node, toneOption));\n\n        // kick the elements: Safari needs this otherwise sometimes they remain hidden (!)\n        modifierHolder.insertBefore(genderOption, genderOption.nextSibling);\n        modifierHolder.insertBefore(toneOption, toneOption.nextSibling);\n\n        // refocus if one was focused\n        active && active.focus();\n      }\n    })();\n  }\n\n  static optionType_(type, value) {\n    const node = document.createElement('div');\n    node.className = 'options ' + type;\n    node.dataset[type] = value;\n    node.dataset['name'] = value;\n    return node;\n  }\n\n  optionForName_(name) {\n    const prev = this.options_.get(name);\n    if (prev) {\n      return prev;\n    }\n    const node = document.createElement('div');\n    node.className = 'options';\n    node.setAttribute('data-option', name);\n\n    if (name[0] === '^') {\n      node.classList.add('special');\n      name = name.substr(1);\n    }\n    node.setAttribute('data-name', name);  // presentation only\n    return node;\n  }\n\n  /**\n   * Creates a `button` with the textContent of the passed emoji. Starts removed from the page,\n   * but will (when valid) be placed in-order inside the specified `option`.\n   *\n   * @param {!HTMLElement} option to place inside\n   * @param {string} emoji\n   * @return {!HTMLButtonElement}\n   */\n  addEmojiTo_(option, emoji) {\n    let button = this.buttons_.get(emoji);\n    if (button) {\n      // if the button was known, check buttonTarget_: either it's the eventual placement, which\n      // we must replace, or it's a known good/bad already\n      const target = this.buttonTarget_.get(button);\n      if (target === null) {\n        return button;  // known invalid\n      } else if (target === undefined) {\n        option.appendChild(button);  // known good\n        return button;\n      }\n    } else {\n      if (this.buttonPool_.length !== 0) {\n        button = this.buttonPool_.pop();\n      } else {\n        button = document.createElement('button');\n      }\n      button.textContent = emoji;\n      this.buttons_.set(emoji, button);\n\n      valid(emoji).then((isValid) => {\n        if (!isValid) {\n          return this.buttonTarget_.set(button, null);\n        }\n\n        const node = this.buttonTarget_.get(button);\n        node.parentNode.replaceChild(button, node);\n        this.buttonTarget_.delete(button);\n      });\n    }\n\n    const node = document.createTextNode('');  // empty placeholder to replace\n    this.buttonTarget_.set(button, node);\n    option.appendChild(node);\n\n    return button;\n  }\n\n  /**\n   * Updated displayed options with real results. These are expected the API format:\n   *    [[name,emoji,emoji,...],[name,emoji,...],...]\n   *\n   * This retains existing options if they are included in the named results.\n   *\n   * @param {!Array<!Array<string>>}\n   */\n  update(results) {\n    const options = new Map();\n    const buttons = new Map();\n    const previousActiveElement =\n        this.holder_.contains(document.activeElement) ? document.activeElement : null;\n\n    results.forEach((result) => {\n      const name = result[0];\n\n      const option = this.optionForName_(name);\n      options.set(name, option);\n      this.options_.delete(name);\n      this.holder_.appendChild(option);  // reinsert in better order\n\n      // TODO(samthor): This is a bit hacky. This saves buttons that are part of these options,\n      // even if they haven't been sent to us again in results.\n      for (let i = 0; i < option.children.length; ++i) {\n        const b = option.children[i];\n        const emoji = b.textContent;\n        if (buttons.has(emoji)) {\n          b.remove();\n          this.buttonPool_.push(b);\n          --i;\n          continue;\n        }\n        buttons.set(emoji, b);\n      }\n\n      for (let i = 1, emoji; emoji = result[i]; ++i) {\n        if (buttons.has(emoji)) {\n          continue;  // already stolen by something above us\n        }\n        // nb. addEmojiTo_ pulls old buttons from this.buttons_\n        buttons.set(emoji, this.addEmojiTo_(option, emoji));\n      }\n    });\n\n    this.options_.forEach((option) => {\n      // TODO(samthor): Edge doesn't like ...HTMLCollection\n      for (let i = 0; i < option.children.length; ++i) {\n        this.buttonPool_.push(option.children[i]);\n      }\n      option.remove();\n    });\n    this.options_ = options;\n    this.buttons_ = buttons;\n\n    if (previousActiveElement) {\n      if (document.body.contains(previousActiveElement)) {\n        previousActiveElement.focus();\n      } else {\n        typer.focus();  // restore to main input\n      }\n    }\n  }\n}\n\n// key overrides to recognize spacebar causing 'click'\nlet spaceFrame = 0;\nchooser.addEventListener('keyup', (ev) => {\n  if (ev.key !== ' ' || ev.target.localName !== 'button') { return; }\n  spaceFrame = window.setTimeout(() => spaceFrame = 0, 0);\n});\n\n// stores the previous user-driven l/r position\nlet previousChooserLeft = undefined;\nlet duringNavigate = false;\n\n// if a button was focused, reset chooser unless we were going u/d\nchooser.addEventListener('focus', (ev) => {\n  if (!duringNavigate) {\n    previousChooserLeft = document.activeElement.getBoundingClientRect().left;\n  }\n}, true);\n\n/**\n * Navigates through candidates until we find the best not on our current row, and focuses it.\n *\n * @param {!IArrayLike<!Node>} cands\n * @return {boolean} true if we focused something new\n */\nfunction navigateChooserButtonVertical(cands) {\n  const best = {dist: Infinity, button: null};\n\n  const previousRect = document.activeElement.getBoundingClientRect();\n  // did we have a previous explicit l/r position?\n  const left = (previousChooserLeft !== undefined ? previousChooserLeft : previousRect.left);\n\n  let targetTop = undefined;\n  for (let i = 0; i < cands.length; ++i) {\n    const button = cands[i];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    } else if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (!best.button) {\n    return false;\n  }\n  duringNavigate = true;\n  try {\n    best.button.focus();\n  } finally {\n    duringNavigate = false;\n  }\n  return true;\n}\n\n// button click handler\nchooser.addEventListener('click', (ev) => {\n  previousChooserLeft = undefined;  // used a mouse or chose something\n  const isKeyboard = eventlib.isKeyboardClick(ev);\n\n  let label = undefined;\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    if (ev.shiftKey) {\n      return;  // don't do anything\n    }\n\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n    label = 'modifier';\n  } else if (b.parentNode.dataset['option']) {\n    if (ev.shiftKey) {\n      if (copier.copyText(b.textContent)) {\n        ga('send', 'event', 'options', 'copy');\n      }\n\n      // retain scroll position while refocusing on the suitable target\n      const scrollTop = document.scrollingElement.scrollTop;\n      isKeyboard ? b.focus() : typer.focus();\n      document.scrollingElement.scrollTop = scrollTop;\n      return;\n    }\n\n    // nb. we typically clear the word on choice (as it confuses @nickyringland), but if you hit\n    // space or ctrl-click the button, keep it around.\n    const retainWord = (spaceFrame !== 0 || ev.metaKey || ev.ctrlKey);\n    const word = retainWord ? b.parentNode.dataset['option'] : null;\n\n    const detail = {choice: b.textContent, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(b.parentNode.dataset['option'], detail.choice);\n    label = 'emoji';\n  } else {\n    // unknown\n  }\n  if (!label) { return; }\n\n  ga('send', 'event', 'options', 'click', label);\n\n  if (!isKeyboard) {\n    typer.focus();  // nb. we're actually double-refocusing\n  }\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', (ev) => {\n  if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    const typerRect = typer.getBoundingClientRect();\n    previousChooserLeft = typerRect.left + input.cursorPosition(typer);\n\n    if (navigateChooserButtonVertical(chooser.querySelectorAll('button'))) {\n      ga('send', 'event', 'options', 'keyboardnav');\n    }\n  } else if (ev.key === 'ArrowRight' || ev.key === 'Right') {\n    const l = typer.value.length;\n    if (typer.selectionEnd === l && typer.selectionStart === l) {\n      const first = chooser.querySelector('button');\n      first && first.focus();\n    }\n  }\n});\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', (ev) => {\n  const arrow = eventlib.arrowFromEvent(ev);\n  if (!arrow) { return; }\n\n  if (!chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (arrow === 'ArrowLeft') {\n    delta = -1;\n  } else if (arrow === 'ArrowRight') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    } else if (target < 0) {\n      typer.focus();\n      typer.dispatchEvent(new CustomEvent('select-end'));\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  let cands;\n  if (arrow === 'ArrowUp') {\n    cands = buttonArray.slice(0, index);\n    cands.reverse();\n  } else if (arrow === 'ArrowDown') {\n    cands = buttonArray.slice(index);\n  } else {\n    return;\n  }\n\n  if (!navigateChooserButtonVertical(cands)) {\n    if (arrow === 'ArrowUp') {\n      typer.focus();\n    }\n  }\n  if (arrow === 'ArrowDown') {\n    // don't allow arrow scrolling unless we're within 64 pixels of the screen end\n    const focusRect = document.activeElement.getBoundingClientRect();\n    const max = focusRect.top + focusRect.height;\n    if (window.innerHeight - max > 64) {\n      ev.preventDefault();\n    }\n  }\n});\n\n(function() {\n  const longTime = 2000;\n  const delayTime = 250;\n  const manager = new ButtonManager(chooser);\n\n  let previous = {};\n  let previousQueryAt = performance.now();\n  let previousResults = [];\n\n  let suggestInvoke = 0;\n  function findSuggest(q) {\n    const localSuggestInvoke = ++suggestInvoke;\n    if (!q) {\n      typer.dispatchEvent(new CustomEvent('suggest', {detail: null}));\n      return;\n    }\n\n    let exactMatch = null;\n    const localResults = previousResults.slice().filter((row) => {\n      if (q.length > 1 && row[0] === q) {\n        exactMatch = row;\n        return false;\n      }\n      return row[0].startsWith(q);\n    });\n    exactMatch && localResults.unshift(exactMatch);\n\n    const callback = (result) => {\n      if (localSuggestInvoke === suggestInvoke) {\n        typer.dispatchEvent(new CustomEvent('suggest', {detail: result}));\n      }\n    };\n    findValidMatch(localResults, callback);\n  }\n\n  // handler for a prefix search\n  typer.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const now = performance.now();\n\n    // immediately inform manager of modifier buttons (gender, tone), if it's a full word search\n    const info = modifier.modify(!ev.detail.prefix && ev.detail.focus || '');\n    manager.setModifier(info);\n\n    if (previous.text !== query.text) {\n      // text changed, immediately run suggest code\n      findSuggest(query.text);\n    }\n\n    // TODO(samthor): This delays further requests. Ideally we want to 'subscribe' to a topic\n    // from the provider and just be fed updates as fast as we have them (including if we have\n    // a local cache). This way we avoid awkward delays and filtering oddities.\n    const initialMore = previous.text && query.text && previous.text.length !== 0 &&\n        previous.text.startsWith(query.text.substr(0, previous.text.length)) || false;\n\n    let immediate = false;\n    if (!previous.text || previous.prefix !== query.prefix) {\n      immediate = true;  // type changed, user expects snappiness\n    } else if (now - previousQueryAt > longTime) {\n      immediate = true;  // it's been a while\n    }\n    previous = query;\n    previousQueryAt = now;\n\n    const request = async (timeout=0, more=false) => {\n      if (timeout) {\n        await promises.rAF(timeout);\n        if (previous !== query) { return -1; }\n      }\n      const results = await provider.request(query.text, query.prefix, more);\n      if (previous !== query) { return -1; }\n\n      // find the first matching thing and suggest it as autocomplete\n      previousResults = results;\n      findSuggest(query.text);\n\n      return manager.update(results);\n    };\n\n    const p = request(immediate ? 0 : delayTime, initialMore).then((valid) => {\n      if (valid < 0) { return -2; }  // query changed\n\n      if (!query.text) {\n        // TODO: delay empty data by a decent time, except on small screens\n        const timeout = window.innerHeight <= 400 ? 0 : 750;\n        return request(timeout, true);\n      }\n\n      const timeout = Math.max(1000, 100 * Math.pow(valid, 0.75));\n      return request(timeout, true);\n    }).catch((err) => {\n      console.error('error doing request', err);\n    });\n  });\n}());\n","\nimport * as provider from './lib/provider.js';\nimport * as promises from './lib/promises.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let value = '';\n  let pending = null;\n\n  input.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined && query.selection);\n    value = query.focus;\n    if (!selection) {\n      if (!pending) {\n        namer.value = '';  // clear on done if not pending\n        advanced.hidden = true;\n      }\n      return false;\n    }\n    // TODO: round trip to confirm validity of emoji?\n    advanced.hidden = false;\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', (ev) => {\n    ev.preventDefault();\n    if (pending) {\n      return false;  // can't submit while running\n    }\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n\n      pending = null;\n      if (!value) {\n        advanced.hidden = true;\n      }\n    };\n\n    pending = provider.submit(namer.value, value).then((response) => {\n      if (!response.ok) {\n        throw new Error(response.status);\n      }\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err);\n      return true;\n    }).then(cleanup);\n\n    pending.then(() => promises.delay(2000)).then(() => {\n      button.className = '';\n    });\n  });\n}(typer, advanced));\n","\n/**\n * @fileoverview Controls the size and `has-value` class of the body itself based on current input.\n */\n\nimport * as promises from './lib/promises.js';\n\nconst value = (ev) => {\n  const text = ev.detail.trim();\n  document.body.classList.toggle('has-value', Boolean(text));\n};\ntyper.addEventListener('value', value);\nvalue({detail: typer.value});\n\n// global return-to-typer\ndocument.body.addEventListener('keydown', (ev) => {\n  switch (ev.key) {\n  case 'Escape':\n    // #1: focus on typer\n    if (document.activeElement !== typer) {\n      typer.focus();\n      break;\n    }\n\n    // #2: clear selection\n    if (typer.selectionStart !== typer.selectionEnd) {\n      if (typer.selectionDirection === 'backward') {\n        typer.selectionStart = typer.selectionEnd;\n      } else {\n        typer.selectionEnd = typer.selectionStart;\n      }\n      break;\n    }\n\n    // #3: move to end of input\n    const l = typer.value.length;\n    typer.setSelectionRange(l, l);\n    break;\n  }\n});\n\nfunction isExtentNode(node) {\n  return node instanceof Element && node.classList.contains('extent');\n}\n\ndocument.addEventListener('selectionchange', (ev) => {\n  const s = window.getSelection();\n  const {anchorNode: a, focusNode: b} = s;\n  if (a !== b && isExtentNode(a) && isExtentNode(b)) {\n    s.removeAllRanges();  // remove immediately to prevent flash\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('select-all'));\n  }\n}, true);\n\ndocument.addEventListener('focusin', (ev) => {\n  promises.microtask().then(() => {\n    if (document.activeElement === document.body) {\n      typer.focus();\n    }\n  });\n});\n\n// set minHeight to actual viewport height, but allow for keyboard etc\nconst resize = (ev) => {\n  const height = window.innerHeight;\n  document.body.style.minHeight = `${height}px`;\n};\nwindow.addEventListener('resize', resize);\nwindow.addEventListener('load', resize);\nresize();\n\n// Link tracking\n\ndocument.body.addEventListener('click', (ev) => {\n  const target = ev.target && ev.target.closest('a[href]');\n  if (!target) { return; }\n\n  ga('send', 'event', 'outbound', 'click', target.href);\n});\n\n// install code, delay by ~2500ms on load\n\nwindow.setTimeout(() => {\n  const dismissKey = 'dismiss-install';\n  const sourceKey = 'sources';\n  const sources = (window.localStorage[sourceKey] || '').split(',').filter(Boolean);\n\n  const sourceMatch = /utm_source=([_\\w\\d]*)/;\n  const m = sourceMatch.exec(window.location.search);\n  if (m) {\n    if (sources.indexOf(m[1]) === -1) {\n      sources.push(m[1]);\n    }\n    window.localStorage[sourceKey] = sources.join(',');\n  }\n\n  if (sources.length || window.localStorage[dismissKey]) {\n    return;  // we have been installed somewhere already\n  }\n\n  const footer = document.querySelector('footer');\n  footer.addEventListener('click', (ev) => {\n    if (!ev.target.classList.contains('dismiss-install')) {\n      return;\n    }\n    ga('send', 'event', 'install', 'dismiss');\n    window.localStorage[dismissKey] = true;\n    document.body.removeAttribute('data-install');\n  });\n\n  // TODO(samthor): Allow showing both ext/windows on say, Chrome Windows.\n  if (document.body.dataset['install']) {\n    // we probably got pipped to the post by PWA install, great\n  } else if (navigator.userAgent.match(/Chrome\\//) && navigator.platform.match(/^(Mac|Win|Linux)/)) {\n    // We're Chrome on some kind of desktop\n    document.body.dataset['install'] = 'ext';\n  } else if (typeof Windows === 'undefined' && navigator.platform.startsWith('Win')) {\n    // 'Windows' not found (not already installed), and on Windows\n    document.body.dataset['install'] = 'windows';\n  }\n\n}, 2500);\n\n// PWA install code below, run immediately\n\n(function() {\n\n  let deferredPrompt = null;\n\n  function cleanupPrompt() {\n    document.body.removeAttribute('data-install');\n    deferredPrompt = null;\n  }\n\n  window.addEventListener('beforeinstallprompt', (ev) => {\n    ga('send', 'event', 'install', 'available');\n    document.body.dataset['install'] = 'pwa';\n    deferredPrompt = ev;\n    ev.preventDefault();\n    return false;\n  });\n\n  window.addEventListener('appinstalled', (ev) => {\n    ga('send', 'event', 'install', 'installed');\n    cleanupPrompt();\n  });\n\n  const installEl = document.getElementById('install');\n  installEl.addEventListener('click', (ev) => {\n    if (!deferredPrompt) {\n      return;\n    }\n    deferredPrompt.prompt();\n\n    if (!deferredPrompt.userChoice) {\n      return;  // older Chrome\n    }\n\n    deferredPrompt.userChoice.then((result) => {\n      ga('send', 'event', 'install', result);\n      // TODO: should we listen to appinstalled? I suppose we don't know what the user said.\n    }).catch((err) => {\n      console.warn('beforeinstallprompt prompt', err);\n    }).then(cleanupPrompt);\n  });\n\n}());\n","\n/**\n * @fileoverview Rotates through various advertisements in Emojityper.\n */\n\nconst adverts = document.getElementById('adverts');\n\nfunction refresh() {\n  const active = adverts.querySelector('.active');\n  const next = (active && active.nextElementSibling || adverts.firstElementChild);\n  if (!next) {\n    console.warn('no adverts to choose from');\n    return;\n  }\n\n  active && active.classList.remove('active');\n  next.classList.add('active');\n\n  enqueue();\n}\n\nlet timeout;\nfunction enqueue() {\n  window.clearTimeout(timeout);\n  timeout = window.setTimeout(() => {\n    window.requestAnimationFrame(refresh);\n  }, 10 * 1000);\n}\n\nenqueue();\n","\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('./sw.js').catch((err) => {\n    console.warn('failed to register SW', err);\n  });\n\n  const hadInitialController = Boolean(navigator.serviceWorker.controller);\n  navigator.serviceWorker.addEventListener('controllerchange', () => {\n    if (hadInitialController) {\n      // only reload if we had a SW on load\n      console.debug('got SW controllerchange, reload');\n      window.location.reload();\n    } else {\n      // this is the very first SW, so reloading doesn't help us\n    }\n  });\n}\n","\nimport {debounce} from './lib/promises.js';\n\nlet prevOnLine = true;\n\nfunction notifyStatus() {\n  if ('onLine' in navigator && prevOnLine !== navigator.onLine) {\n    ga('send', 'event', 'network', navigator.onLine ? 'online' : 'offline');\n    prevOnLine = navigator.onLine;\n  }\n}\n\nnotifyStatus();\nwindow.addEventListener('online', () => debounce(notifyStatus));\nwindow.addEventListener('offline', () => debounce(notifyStatus));\n","\nconst placeholders = [\n  'Type words, receive emoji 👍',\n  'Use your keyboard to search 🔎',\n  'Find emoji that your heart desires ❤️⌨️',\n  'Keyboard. Emoji. Forever 😍',\n  'Keyboard emoji since 2016 📜',\n  'Just tap a key to search 👆',\n  'Type, tap enter to copy, profit 💸',\n  'Emoji for every occasion, just type 🔡',\n];\n\nconst choice = Math.floor(Math.random() * placeholders.length);\ntyper.placeholder = placeholders[choice];\n","\nimport './polyfill.js';\nimport './buttons.js';\nimport './input.js';\nimport './options.js';\nimport './selection.js';\nimport './page.js';\nimport './adverts.js';\nimport './sw.js';\nimport './offline.js';\nimport './placeholders.js';\n\n// global error handler for logs\nwindow.onerror = (msg, file, line, col, error) => {\n  console.info('got err', String(msg));\n  try {\n    ga('send', 'event', 'error', `${file},${line}:${col}`, String(msg), {nonInteraction: true});\n  } catch (e) {}\n};\n"]}