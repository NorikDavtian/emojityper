{"version":3,"file":"e8138ddd.js","sources":["src/lib/promises.js","src/lib/results.js","src/lib/type.js","src/lib/provider.js","src/lib/prefixgen.js"],"sourcesContent":["\nconst resolved = Promise.resolve();\n\n/**\n * Returns a Promise that resolves on `requestIdleCallback`.\n *\n * @return {!Promise<!IdleDeadline>}\n */\nexport function idle() {\n  return new Promise((resolve) => window.requestIdleCallback(resolve));\n}\n\n/**\n * Returns a Promise that resolves on `requestAnimationFrame`.\n *\n * @param {number=} delay whether to also delay by `setTimeout`\n * @return {!Promise<!IdleDeadline>}\n */\nexport function rAF(delay=undefined) {\n  if (delay !== undefined) {\n    return new Promise((resolve) => {\n      window.setTimeout(() => window.requestAnimationFrame(resolve), delay);\n    });\n  }\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n\n/**\n * Returns a Promise that resolves after a microtask.\n *\n * @return {!Promise<void>}\n */\nexport function microtask() {\n  return Promise.resolve();\n}\n\n/**\n * @return {{promise: !Promise<void>, resolver: function(): void}}\n */\nexport function resolver() {\n  let resolver;\n  const promise = new Promise((resolve) => resolver = resolve);\n  return {resolver, promise};\n}\n\n/**\n * @return {!Promise<void>}\n */\nexport function delay(ms=0) {\n  return new Promise((resolve) => window.setTimeout(resolve, ms));\n}\n\nconst debouceMap = new Map();\n\n/**\n * Returns a Promise that debounces a call to the passed callable.\n *\n * @template T\n * @param {function(): T} callable\n * @param {number=} delay\n * @return {!Promise<T>}\n */\nexport function debounce(callable, delay=0) {\n  let state = debouceMap.get(callable);\n  if (!state) {\n    state = {c: callable};\n    const p = new Promise((resolve) => state.r = resolve);\n    state.p = p.then(() => {\n      debouceMap.delete(callable);\n      return state.c();\n    });\n    debouceMap.set(callable, state);\n  }\n\n  window.clearTimeout(state.t);\n  state.t = window.setTimeout(state.r, Math.max(0, delay));\n\n  return state.p;\n}","\n/**\n * Remove duplicate entries from the passed array, only from the 1th index.\n *\n * @param {!Array<string>}\n * @return {!Array<string>}\n */\nfunction removeDuplicates(row) {\n  const found = new Set();\n  return row.filter((item, i) => {\n    if (i !== 0) {\n      if (found.has(item)) { return false; }\n      found.add(item);\n    }\n    return true;\n  });\n}\n\n/**\n * Merge the given results arrays. These will both be in the form of:\n *   [[name, emoji1, emoji2,....], ...]\n *\n * The first argument will be updated with the data from the following arguments.\n *\n * @param {...!Array<!Array<string>>} all\n */\nexport function merge(...all) {\n  if (!all.length) {\n    return [];\n  }\n\n  const lookup = {};\n  const existing = all.shift();\n  existing.forEach((row, i) => lookup[row[0]] = i);\n\n  all.forEach((update) => {\n    update.forEach((row) => {\n      const index = lookup[row[0]];\n      if (index === undefined) {\n        lookup[row[0]] = existing.length;  // in case there's dup data\n        existing.push(row);\n        return;\n      }\n  \n      // otherwise, just append all new data and place back into array\n      const existingRow = existing[index];\n      const updatedData = row.slice(1);\n      existing[index] = removeDuplicates(existingRow.concat(updatedData));\n    });\n  });\n\n  return existing;\n}","const options = {\n  'abcd': [0x1f521],\n  'abc': [0x1f524],\n  'ab': [0x1f18e],\n  'a': [0x1f170, 0xfe0f],\n  'atm': [0x1f3e7],\n  'cool': [0x1f192],\n  'free': [0x1f193],\n  'id': [0x1f194],\n  'i': [0x2139, 0xfe0f],\n  'm': [0x24c2, 0xfe0f],\n  'ok': [0x1f197],\n  'o': [0x1f17e, 0xfe0f],\n  'p': [0x1f17f, 0xfe0f],\n  'sos': [0x1f198],\n  'up': [0x1f199],\n  'vs': [0x1f19a],\n  '!!': [0x203c, 0xfe0f],\n  '!?': [0x2049, 0xfe0f],\n  '!': [0x2757],\n  '?': [0x2753],\n  '$': [0x1f4b2],\n  '£': [0x1f4b7],\n  '€': [0x1f4b6],  // FIXME: emojityper doesn't think this is a word char\n  '¥': [0x1f4b4],\n  'new': [0x1f195],\n  'ng': [0x1f196],\n  'zzz': [0x1f4a4],\n  '1234': [0x1f522],\n  'cl': [0x1f191],\n  'b': [0x1f171, 0xfe0f],\n  'wc': [0x1f6be],\n  '100': [0x1f4af],\n  '10': [0x1f51f],\n  '*': [0x2a, 0xfe0f, 0x20e3],\n  '#': [0x23, 0xfe0f, 0x20e3],\n// \"tm\" is a bit subtle\n//  'tm': [0x2122, 0xfe0f],\n  '<': [0x25c0, 0xfe0f],\n  '>': [0x25b6, 0xfe0f],\n  '^': [0x1f53c],\n  '+': [0x2795],\n  '-': [0x2796],\n  'x': [0x274e],\n  '~': [0x3030, 0xfe0f],\n  '.': [0x23fa, 0xfe0f],\n};\n\n\nconst keys = Object.keys(options);\nkeys.sort((a, b) => {\n  if (a.length !== b.length) {\n    return b.length - a.length;\n  }\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return +1;\n  }\n  return 0;\n});\n\n\nconst matchPrefix = (s, preferLetter) => {\n  let cand = null;\n\n  if (s[0] >= 'a' && s[0] <= 'z') {\n    const point = 0x1f1e6 + (s.codePointAt(0) - 97);\n    cand = {length: 1, points: [point, 0xfe0f]};\n  } else if (s[0] >= '0' && s[0] <= '9') {\n    const point = 0x30 + (s.codePointAt(0) - 48);\n    cand = {length: 1, points: [point, 0xfe0f, 0x20e3]};\n  }\n\n  if (preferLetter && cand) {\n    return cand;\n  }\n\n  for (const k of keys) {\n    if (s.startsWith(k)) {\n      return {length: k.length, points: options[k]};\n    }\n  }\n  return cand;\n};\n\n\nexport default function(value, preferLetter=false) {\n  let work = value.toLowerCase();\n  const out = [];\n\n  while (work.length) {\n    const matched = matchPrefix(work, preferLetter);\n    if (matched === null) {\n      return null;  // fail early, can't emoji-fy this\n    }\n    out.push(...matched.points);\n    work = work.substr(matched.length);\n  }\n\n  return String.fromCodePoint(...out);\n}","const api = 'https://emojibuff.com/api';\nconst recentLimit = 16;\nconst selectionDelay = 5 * 1000;\n\nimport build from './prefixgen.js';\nimport * as promises from './promises.js';\nimport * as results from './results.js';\nimport type from './type.js';\n\n/**\n * @param {string} key for endpoint/cache\n * @param {number} expiry in hours\n * @param {(function(boolean): void)=} callback to call with true then false (for loading work)\n * @return {function(): !Promise<!Array<!Array<string>>}\n */\nfunction loaderFor(key, expiry=24, callback=() => {}) {\n  let promiseResults;\n\n  // TODO: refetch after >expiry, don't just invalidate\n\n  const raw = window.localStorage[key];\n  if (raw) {\n    let out;\n    try {\n      out = JSON.parse(raw);\n    } catch (e) {\n      console.debug('couldn\\'t parse localStorage', key, e);\n      out = null;\n    }\n    if (out && out['results']) {\n      promiseResults = Promise.resolve(out['results']);\n      if (out['created'] >= +new Date - (60 * 60 * 1000 * expiry)) {\n        // return immediately, it's less than one day old\n        return () => promiseResults;\n      }\n    }\n  }\n\n  // we don't have data or it's >1day old, refetch\n  // TODO(samthor): Break into retryable fetch.\n  const f = new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', `${api}/${key}`);\n    xhr.onerror = reject;\n    xhr.responseType = 'json';\n    xhr.onload = () => resolve(xhr.response);\n    xhr.send();\n  }).then((raw) => {\n    // IE11 doesn't respect responseType, and we always return an Object\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  }).then((update) => {\n    promiseResults = f;  // can return real results now\n\n    // store in localStorage for next time\n    update['created'] = +new Date();\n    window.localStorage[key] = JSON.stringify(update);\n\n    // return updated results\n    return update['results'];\n  });\n\n  // no local data, wait for data\n  if (!promiseResults) {\n    callback(true);                 // indicate working\n    f.then(() => callback(false));  // done\n    return () => f;\n  }\n\n  return () => promiseResults;\n}\n\n/**\n * Returns the local prefix search tool.\n *\n * @return {!Promise<function(string, boolean): !Array<!Array<string>>>}\n */\nconst getPrefixGen = (function() {\n  const loader = loaderFor('popular', 24, (working) => {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = !working;\n  });\n  return () => {\n    return loader().then((results) => build(results))\n  };\n}());\n\n/**\n * Returns the trending emoji.\n *\n * @return {!Promise<!Array<string>>}\n */\nconst getTrendingEmoji = (function() {\n  const loader = loaderFor('hot', 1);\n  return () => {\n    return loader().then((results) => {\n      let out = [];\n      results.forEach((data) => {\n        out = out.concat(data.slice(1));  // drop name\n      });\n      return out;\n    });\n  };\n}());\n\n/**\n * Requests emoji completion.\n *\n * @param {string} text user has typed\n * @param {boolean} prefix is this a prefix search, or is it a definite whole word?\n * @param {boolean=} more whether to return lots more results for this query\n * @return {!Promise<!Array<!Array>>}\n */\nexport function request(text, prefix, more=false) {\n  if (!text) {\n    if (more && text === '') {\n      const r = recent();\n      r.unshift('^recent');\n\n      return getTrendingEmoji().then((p) => {\n        p.unshift('^trending');\n        return [r, p];\n      });\n    }\n\n    return Promise.resolve([]);\n  }\n\n  const all = [\n    getPrefixGen().then((suggest) => suggest(text, prefix)),\n  ];\n\n  if (more) {\n    // TODO: At some point, the 'more' data should go into a local cache. For now, just fetch.\n    let url = `${api}/q?q=${window.encodeURIComponent(text)}`;\n    if (!prefix) {\n      url += '&exact';\n    }\n    const morePromise = window.fetch(url).then((out) => out.json()).then((out) => out['results']);\n    all.push(morePromise);\n  }\n\n  const typer = type(text);\n  const typerLetter = type(text, true);\n  if (typer || typerLetter) {\n    const r = ['^type'];\n    if (typer) {\n      r.push(typer);\n    }\n    if (typerLetter && typerLetter !== typer) {\n      r.push(typerLetter);\n    }\n    all.push([r]);\n  }\n\n  return Promise.all(all).then((out) => results.merge(...out));\n}\n\n/**\n * Records use of name/emoji pairs.\n *\n * @param {string} name used to select emoji\n * @param {string} emoji selected\n * @param {!Promise<!Response>} eventual response after delay\n */\nexport const select = (function() {\n  let pending = {};\n\n  const runner = () => {\n    const body = JSON.stringify(pending);\n    pending = {};  // clear pending for next time\n\n    if (window._dev) {\n      return null;  // don't log in dev\n    }\n\n    return navigator.sendBeacon(api + '/sel', body);\n  };\n\n  return function select(name, emoji) {\n    if (name[0] === '^') {\n      return;  // do nothing\n    }\n\n    const r = recent();\n    const index = r.indexOf(emoji);\n    if (index !== -1) {\n      r.splice(index, 1);\n    }\n    r.unshift(emoji);\n    r.splice(recentLimit);\n    window.localStorage['recent'] = r.join(',');\n    // TODO: do something with recent emoji use\n\n    pending[name] = emoji;\n    return promises.debounce(runner, selectionDelay);\n  }\n}());\n\n/**\n * Submit the name of an emoji.\n *\n * @param {string} name\n * @param {string} emoji\n * @return {!Promise<Response>}\n */\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n\n/**\n * Gets recently used emoji.\n *\n * @return {!Array<string>}\n */\nexport function recent() {\n  return (window.localStorage['recent'] || '').split(',').filter((x) => x);\n}","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed, prefix) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    if (!prefix) {\n      all = all.filter(word => word === typed);\n    }\n    all = all.map(word => [word, ...values[word]]);\n\n    return all.length ? all : [];\n  }\n}\n"],"names":["idle","Promise","resolve","window","requestIdleCallback","rAF","delay","undefined","setTimeout","requestAnimationFrame","microtask","ms","debouceMap","Map","debounce","callable","state","get","c","p","r","then","delete","set","clearTimeout","t","Math","max","merge","all","length","lookup","existing","shift","forEach","row","i","update","index","push","existingRow","updatedData","slice","found","Set","filter","item","has","add","removeDuplicates","concat","options","abcd","abc","ab","a","atm","cool","free","id","m","ok","o","sos","up","vs","!!","!?","!","?","$","£","€","¥","new","ng","zzz","1234","cl","b","wc","100","10","*","#","<",">","^","+","-","x","~",".","keys","Object","sort","matchPrefix","s","preferLetter","cand","points","codePointAt","k","startsWith","value","work","toLowerCase","out","matched","substr","String","fromCodePoint","api","loaderFor","key","promiseResults","expiry","callback","raw","localStorage","JSON","parse","e","console","debug","Date","f","reject","xhr","XMLHttpRequest","open","onerror","responseType","onload","response","send","stringify","getPrefixGen","loader","working","hidden","results","prefixLength","maxSuggestions","prefixSuggest","values","data","prefix","part","opts","typed","rest","word","map","build","getTrendingEmoji","request","text","more","recent","unshift","suggest","url","encodeURIComponent","morePromise","fetch","json","typer","type","typerLetter","select","pending","runner","body","_dev","navigator","sendBeacon","name","emoji","indexOf","splice","join","promises","submit","FormData","append","method","mode","split"],"mappings":"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"}