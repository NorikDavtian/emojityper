{"version":3,"sources":["src/polyfill.js","src/buttons.js","src/lib/modifier.js","src/input.js","src/lib/prefixgen.js","src/lib/promises.js","src/lib/results.js","src/lib/provider.js","src/lib/worker.js","src/lib/valid.js","src/lib/event.js","src/options.js","src/selection.js","src/page.js","src/adverts.js","src/sw.js","src/offline.js"],"names":["window","requestIdleCallback","callback","start","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","setTimeout","cancelIdleCallback","id","clearTimeout","navigator","sendBeacon","url","body","Promise","resolve","reject","xhr","XMLHttpRequest","open","onerror","onload","send","all","Array","from","buttons","querySelectorAll","handler","ev","text","detail","trim","hasValue","Boolean","forEach","button","disabled","typer","addEventListener","value","input","timeout","defaultText","textContent","spaceRe","key","click","focus","end","selectionStart","selectionEnd","left","right","length","exec","substr","ok","document","execCommand","e","console","warn","info","ga","dataset","copied","copy","canvas","createElement","context","getContext","font","measureText","cache","count","s","result","undefined","width","fixedWidthEmoji","platform","isSingle","debugMode","location","search","indexOf","emojiWidth","debug","invalidWidth","characterWidth","isExpectedLength","chars","splitEmoji","jsdecode","flags","reduce","total","char","isFlagPoint","point","expectedLength","ceil","floor","clen","i","String","fromCodePoint","map","c","basicDiversity","isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","unlikelyModifierBase","len","points","raw","charCodeAt","extra","push","genderFlip","list","Map","data","f","m","n","j","v","has","Error","set","out","get","single","neutral","curr","suffix","check","next","modify","opt_op","stats","tone","gender","double","record","some","first","genderable","family","ch","flip","isSinglePerson","candidate","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","allowOtherFlip","genderPoint","concat","datasetSafeDelete","el","keys","d","upgraded","WeakMap","cursorPosition","upgrade","isWordCode","code","helper","className","parentNode","insertBefore","underline","appendChild","sizer","nonce","offsetLeft","mid","scrollLeft","readyState","classList","add","renderLine","remove","hidden","to","getElementById","style","transform","setRange","initialLength","state","previousDetail","mergedEventHandler","events","permitNextChange","dispatchEvent","CustomEvent","isNotWordAfter","changeHandler","prefix","word","selection","frame","Set","dedup","clear","requestAnimationFrame","type","split","event","which","activeElement","scrollLeftOnBlur","preventDefault","keyCode","dedupRenderLine","passive","replaceFocus","call","previousScrollLeft","update","drift","where","prev","arg","[object Object]","modifier.modify","emoji","choice","build","prefixLength","maxSuggestions","prefixSuggest","values","k","slice","part","opts","typed","rest","toLowerCase","filter","startsWith","idle","rAF","delay","ms","debouceMap","debounce","callable","r","then","delete","t","removeDuplicates","row","found","item","merge","existing","lookup","existingRow","updatedData","api","recentLimit","selectionDelay","getPrefixGen","localPromise","localStorage","JSON","parse","Date","responseType","response","loader","stringify","remotePromise","promiseToReturn","request","more","recent","unshift","suggest","encodeURIComponent","morePromise","fetch","json","both","local","results.merge","select","pending","runner","name","splice","join","promises.debounce","submit","FormData","append","method","mode","x","allowedWorkTime","maximumTaskFrame","Worker","this","fn_","queue_","waiting_","runner_","catch","err","promises.idle","chunk_","promises.rAF","done","shift","ls","known","worker","async","valid","immediate","task","arrowKeys","arrowFromEvent","ButtonManager","holder","holder_","pendingFirstEmoji_","options_","buttons_","buttonTarget_","modifierHolder","setModifier","genderOption","optionType_","toneOption","createModifierButton","genders","tones","updateStatus","yes","node","owner","active","contains","l","nextSibling","setAttribute","option","target","isValid","replaceChild","createTextNode","cand","firstElementChild","checker","immediateResult","immediateFirstEmojiForOption_","results","options","previousActiveElement","optionForName_","children","b","addEmojiTo_","spaceFrame","chooser","localName","previousChooserLeft","duringNavigate","navigateChooserButtonVertical","cands","best","dist","Infinity","previousRect","getBoundingClientRect","targetTop","candidateRect","top","abs","copyText","dummy","position","isKeyboard","screenX","label","shiftKey","scrollTop","scrollingElement","metaKey","ctrlKey","provider.select","typerRect","input.cursorPosition","arrow","eventlib.arrowFromEvent","buttonArray","delta","reverse","focusRect","height","innerHeight","manager","previous","previousQueryAt","pendingFirstEmojiRequest","query","provider.request","pow","error","invalidLetterRe","replace","simplifyWord","firstEmojiForOption","advanced","form","querySelector","namer","provider.submit","status","_","promises.delay","toggle","resize","minHeight","deferredPrompt","cleanupPrompt","installEl","prompt","userChoice","adverts","refresh","nextElementSibling","enqueue","serviceWorker","register","controller","reload","prevOnLine","notifyStatus","onLine"],"mappings":"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","file":"bundle-b39e2f6d4e.js","sourcesContent":["\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nif (!window.requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = (callback) => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\nif (!navigator.sendBeacon) {\n  navigator.sendBeacon = function(url, body) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', url, true);\n      xhr.onerror = reject;\n      xhr.onload = resolve;\n      xhr.send(body);\n    });\n  };\n}\n","\n/**\n * @fileoverview Handles the buttons in the top-right of the page (currently just Copy).\n */\n\nconst all = Array.from(buttons.querySelectorAll('button'));\n\nconst handler = (ev) => {\n  const text = ev.detail.trim();\n  const hasValue = Boolean(text);\n  all.forEach(button => button.disabled = !hasValue);\n};\ntyper.addEventListener('value', handler);\nhandler({detail: typer.value});\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = () => {\n    const [start, end] = [input.selectionStart, input.selectionEnd];\n\n    // find start/end of content (trim, but find positions)\n    let left = 0;\n    let right = input.value.length;\n    if (input.selectionStart !== input.selectionEnd) {\n      left = input.selectionStart;\n      right = input.selectionEnd;\n    }\n    left += spaceRe.exec(input.value.substr(left))[0].length;\n    right = left + input.value.substr(left, right - left).trim().length;\n    if (right <= left) { return false; }\n\n    input.focus();\n    input.selectionStart = left;\n    input.selectionEnd = right;\n\n    let ok = false;\n    try {\n      ok = document.execCommand('copy');\n    } catch(e) {\n      console.warn('could not copy', e);\n      ok = false;\n    }\n    // restore previous selection\n    [input.selectionStart, input.selectionEnd] = [start, end];\n\n    if (!ok) { return true; }\n    console.info('copied', input.value.substr(left, right));\n\n    // analytics\n    ga('send', 'event', 'text', 'copy');\n\n    // show message\n    button.textContent = button.dataset.copied;\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout((ev) => {\n      button.textContent = defaultText;\n    }, 500);\n  };\n\n  input.addEventListener('keydown', ev => {\n    if (ev.key == 'Enter') {\n      button.click();\n      input.focus();\n    }\n  });\n  button.addEventListener('click', ev => {\n    copy();\n    button.focus();\n  });\n}(copy, typer));\n\n","\nconst canvas = document.createElement('canvas');\nconst context = canvas.getContext('2d');\ncontext.font = '1px monospace';\n\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  let cache = {};\n  let count = 0;\n\n  return s => {\n    let result = cache[s];\n    if (result === undefined) {\n      cache[s] = result = context.measureText(s).width;\n      if (++count > 4000) {\n        // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n        // probably greater than we'll ever use: still, empty if it's too big\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/.exec(navigator.platform));\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single char long (and probably a single emoji)\n */\nconst isSingle = (function() {\n  const debugMode = window.location.search.indexOf('debug') !== -1;\n\n  // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n  const emojiWidth = measureText('\\u{1f602}');\n  if (fixedWidthEmoji) {\n    if (debugMode) {\n      console.info('fixed emoji width is', emojiWidth, 'for \\u{1f602}');\n      return (s) => {\n        const ok = measureText(s) === emojiWidth;\n        if (!ok) {\n          console.debug('isSingle can\\'t render', s, 'width', measureText(s));\n        }\n        return ok;\n      };\n    }\n    // great! We can quickly check this!\n    return (s) => measureText(s) === emojiWidth;\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  const characterWidth = context.measureText('a').width;\n  if (debugMode) {\n    console.info('invalid char has width', invalidWidth, 'ascii char has width', characterWidth);\n  }\n  return (s) => {\n    const width = measureText(s);\n    if (debugMode) {\n      console.debug('isSingle', s, 'has width', width);\n    }\n    return (width !== invalidWidth && width < invalidWidth * 2 && width > characterWidth) ||\n        width === emojiWidth;\n  };\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emojis? On variable width\n * platforms, this can take O(n).\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  // FIXME: This treats ZWJ'ed characters that aren't a single char as invalid. Maybe it's not\n  // worth worrying, but instead just checking that all the points are valid emoji.\n\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return (s) => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return (s) => {\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n    const clen = chars.length;\n    for (let i = 0; i < clen; ++i) {\n      const char = chars[i];\n      if (char.length === 0 && isFlagPoint(char[0].point)) {\n        continue;  // treat flag chars as A-OK\n      }\n      // measure this particular point and ensure it's single.\n      const s = String.fromCodePoint(...char.map(c => c.point));\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nfunction jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0x1f9d2,  // girl, boy, child\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return point => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number}>>}\n */\nfunction splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{tone: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), tone: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const stats = {tone: false, gender: {single: false, double: false, neutral: false}};\n  if (!s) {\n    return stats;\n  }\n  const points = jsdecode(s);\n\n  // split out gender modifiers and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach(ch => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.tone = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.tone || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.tone && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.tone = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach(ch => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        if (genderPoint && isSingle(String.fromCodePoint(first) + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.tone !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.tone;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.tone;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach(ch => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","\nimport * as modifier from './lib/modifier.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach((key) => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\nconst upgraded = new WeakMap();\n\nexport function cursorPosition(el) {\n  const fn = upgraded.get(el);\n  if (fn !== undefined) {\n    return fn();\n  }\n  return undefined;\n}\n\n// word focus handler\nfunction upgrade(el) {\n  if (upgraded.has(el)) {\n    return false;\n  }\n\n  const isWordCode = (code) => {\n    // FIXME: turns out matching non-emoji is hard\n    // TODO: this RegExp _might_ work but it needs transpiling-\n    // new RegExp(/(?:[\\p{Letter}\\p{Number}\\p{Punctuation}](?!\\u{fe0f}?\\u{20e3}))+/u);\n    return code < 5000 && code != 32;\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  // measures the width of text\n  const measureText = (function() {\n    const sizer = document.createElement('div');\n    sizer.className = 'sizer';\n    helper.appendChild(sizer);\n\n    const nonce = document.createElement('div');\n    nonce.className = 'nonce';\n\n    return (text) => {\n      sizer.textContent = text;\n      sizer.appendChild(nonce);\n      return nonce.offsetLeft;\n    }\n  }());\n\n  // record upgraded measurer for callers to find our pixel position\n  upgraded.set(el, () => {\n    const mid = ~~((el.selectionStart + el.selectionEnd) / 2)\n    return measureText(el.value.substr(0, mid)) - el.scrollLeft;\n  });\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', (ev) => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = () => {\n    if (el.dataset.from === undefined) {\n      underline.hidden = true;\n      return false;\n    }\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n\n    // otherwise, record and draw the line\n    const left = measureText(el.value.substr(0, from));\n    const width = measureText(el.value.substr(from, to - from));\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = `translateX(-${el.scrollLeft}px)`;\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    [el.dataset.from, el.dataset.to] = [from, to];\n    if (from >= to) {\n      datasetSafeDelete(el, 'prefix', 'word', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = (permitNextChange) => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // range selection, magic\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix', 'word');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // calculate from/to locally\n    let from = state.start;\n    let to = state.start;\n\n    // are we at the end (only have spaces until end)?\n    const isAtEnd = !el.value.substr(state.end).trim();\n    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));\n\n    if (isNotWordAfter) {\n      for (; to > 0; --to) {\n        if (el.value.charCodeAt(to - 1) !== 32) {\n          break;\n        }\n      }\n      if (to < from) {\n        from = to;\n      }\n    }\n\n    // walk backwards while the previous character is a word\n    for (; from > 0; --from) {\n      if (!isWordCode(el.value.charCodeAt(from - 1))) {\n        break;\n      }\n    }\n\n    // walk forwards while the next char is not a space\n    for (; to < el.value.length; ++to) {\n      if (!isWordCode(el.value.charCodeAt(to))) {\n        break;\n      }\n    }\n\n    // if it's invalid, but there's not a word after, and we were permitted, ignore\n    if (from >= to && isNotWordAfter && permitNextChange) { return; }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);\n      datasetSafeDelete(el, 'word');\n    }\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  let previousDetail = {};\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('focus')) {\n      // only if it wasn't a range selection (otherwise clicking back retains range, weird)\n      if (state.start === state.end) {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }\n\n    // run change handler: if true, nothing changed\n    if (changeHandler(permitNextChange)) { return; }\n\n    // send query: prefix or whole-word\n    let text = el.dataset.prefix || el.dataset.word || null;\n    if (!el.dataset.focus) {\n      text = '';  // nothing focused, pretend it's empty input\n    }\n    const detail = {\n      text,\n      prefix: 'prefix' in el.dataset,\n      focus: el.dataset.focus,\n      selection: (el.selectionStart !== el.selectionEnd),\n    };\n\n    // send event only if something has changed\n    if (detail.text !== previousDetail.text ||\n        detail.prefix !== previousDetail.prefix ||\n        detail.focus !== previousDetail.focus ||\n        detail.selection !== previousDetail.selection) {\n      previousDetail = detail;\n      el.dispatchEvent(new CustomEvent('query', {detail}));\n    }\n  };\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = (ev) => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input';\n    rest.split(/\\s+/).forEach((event) => el.addEventListener(event, dedup));\n    dedup();\n\n    // if a user is dragging around, this might be changing the offsetLeft (dragging input l/r)\n    el.addEventListener('mousemove', (ev) => {\n      if (ev.which) {\n        dedup();\n      }\n    });\n\n    // add 'selectionchange' (only valid on document) to listen to the initial long-press selection\n    // on Chrome (possibly others?) mobile: it doesn't generate 'select'.\n    document.addEventListener('selectionchange', (ev) => {\n      if (document.activeElement === el) {\n        dedup();\n      }\n    });\n\n    // on blur, after a backspace, Chrome moves the start/end selection: fix it\n    let scrollLeftOnBlur = false;\n    el.addEventListener('blur', (ev) => {\n      if (el.scrollLeft) {\n        scrollLeftOnBlur = el.scrollLeft || false;\n      }\n      if (el.selectionStart !== state.start || el.selectionStart !== state.end) {\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }, true);\n    el.addEventListener('focusout', (ev) => {\n      if (scrollLeftOnBlur !== false) {\n        el.scrollLeft = scrollLeftOnBlur;\n        scrollLeftOnBlur = false;\n      }\n    }, true);\n  }());\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', (ev) => {\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case 'ArrowDown':\n    case 'Down':\n    case 'ArrowUp':\n    case 'Up':\n      ev.preventDefault();  // disable normal up/down behavior\n      return;\n\n    case ' ':\n      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n\n      // TODO: do this to prevent actually space being hit (@samthor prefers it this way)\n      //ev.preventDefault();\n      break;\n    }\n  });\n\n  // add a non-deduped keyup handler, for space on mobile browsers\n  el.addEventListener('keyup', (ev) => {\n    if (ev.keyCode === 229 || !ev.keyCode) {\n      // look for a space before whatever was entered.\n      const v = el.value.substr(el.selectionStart - 1, 1);\n      if (v === ' ' && el.dataset.prefix) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = () => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = (call) => {\n    const previousScrollLeft = el.scrollLeft;\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n\n    const update = call(value);\n    if (update == null) { return false; }\n    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n\n    const drift = (where) => {\n      if (where >= to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    const prev = document.activeElement;\n\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n    // pretend we were like this all along\n    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];\n\n    prev && prev.focus();\n\n    permitNextChange = true;\n    el.scrollLeft = previousScrollLeft;  // before setRange, so the underline is correct\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus word, if any\n  el.addEventListener('modifier', (ev) => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus((value) => modifier.modify(value, arg).out || '');\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', (ev) => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(() => emoji)) { return; }\n\n    // listen to the caller's view on what word we should pretend this emoji is\n    el.dataset['word'] = ev.detail.word || '';\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed, prefix) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    if (!prefix) {\n      all = all.filter(word => word === typed);\n    }\n    all = all.map(word => [word, ...values[word]]);\n\n    return all.length ? all : [];\n  }\n}\n","\nconst resolved = Promise.resolve();\n\n/**\n * Returns a Promise that resolves on `requestIdleCallback`.\n *\n * @return {!Promise<!IdleDeadline>}\n */\nexport function idle() {\n  return new Promise((resolve) => window.requestIdleCallback(resolve));\n}\n\n/**\n * Returns a Promise that resolves on `requestAnimationFrame`.\n *\n * @param {number=} delay whether to also delay by `setTimeout`\n * @return {!Promise<!IdleDeadline>}\n */\nexport function rAF(delay=undefined) {\n  if (delay !== undefined) {\n    return new Promise((resolve) => {\n      window.setTimeout(() => window.requestAnimationFrame(resolve), delay);\n    });\n  }\n  return new Promise((resolve) => window.requestAnimationFrame(resolve));\n}\n\n/**\n * Returns a Promise that resolves after a microtask.\n *\n * @return {!Promise<void>}\n */\nexport function microtask() {\n  const {resolver, promise} = resolver()\n  resolved.then(resolver);\n  return promise;\n}\n\n/**\n * @return {{promise: !Promise<void>, resolver: function(): void}}\n */\nexport function resolver() {\n  let resolver;\n  const promise = new Promise((resolve) => resolver = resolve);\n  return {resolver, promise};\n}\n\n/**\n * @return {!Promise<void>}\n */\nexport function delay(ms=0) {\n  return new Promise((resolve) => window.setTimeout(resolve, ms));\n}\n\nconst debouceMap = new Map();\n\n/**\n * Returns a Promise that debounces a call to the passed callable.\n *\n * @template T\n * @param {function(): T} callable\n * @param {number=} delay\n * @return {!Promise<T>}\n */\nexport function debounce(callable, delay=0) {\n  let state = debouceMap.get(callable);\n  if (!state) {\n    state = {c: callable};\n    const p = new Promise((resolve) => state.r = resolve);\n    state.p = p.then(() => {\n      debouceMap.delete(callable);\n      return state.c();\n    });\n    debouceMap.set(callable, state);\n  }\n\n  window.clearTimeout(state.t);\n  state.t = window.setTimeout(state.r, Math.max(0, delay));\n\n  return state.p;\n}","\n/**\n * Remove duplicate entries from the passed array, only from the 1th index.\n *\n * @param {!Array<string>}\n * @return {!Array<string>}\n */\nfunction removeDuplicates(row) {\n  const found = new Set();\n  return row.filter((item, i) => {\n    if (i !== 0) {\n      if (found.has(item)) { return false; }\n      found.add(item);\n    }\n    return true;\n  });\n}\n\n/**\n * Merge the given results arrays. These will both be in the form of:\n *   [[name, emoji1, emoji2,....], ...]\n *\n * The first argument will be updated with the data from the second argument.\n *\n * @param {!Array<!Array<string>>} existing\n * @param {!Array<!Array<string>>} update\n */\nexport function merge(existing, update) {\n  const lookup = {};\n  existing.forEach((row, i) => lookup[row[0]] = i);\n\n  update.forEach((row) => {\n    const index = lookup[row[0]];\n    if (index === undefined) {\n      lookup[row[0]] = existing.length;  // in case there's dup data\n      existing.push(row);\n      return;\n    }\n\n    // otherwise, just append all new data and place back into array\n    const existingRow = existing[index];\n    const updatedData = row.slice(1);\n    existing[index] = removeDuplicates(existingRow.concat(updatedData));\n  });\n}","const api = 'https://emojityper.appspot.com';\nconst recentLimit = 8;\nconst selectionDelay = 5 * 1000;\n\nimport build from './prefixgen.js';\nimport * as promises from './promises.js';\nimport * as results from './results.js';\n\n/**\n * Returns the local prefix search tool.\n *\n * @return {function(string, boolean): !Array<!Array<string>>}\n */\nconst getPrefixGen = (function() {\n  let localPromise = null;  // results from localStorage\n  const raw = window.localStorage['popular'];\n  if (raw) {\n    let out;\n    try {\n      out = JSON.parse(raw);\n    } catch (e) {\n      console.debug('couldn\\'t parse localStorage popular', e);\n      out = null;\n    }\n    if (out) {\n      localPromise = Promise.resolve(build(out['results']));\n      if (out['created'] >= (+new Date - 60 * 60 * 24 * 1000)) {\n        // return immediately, it's less than one day old\n        return () => localPromise;\n      }\n    }\n  }\n\n  // we don't have data or it's >1day old, refetch\n  const f = new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', api + '/popular');\n    xhr.onerror = reject;\n    xhr.responseType = 'json';\n    xhr.onload = () => resolve(xhr.response);\n    xhr.send();\n  }).then(raw => {\n    // IE11 doesn't respect responseType, and we always return an Object\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  });\n\n  f.then(data => {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = true;\n    data['created'] = +new Date();\n    window.localStorage['popular'] = JSON.stringify(data);\n  });\n\n  const remotePromise = f.then(v => build(v['results']));\n  if (!localPromise) {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = false;\n    return () => remotePromise;  // wait for data\n  }\n\n  // return localPromise until remotePromise is done\n  let promiseToReturn = localPromise;\n  remotePromise.then(() => promiseToReturn = remotePromise);\n  return () => promiseToReturn;\n}());\n\n/**\n * Requests emoji completion.\n *\n * @param {string} text user has typed\n * @param {boolean} prefix is this a prefix search, or is it a definite whole word?\n * @param {boolean=} more whether to return lots more results for this query\n * @return {!Promise<!Array<!Array>>}\n */\nexport function request(text, prefix, more=false) {\n  if (!text) {\n    if (more && text === '') {\n      const r = recent();\n      r.unshift('^recent');\n      const p = ['^popular']; // TODO: include popular emoji\n      return Promise.resolve([r, p]);\n    }\n\n    return Promise.resolve([]);\n  }\n\n  const localPromise = getPrefixGen().then(suggest => suggest(text, prefix));\n  if (!more) {\n    return localPromise;\n  }\n\n  // TODO: At some point, the 'more' data should go into a local cache. For now, just fetch.\n  let url = `${api}/query?query=${window.encodeURIComponent(text)}`;\n  if (prefix) {\n    url += '&prefix=true';\n  }\n  const morePromise = window.fetch(url).then(out => out.json()).then(out => out['results']);\n  return Promise.all([localPromise, morePromise]).then(both => {\n    const [local, more] = both;\n    results.merge(local, more);\n    return local;\n  });\n}\n\n/**\n * Records use of name/emoji pairs.\n *\n * @param {string} name used to select emoji\n * @param {string} emoji selected\n * @param {!Promise<!Response>} eventual response after delay\n */\nexport const select = (function() {\n  let pending = {};\n\n  const runner = () => {\n    const body = JSON.stringify(pending);\n    pending = {};  // clear pending for next time\n    return navigator.sendBeacon(api + '/select', body);\n  };\n\n  return function select(name, emoji) {\n    if (name[0] === '^') {\n      return;  // do nothing\n    }\n\n    const r = recent();\n    const index = r.indexOf(emoji);\n    if (index !== -1) {\n      r.splice(index, 1);\n    }\n    r.unshift(emoji);\n    r.splice(recentLimit);\n    window.localStorage['recent'] = r.join(',');\n    // TODO: do something with recent emoji use\n\n    pending[name] = emoji;\n    return promises.debounce(runner, selectionDelay);\n  }\n}());\n\n/**\n * Submit the name of an emoji.\n *\n * @param {string} name\n * @param {string} emoji\n * @return {!Promise<Response>}\n */\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n\n/**\n * Gets recently used emoji.\n *\n * @return {!Array<string>}\n */\nexport function recent() {\n  return (window.localStorage['recent'] || '').split(',').filter((x) => x);\n}","\n/**\n * @fileoverview Async worker.\n */\n\nimport * as promises from './promises.js';\n\nconst allowedWorkTime = 4;\nconst maximumTaskFrame = 100;\n\nexport default class Worker {\n  constructor(fn) {\n    this.fn_ = fn;\n    this.queue_ = [];\n    this.waiting_ = null;\n\n    this.runner_().catch((err) => {\n      console.info('worker runner failed', err);\n      throw err;\n    });\n  }\n\n  async runner_() {\n    await new Promise((resolve) => this.waiting_ = resolve);\n    this.waiting_ = null;\n    await promises.idle();\n\n    for (;;) {\n      if (this.chunk_()) {\n        return this.runner_();\n      }\n      await promises.rAF();\n    }\n  }\n\n  /**\n   * Completes a chunk of work.\n   *\n   * @return {boolean} Whether work is done.\n   */\n  chunk_() {\n    const start = window.performance.now();\n\n    let done = 0;\n    while (this.queue_.length) {\n      const next = this.queue_.shift();\n      next.resolve(this.fn_(next.arg));\n      ++done;\n\n      if (done == maximumTaskFrame || window.performance.now() - start > allowedWorkTime) {\n        break;\n      }\n    }\n\n    return !this.queue_.length;\n  }\n\n  task(arg) {\n    return new Promise((resolve) => {\n      this.queue_.push({resolve, arg});\n      this.waiting_ && this.waiting_();\n    });\n  }\n}\n","\n/**\n * @fileoverview The validator runs constantly and validates emoji rendering.\n */\n\nimport {isExpectedLength} from './modifier.js';\nimport Worker from './worker.js';\n\nconst prefix = '-ok_';\nconst ls = window.localStorage;\nconst known = new Map();\n\nfunction runner(emoji) {\n  const key = prefix + emoji;\n  if (ls[key]) {\n    return true;\n  }\n\n  const out = isExpectedLength(emoji);\n  known.set(emoji, out);\n  if (out) {\n    ls[key] = 't';  // use dummy small string\n  }\n  return out;\n}\n\nconst worker = new Worker(runner);\n\n/**\n * As per isExpectedLength, but caches successful results.\n *\n * @param {string} string to check\n * @return {!Promise<boolean>} whether this is probably an emoji\n */\nexport async function valid(emoji) {\n  const immediate = known.get(emoji);\n  if (immediate !== undefined) {\n    return immediate;\n  }\n  return worker.task(emoji);\n}\n","\nconst arrowKeys = ['Left', 'Right', 'Up', 'Down'];\n\n/**\n * @param {!Event} event\n * @return {?string} one of \"Arrow{Left,Right,Up,Down}\" if this is a keyboard event of that arrow\n */\nexport function arrowFromEvent(ev) {\n  if (!ev.key) {\n    return null;\n  }\n  if (ev.key.startsWith('Arrow')) {\n    return ev.key;\n  }\n  if (arrowKeys.indexOf(ev.key) === -1) {\n    return null;\n  }\n  return 'Arrow' + ev.key;\n}\n","\n/**\n * @fileoverview Emojityper's suggestion handler. Handles creation, showing etc of autocomplete\n * buttons in the UI.\n */\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\nimport {valid} from './lib/valid.js';\nimport * as promises from './lib/promises.js';\nimport * as eventlib from './lib/event.js';\nimport * as input from './input.js';\n\n/**\n * ButtonManager helps create and show emoji buttons in the UI.\n */\nclass ButtonManager {\n  constructor(holder) {\n    this.holder_ = holder;\n    this.pendingFirstEmoji_ = null;\n\n    /** @type {!Map<string, !HTMLElement>} */\n    this.options_ = new Map();\n\n    /** @type {!Map<string, !HTMLButtonElement>} */\n    this.buttons_ = new Map();\n\n    /** @type {!WeakMap<!HTMLButtonElement, !DocumentFragment>} */\n    this.buttonTarget_ = new WeakMap();\n\n    const modifierHolder = document.createElement('div');\n    this.holder_.appendChild(modifierHolder);\n\n    /** @type {function(this:ButtonManager, !Object): void} */\n    this.setModifier = (() => {\n      const genderOption = ButtonManager.optionType_('modifier', 'gender');\n      const toneOption = ButtonManager.optionType_('modifier', 'tone');\n      modifierHolder.appendChild(genderOption);\n      modifierHolder.appendChild(toneOption);\n\n      // helper to create buttons\n      const createModifierButton = (text, value=null) => {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.dataset['value'] = value;\n        return button;\n      };\n\n      // create gender options\n      const genders = [\n        createModifierButton('\\u{26AC}', ''),\n        createModifierButton('\\u{2640}', 'f'),\n        createModifierButton('\\u{2640}\\u{2642}', 'fm'),\n        createModifierButton('\\u{2642}', 'm'),\n        createModifierButton('\\u{2642}\\u{2640}', 'mf'),\n      ];\n\n      // create tone options\n      const tones = [\n        toneOption.appendChild(createModifierButton('\\u{2014}', '')),\n      ];\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        tones.push(createModifierButton(String.fromCodePoint(i), i));\n      }\n\n      // helper to add/remove\n      const updateStatus = (yes, node, owner) => {\n        yes ? owner.appendChild(node) : node.remove();\n      };\n      return function(info) {\n        const active =\n            modifierHolder.contains(document.activeElement) ? document.activeElement : null;\n        genders.forEach((node) => {\n          const l = node.dataset['value'].length;\n          const yes = (!l && info.gender.neutral)\n              || (l === 1 && info.gender.single)\n              || (l === 2 && info.gender.double);\n          updateStatus(yes, node, genderOption);\n        });\n        tones.forEach((node) => updateStatus(info.tone, node, toneOption));\n\n        // kick the elements: Safari needs this otherwise sometimes they remain hidden (!)\n        modifierHolder.insertBefore(genderOption, genderOption.nextSibling);\n        modifierHolder.insertBefore(toneOption, toneOption.nextSibling);\n\n        // refocus if one was focused\n        active && active.focus();\n      }\n    })();\n  }\n\n  static optionType_(type, value) {\n    const node = document.createElement('div');\n    node.className = 'options ' + type;\n    node.dataset[type] = value;\n    node.dataset['name'] = value;\n    return node;\n  }\n\n  optionForName_(name) {\n    const prev = this.options_.get(name);\n    if (prev) {\n      return prev;\n    }\n    const node = document.createElement('div');\n    node.className = 'options';\n    node.setAttribute('data-option', name);\n\n    if (name[0] === '^') {\n      node.classList.add('special');\n      name = name.substr(1);\n    }\n    node.setAttribute('data-name', name);  // presentation only\n    return node;\n  }\n\n  /**\n   * Creates a `button` with the textContent of the passed emoji. Starts removed from the page,\n   * but will (when valid) be placed in-order inside the specified `option`.\n   *\n   * @param {!HTMLElement} option to place inside\n   * @param {string} emoji\n   * @return {!HTMLButtonElement}\n   */\n  addEmojiTo_(option, emoji) {\n    let button = this.buttons_.get(emoji);\n    if (button) {\n      // if the button was known, check buttonTarget_: either it's the eventual placement, which\n      // we must replace, or it's a known good/bad already\n      const target = this.buttonTarget_.get(button);\n      if (target === null) {\n        return button;  // known invalid\n      } else if (target === undefined) {\n        option.appendChild(button);  // known good\n        return button;\n      }\n    } else {\n      button = document.createElement('button');\n      button.textContent = emoji;\n      this.buttons_.set(emoji, button);\n\n      valid(emoji).then((isValid) => {\n        if (!isValid) {\n          return this.buttonTarget_.set(button, null);\n        }\n\n        const node = this.buttonTarget_.get(button);\n        node.parentNode.replaceChild(button, node);\n        this.buttonTarget_.delete(button);\n\n        // TODO(samthor): call this less?\n        this.pendingFirstEmoji_ && this.pendingFirstEmoji_();\n      });\n    }\n\n    const node = document.createTextNode('');  // empty placeholder to replace\n    this.buttonTarget_.set(button, node);\n    option.appendChild(node);\n\n    return button;\n  }\n\n  /**\n   * Returns any current valid emoji for the passed option name.\n   *\n   * @param {string} name\n   * @return {?string} emoji\n   */\n  immediateFirstEmojiForOption_(name) {\n    const node = this.options_.get(name);\n    const cand = node && node.firstElementChild;\n    return cand ? cand.textContent : null;\n  }\n\n  /**\n   * Returns a promise for the first valid emoji value for the given name. This allows a user to\n   * keep typing(-ish) yet have their text replaced with emoji.\n   *\n   * This promise isn't guaranteed to resolve. Drops previous request on additional calls.\n   *\n   * @param {string} name to search for\n   * @return {!Promise<?string>} emoji found\n   */\n  firstEmojiForOption(name) {\n    return new Promise((resolve) => {\n      const checker = () => {\n        const immediateResult = this.immediateFirstEmojiForOption_(name);\n        if (!immediateResult) {\n          return false;\n        }\n        if (this.pendingFirstEmoji_ === checker) {\n          this.pendingFirstEmoji_ = null;\n        }\n        resolve(immediateResult);\n      };\n      this.pendingFirstEmoji_ = checker;\n      checker();\n    });\n  }\n\n  /**\n   * Updated displayed options with real results. These are expected the API format:\n   *    [[name,emoji,emoji,...],[name,emoji,...],...]\n   *\n   * This retains existing options if they are included in the named results.\n   *\n   * @param {!Array<!Array<string>>}\n   */\n  update(results) {\n    const options = new Map();\n    const buttons = new Map();\n    const previousActiveElement =\n        this.holder_.contains(document.activeElement) ? document.activeElement : null;\n\n    results.forEach((result) => {\n      const name = result[0];\n\n      const option = this.optionForName_(name);\n      options.set(name, option);\n      this.options_.delete(name);\n      this.holder_.appendChild(option);  // reinsert in better order\n\n      // TODO(samthor): This is a bit hacky. This saves buttons that are part of these options,\n      // even if they haven't been sent to us again in results.\n      for (let i = 0; i < option.children.length; ++i) {\n        const b = option.children[i];\n        const emoji = b.textContent;\n        if (buttons.has(emoji)) {\n          b.remove();\n          --i;\n          continue;\n        }\n        buttons.set(emoji, b);\n      }\n\n      for (let i = 1, emoji; emoji = result[i]; ++i) {\n        if (buttons.has(emoji)) {\n          continue;  // already stolen by something above us\n        }\n        // nb. addEmojiTo_ pulls old buttons from this.buttons_\n        buttons.set(emoji, this.addEmojiTo_(option, emoji));\n      }\n    });\n\n    this.options_.forEach((option) => option.remove());\n    this.options_ = options;\n    this.buttons_ = buttons;\n\n    if (previousActiveElement) {\n      if (document.body.contains(previousActiveElement)) {\n        previousActiveElement.focus();\n      } else {\n        typer.focus();  // restore to main input\n      }\n    }\n  }\n}\n\n// key overrides to recognize spacebar causing 'click'\nlet spaceFrame = 0;\nchooser.addEventListener('keyup', (ev) => {\n  if (ev.key !== ' ' || ev.target.localName !== 'button') { return; }\n  spaceFrame = window.setTimeout(() => spaceFrame = 0, 0);\n});\n\n// stores the previous user-driven l/r position\nlet previousChooserLeft = undefined;\nlet duringNavigate = false;\n\n// if a button was focused, reset chooser unless we were going u/d\nchooser.addEventListener('focus', (ev) => {\n  if (!duringNavigate) {\n    previousChooserLeft = document.activeElement.getBoundingClientRect().left;\n  }\n}, true);\n\n/**\n * Navigates through candidates until we find the best not on our current row, and focuses it.\n *\n * @param {!IArrayLike<!Node>} cands\n * @return {boolean} true if we focused something new\n */\nfunction navigateChooserButtonVertical(cands) {\n  const best = {dist: Infinity, button: null};\n\n  const previousRect = document.activeElement.getBoundingClientRect();\n  // did we have a previous explicit l/r position?\n  const left = (previousChooserLeft !== undefined ? previousChooserLeft : previousRect.left);\n\n  let targetTop = undefined;\n  for (let i = 0; i < cands.length; ++i) {\n    const button = cands[i];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    } else if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (!best.button) {\n    return false;\n  }\n  duringNavigate = true;\n  try {\n    best.button.focus();\n  } finally {\n    duringNavigate = false;\n  }\n  return true;\n}\n\nfunction copyText(text) {\n  const dummy = document.createElement('input');\n  dummy.style.position = 'fixed';\n  dummy.value = text;\n  try {\n    document.body.appendChild(dummy);\n    dummy.focus();\n    dummy.selectionStart = 0;\n    dummy.selectionEnd = dummy.value.length;\n    document.execCommand('copy');\n  } finally {\n    dummy.remove();\n  }\n}\n\n// button click handler\nchooser.addEventListener('click', (ev) => {\n  previousChooserLeft = undefined;  // used a mouse or chose something\n  const isKeyboard = (ev.screenX === 0 && ev.detail === 0);\n\n  let label = undefined;\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    if (ev.shiftKey) {\n      return;  // don't do anything\n    }\n\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n    label = 'modifier';\n  } else if (b.parentNode.dataset['option']) {\n    if (ev.shiftKey) {\n      copyText(b.textContent);\n      ga('send', 'event', 'options', 'copy');\n\n      // retain scroll position while refocusing on the suitable target\n      const scrollTop = document.scrollingElement.scrollTop;\n      isKeyboard ? b.focus() : typer.focus();\n      document.scrollingElement.scrollTop = scrollTop;\n      return;\n    }\n\n    // nb. we typically clear the word on choice (as it confuses @nickyringland), but if you hit\n    // space or ctrl-click the button, keep it around.\n    const retainWord = (spaceFrame !== 0 || ev.metaKey || ev.ctrlKey);\n    const word = retainWord ? b.parentNode.dataset['option'] : null;\n\n    const detail = {choice: b.textContent, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(b.parentNode.dataset['option'], detail.choice);\n    label = 'emoji';\n  } else {\n    // unknown\n  }\n  if (!label) { return; }\n\n  ga('send', 'event', 'options', 'click', label);\n\n  if (!isKeyboard) {\n    typer.focus();  // nb. we're actually double-refocusing\n  }\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', (ev) => {\n  if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    const typerRect = typer.getBoundingClientRect();\n    previousChooserLeft = typerRect.left + input.cursorPosition(typer);\n\n    if (navigateChooserButtonVertical(chooser.querySelectorAll('button'))) {\n      ga('send', 'event', 'options', 'keyboardnav');\n    }\n  }\n});\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', (ev) => {\n  switch (ev.key) {\n  case 'Escape':\n    typer.focus();\n    break;\n  }\n  const arrow = eventlib.arrowFromEvent(ev);\n  if (!arrow) { return; }\n\n  if (!chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (arrow === 'ArrowLeft') {\n    delta = -1;\n  } else if (arrow === 'ArrowRight') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  let cands;\n  if (arrow === 'ArrowUp') {\n    cands = buttonArray.slice(0, index);\n    cands.reverse();\n  } else if (arrow === 'ArrowDown') {\n    cands = buttonArray.slice(index);\n  } else {\n    return;\n  }\n\n  if (!navigateChooserButtonVertical(cands)) {\n    if (arrow === 'ArrowUp') {\n      typer.focus();\n    }\n  }\n  if (arrow === 'ArrowDown') {\n    // don't allow arrow scrolling unless we're within 64 pixels of the screen end\n    const focusRect = document.activeElement.getBoundingClientRect();\n    const max = focusRect.top + focusRect.height;\n    if (window.innerHeight - max > 64) {\n      ev.preventDefault();\n    }\n  }\n});\n\n(function() {\n  const longTime = 2000;\n  const delayTime = 250;\n  const manager = new ButtonManager(chooser);\n\n  let previous = {};\n  let previousQueryAt = performance.now();\n  let pendingFirstEmojiRequest = null;\n\n  // handler for a prefix search\n  typer.addEventListener('query', (ev) => {\n    // immediately inform manager of modifier buttons (gender, tone), if it's a full word search\n    const info = modifier.modify(!ev.detail.prefix && ev.detail.focus || '');\n    manager.setModifier(info);\n\n    pendingFirstEmojiRequest = null;  // user typed something else\n\n    let immediate = false;\n    const now = performance.now();\n    const query = ev.detail;\n    if (!previous.text || previous.prefix !== query.prefix) {\n      immediate = true;  // type changed, user expects snappiness\n    } else if (now - previousQueryAt > longTime) {\n      immediate = true;  // it's been a while\n    }\n    previous = query;\n    previousQueryAt = now;\n\n    const request = async (timeout=0, more=false) => {\n      if (timeout) {\n        await promises.rAF(timeout);\n        if (previous !== query) { return -1; }\n      }\n      const results = await provider.request(query.text, query.prefix, more);\n      if (previous !== query) { return -1; }\n\n      // TODO: rather than discarding, can we work out whether this is something we can _filter_\n      // to _look_ like the real results?\n      // nb. we'd have to say... this is \"old\" but the final one hasn't finished.\n\n      return manager.update(results);\n    };\n\n    const p = request(immediate ? 0 : delayTime).then((valid) => {\n      if (valid < 0) { return -2; }  // query changed\n\n      // TODO: the 'more' behaviour interacts oddly with pendingFirstEmojiRequest, as it can appear\n      // as if your emoji changes after a _long_ time.\n\n      if (!query.text) {\n        // TODO: delay empty data by a decent time\n        return request(1500, true);\n      }\n\n      const timeout = Math.max(1000, 100 * Math.pow(valid, 0.75));\n      return request(timeout, true);\n    }).catch((err) => {\n      console.error('error doing request', err);\n    });\n  });\n\n  // nb. this punctuation list is just misc stuff needed by emojimap\n  const invalidLetterRe = /[^\\w:\\.,$%^\\-']+/g;\n  const simplifyWord = (word) => word.replace(invalidLetterRe, '').toLowerCase();\n\n  // request an autocomplete, the user has just kept typing\n  typer.addEventListener('request', (ev) => {\n    const word = simplifyWord(ev.detail || '');\n    const request = manager.firstEmojiForOption(word);\n    pendingFirstEmojiRequest = request;\n    request.then((choice) => {\n      if (pendingFirstEmojiRequest !== request) { return; }\n\n      ga('send', 'event', 'options', 'typing');\n      const detail = {choice, word};\n      typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    });\n  });\n}());\n","\nimport * as provider from './lib/provider.js';\nimport * as promises from './lib/promises.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let value = '';\n  let pending = null;\n\n  input.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined && query.selection);\n    value = query.focus;\n    if (!selection) {\n      if (!pending) {\n        namer.value = '';  // clear on done if not pending\n        advanced.hidden = true;\n      }\n      return false;\n    }\n    // TODO: round trip to confirm validity of emoji?\n    advanced.hidden = false;\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', (ev) => {\n    ev.preventDefault();\n    if (pending) {\n      return false;  // can't submit while running\n    }\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n\n      pending = null;\n      if (!value) {\n        advanced.hidden = true;\n      }\n    };\n\n    pending = provider.submit(namer.value, value).then((response) => {\n      if (!response.ok) {\n        throw new Error(response.status);\n      }\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err);\n      return true;\n    }).then(cleanup);\n\n    pending.then(() => promises.delay(2000)).then(() => {\n      button.className = '';\n    });\n  });\n}(typer, advanced));\n","\n/**\n * @fileoverview Controls the size and `has-value` class of the body itself based on current input.\n */\n\nconst value = (ev) => {\n  const text = ev.detail.trim();\n  document.body.classList.toggle('has-value', Boolean(text));\n};\ntyper.addEventListener('value', value);\nvalue({detail: typer.value});\n\n// set minHeight to actual viewport height, but allow for keyboard etc\nconst resize = (ev) => {\n  const height = window.innerHeight;\n  document.body.style.minHeight = `${height}px`;\n};\nwindow.addEventListener('resize', resize);\nwindow.addEventListener('load', resize);\nresize();\n\n\nlet deferredPrompt = null;\n\nfunction cleanupPrompt() {\n  document.body.classList.remove('has-install');\n  deferredPrompt = null;\n}\n\nwindow.addEventListener('beforeinstallprompt', (ev) => {\n  ga('send', 'event', 'install', 'available');\n  document.body.classList.add('has-install');\n  deferredPrompt = ev;\n  ev.preventDefault();\n  return false;\n});\n\nwindow.addEventListener('appinstalled', (ev) => {\n  ga('send', 'event', 'install', 'installed');\n  cleanupPrompt();\n});\n\nconst installEl = document.getElementById('install');\ninstallEl.addEventListener('click', (ev) => {\n  if (!deferredPrompt) {\n    return;\n  }\n  deferredPrompt.prompt();\n\n  if (!deferredPrompt.userChoice) {\n    return;  // older Chrome\n  }\n\n  deferredPrompt.userChoice.then((result) => {\n    ga('send', 'event', 'install', result);\n    // TODO: should we listen to appinstalled? I suppose we don't know what the user said.\n  }).catch((err) => {\n    console.warn('beforeinstallprompt prompt', err);\n  }).then(cleanupPrompt);\n});\n","\n/**\n * @fileoverview Rotates through various advertisements in Emojityper.\n */\n\nconst adverts = document.getElementById('adverts');\n\nfunction refresh() {\n  const active = adverts.querySelector('.active');\n  const next = (active && active.nextElementSibling || adverts.firstElementChild);\n  if (!next) {\n    console.warn('no adverts to choose from');\n    return;\n  }\n\n  active && active.classList.remove('active');\n  next.classList.add('active');\n\n  enqueue();\n}\n\nlet timeout;\nfunction enqueue() {\n  window.clearTimeout(timeout);\n  timeout = window.setTimeout(() => {\n    window.requestAnimationFrame(refresh);\n  }, 10 * 1000);\n}\n\nenqueue();\n","\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('./sw.js').catch((err) => {\n    console.warn('failed to register SW', err);\n  });\n\n  navigator.serviceWorker.addEventListener('controllerchange', () => {\n    if (!navigator.serviceWorker.controller) {\n      // only reload if we already had a SW\n      console.info('got SW controllerchange, reload');\n      window.location.reload();\n    }\n  });\n}\n","\nimport {debounce} from './lib/promises.js';\n\nlet prevOnLine = true;\n\nfunction notifyStatus() {\n  if ('onLine' in navigator && prevOnLine !== navigator.onLine) {\n    ga('send', 'event', 'network', navigator.onLine ? 'online' : 'offline');\n    prevOnLine = navigator.onLine;\n  }\n}\n\nnotifyStatus();\nwindow.addEventListener('online', () => debounce(notifyStatus));\nwindow.addEventListener('offline', () => debounce(notifyStatus));\n"]}