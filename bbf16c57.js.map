{"version":3,"file":"bbf16c57.js","sources":["src/polyfill.js","src/loader.js","src/lib/event.js","src/lib/copier.js","src/buttons.js","node_modules/ok-emoji/src/string.js","node_modules/ok-emoji/src/emoji.js","node_modules/ok-emoji/src/measurer.js","src/lib/modifier.js","src/lib/cache.js","src/lib/word.js","src/input.js","src/lib/worker.js","src/lib/valid.js","src/options.js","src/page.js","src/sw.js","src/entrypoint/main.js"],"sourcesContent":["\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nexport const requestIdleCallback = !window.requestIdleCallback;  // is polyfill needed?\nif (requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = (callback) => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\nexport const sendBeacon = !navigator.sendBeacon;  // is polyfill needed?\nif (sendBeacon) {\n  navigator.sendBeacon = function(url, body) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    xhr.send(body);\n  };\n}\n","import {sendBeacon} from './polyfill.js';\n\n// defer extra scripts until after 'load' event\nwindow.addEventListener('load', (ev) => {\n  if (window.parent && window.parent !== window) {\n    window.parent.postMessage('load', '*');\n  }\n\n  window.requestAnimationFrame(() => {\n    const scriptPWACompat = document.createElement('script');\n    document.head.appendChild(scriptPWACompat);\n    scriptPWACompat.outerHTML = `\n<script\nsrc=\"https://cdn.jsdelivr.net/npm/pwacompat@2.0.8/pwacompat.min.js\"\nintegrity=\"sha384-uONtBTCBzHKF84F6XvyC8S0gL8HTkAPeCyBNvfLfsqHh+Kd6s/kaS4BdmNQ5ktp1\"\ncrossorigin=\"anonymous\">\n</script>`;\n\n    if (!document.currentScript) {\n      // absence indicates we're in module mode, so load extended code\n      const scriptExtended = document.createElement('script');\n      scriptExtended.src = document.body.getAttribute('data-ext');\n      scriptExtended.type = 'module';\n      document.head.appendChild(scriptExtended);\n    }\n\n    if (window._dev) {\n      return;  // don't analytics in dev\n    }\n\n    const scriptAnalytics = document.createElement('script');\n    scriptAnalytics.src = 'https://www.google-analytics.com/analytics.js';\n    document.head.appendChild(scriptAnalytics);\n  });\n});\n\n// create local GA, this matches the 'isogram' code\nconst tempGA = function() {\n  tempGA['q'].push(arguments);\n};\ntempGA['q'] = [];\ntempGA['l'] = 1 * new Date;\nwindow['ga'] = tempGA;\nwindow['GoogleAnalyticsObject'] = 'ga';\n\nwindow.addEventListener('message', (ev) => {\n  const type = ev.data.type || '';\n  switch (type) {\n    case 'ga':\n      // used by extension to log load time\n      ga.apply(null, ev.data.payload);\n      break;\n    default:\n      console.debug('unhandled message', ev.data);\n  }\n});\n\n// enqueue initial GA events\nsendBeacon || ga('set', 'transport', 'beacon');\nga('create', 'UA-39885839-6', 'auto');\nga('send', 'pageview');","\nconst arrowKeys = ['Left', 'Right', 'Up', 'Down'];\n\n/**\n * @param {!Event} ev\n * @return {?string} one of \"Arrow{Left,Right,Up,Down}\" if this is a keyboard event of that arrow\n */\nexport function arrowFromEvent(ev) {\n  if (!ev.key) {\n    return null;\n  }\n  if (ev.key.startsWith('Arrow')) {\n    return ev.key;\n  }\n  if (arrowKeys.indexOf(ev.key) === -1) {\n    return null;\n  }\n  return 'Arrow' + ev.key;\n}\n\n/**\n * @param {!Event} ev\n * @return {boolean} whether this is probably a keyboard/non-mouse click\n */\nexport function isKeyboardClick(ev) {\n  if (!(ev instanceof MouseEvent)) {\n    return true;\n  }\n  return (ev.screenX === 0 && ev.detail === 0) || ev.webkitForce === 0;\n}","\nlet dummy;\n\nexport function copyText(text) {\n  if (!dummy) {\n    dummy = document.createElement('input');\n    dummy.style.position = 'fixed';\n    dummy.style.opacity = 0;\n    document.body.appendChild(dummy);\n  }\n\n  dummy.value = text;\n  try {\n    dummy.hidden = false;\n    dummy.focus();\n    dummy.selectionStart = 0;\n    dummy.selectionEnd = dummy.value.length;\n    document.execCommand('copy');\n  } catch (e) {\n    return false;\n  } finally {\n    dummy.hidden = true;\n  }\n\n  return true;\n}","\n/**\n * @fileoverview Handles the buttons in the top-right of the page (currently just Copy).\n */\n\nimport * as eventlib from './lib/event.js';\nimport * as copier from './lib/copier.js';\n\nconst all = Array.from(input.querySelectorAll('button'));\n\nconst handler = (ev) => {\n  const text = ev.detail.trim();\n  const hasValue = Boolean(text);\n  all.forEach((button) => button.disabled = !hasValue);\n};\ntyper.addEventListener('value', handler);\nhandler({detail: typer.value});\n\nconst buttonTextShow = 500;\n\nfunction notifyParentCopy() {\n  // notify parent (for ext)\n  if (window.parent) {\n    window.parent.postMessage('copy', '*');\n  }\n}\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = () => {\n    const text = input.dataset['copy'].trim().replace(/\\s+/, ' ');\n    if (!copier.copyText(text)) {\n      console.warn('could not copy', text)\n      return true;\n    }\n    console.info('copied', text);\n\n    // analytics\n    ga('send', 'event', 'text', 'copy');\n\n    // show 'Copied!' message\n    button.textContent = button.dataset['copied'];\n    button.classList.add('copied');\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout((ev) => {\n      button.textContent = defaultText;\n      button.classList.remove('copied');\n      maybeReleaseInputEnter();\n      notifyParentCopy();\n    }, buttonTextShow);\n  };\n\n  let wasInputEnter = false;\n  input.addEventListener('keydown', (ev) => {\n    if (wasInputEnter) {\n      // do nothing, enter is being _held_\n    } else if (ev.key === 'Enter' && !ev.repeat) {\n      button.click();\n      button.focus();\n      wasInputEnter = true;\n      ev.preventDefault();\n    }\n  });\n  document.body.addEventListener('keyup', (ev) => {\n    if (ev.key === 'Enter') {\n      maybeReleaseInputEnter();\n    }\n  });\n  button.addEventListener('click', (ev) => {\n    ev.preventDefault();\n    if (wasInputEnter || ev.repeat) {\n      return;  // click is generated as the user holds enter\n    }\n    copy();\n    if (eventlib.isKeyboardClick(ev)) {\n      // if the user tabbed here, keep focus\n      button.focus();\n    }\n  });\n\n  function maybeReleaseInputEnter() {\n    if (wasInputEnter) {\n      if (document.activeElement === button) {\n        input.focus();  // maybe focus moved\n      }\n      wasInputEnter = false;\n    }\n  }\n\n}(copy, typer));\n\n","\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nexport function jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n","\nimport {jsdecode} from './string.js';\n\nexport const runeZWJ = 0x200d;\nexport const runeCap = 0x20e3;\nexport const runeVS16 = 0xfe0f;\nexport const runeTagCancel = 0xe007f;\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nexport function isSkinTone(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nexport function isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a tag character, for tag sequences\n */\nexport function isTag(p) {\n\treturn p >= 0xe0020 && p < 0xe007f\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune can appear before a keycap\n */\nexport function isBeforeCap(p) {\n  return p === 35 || p === 42 || (p >= 48 && p <= 57)  // #, * or 0-9\n}\n\n/**\n * @type {!Array<number>}\n */\nconst skippable = [runeVS16, runeCap, runeTagCancel];\n\n/**\n * Returns a count of the expected number of points displayed for the given valid emoji string.\n *\n * Assumes the emoji is normalized/well-formed: if not, the result will likely just be lower than\n * rendered, and it'll be considered invalid anyway.\n *\n * @param {string} s\n * @return {number} count\n */\nexport function emojiPointCount(s) {\n  const points = jsdecode(s);\n  return _emojiPointCount(points);\n}\n\n/**\n * @param {!Array<number>} points\n * @return {number} count\n */\nexport function _emojiPointCount(points) {\n  let halfCount = 0;\n  const l = points.length;\n  for (let i = 0; i < l; ++i) {\n    const p = points[i];\n    if (p === runeZWJ) {\n      halfCount -= 2;\n    } else if (skippable.indexOf(p) !== -1 || isTag(p) || isSkinTone(p)) {\n      // do nothing\n    } else if (isFlagPoint(p) && points[i+1] !== runeVS16) {\n      ++halfCount;\n    } else {\n      halfCount += 2;\n    }\n  }\n\n  if (points.length === 0) {\n    return 0;  // no points\n  } else if (halfCount <= 2) {\n    return 1;  // return minimum if string had content\n  } else {\n    return (halfCount + 1) >> 1;  // round up\n  }\n}\n\n/**\n * @param {string} s\n * @yield {?Array<number>}\n */\nexport function *iterateEmoji(s) {\n  const points = jsdecode(s);\n  yield *_iterateEmoji(points);\n}\n\n/**\n * @param {!Array<number>} points\n * @yield {?Array<number>}\n */\nexport function *_iterateEmoji(points) {\n  let curr = {flag: false, v: []};\n  const pending = [curr];\n\n  const ensure = (flag) => {\n    if (curr.flag !== flag) {\n      curr = {flag, v: []};\n      pending.push(curr);\n    }\n  };\n\n  const l = points.length;\n  for (let i = 0; i < l; ++i) {\n    const p = points[i];\n\n    if (isFlagPoint(p) && points[i+1] !== runeVS16) {\n      ensure(true);  // force flag mode\n      curr.v.push(p);\n    } else if (skippable.indexOf(p) !== -1 || isTag(p) || isSkinTone(p) || p === runeZWJ) {\n      ensure(false);  // force regular mode\n      curr.v.push(p);\n    } else {\n      // ensure new char unless we follow a ZWJ\n      const off = curr.v.length - 1;\n      if (off !== -1 && curr.v[off] !== runeZWJ) {\n        curr = {flag: false, v: [p]};\n        pending.push(curr);\n      } else {\n        curr.v.push(p);\n      }\n    }\n\n    while (pending.length > 1) {\n      const cand = pending.shift();\n      if (cand.v.length) {\n        yield cand.v;\n      }\n    }\n  }\n\n  const tail = pending[0];\n  if (tail.v.length) {\n    yield tail.v;\n  }\n}\n\n/**\n * Stringifies the given emoji char. By default, generates e.g. \"1f575_fe0f_200d_2642\" or \"23_20e3\".\n *\n * @param {string} s\n * @param {{sep: string, pad: number, lower: boolean, unqualify: boolean}=} opts\n * @return {string}\n */\nexport function stringify(s, opts={}) {\n  const points = jsdecode(s);\n  return _stringify(points, opts);\n}\n\n/**\n * @param {!Array<number>} points\n * @param {{sep: string, pad: number, lower: boolean, unqualify: boolean}=} opts\n * @return {string}\n */\nexport function _stringify(points, opts = {}) {\n  const def = {sep: '_', pad: 0, lower: true, unqualify: true};\n  const {sep, pad, lower, unqualify} = Object.assign(def, opts);\n  if (unqualify) {\n    points = points.filter((part) => part !== runeVS16);\n  }\n  const parts = points.map((point) => {\n    let part = point.toString(16);\n    if (!lower) {\n      part = part.toUpperCase();\n    }\n    return '0'.repeat(Math.max(0, pad - part.length)) + part;\n  });\n  return parts.join(sep);\n}","\nimport {emojiPointCount, _emojiPointCount, _iterateEmoji, isFlagPoint, runeVS16} from './emoji.js';\nimport {jsdecode} from './string.js';\n\n// are we on a platform where emoji are all fixed width? This enables our fast-path.\nconst fixedWidthEmoji =\n    Boolean(/Mac|iP(hone|od|ad)/.exec(navigator.platform)) ||  // Mac and iOS\n    Boolean(/Android/.exec(navigator.userAgent))           ||  // Android\n    false;\n\n// on Windows, the initial Man or Woman of an emoji sequence gets a space after it\n// ...well, Edge struggles with couples/family, Chrome is _just_ couples\nconst needsManWomanHack = Boolean(/Win/.exec(navigator.platform));\n\nconst letterSpacing = 1024;  // must be sensibly large enough so we round over emoji\nconst fontSize = 100;        // large enough to unambiguate other wide chars\n\nconst hider = document.createElement('div');\nhider.style.overflow = 'hidden';\nhider.style.width = '0px';\nhider.style.position = 'absolute';\nhider.setAttribute('href', 'https://github.com/samthor/ok-emoji');\n\nconst measurer = document.createElement('div');\nmeasurer.style.display = 'inline-block';\nmeasurer.style.whiteSpace = 'nowrap';\nmeasurer.style.fontSize = `${fontSize}px`;\nmeasurer.style.lineHeight = 'normal';\nmeasurer.style.fontFamily = 'sans-serif';\n\nhider.appendChild(measurer);\ndocument.body.appendChild(hider);\n\n/**\n * @return {{width: number, height: number}}\n */\nfunction measure() {\n  // use the height of the hider, as it grows to expand 'large' chars (the measurer itself doesn't)\n  // grow, it just renders 'outside'\n  const box = hider.getBoundingClientRect();\n  return {width: measurer.offsetWidth, height: hider.offsetHeight};\n}\n\n// render a char that will show up as an invalid Unicode square box\nmeasurer.textContent = '\\u{ffffd}';\nconst invalidBoxSize = measure();\n\n// render an emoji\nmeasurer.textContent = '\\u{1f602}';\nconst validEmojiSize = measure();\n\n// check invalid vs emoji\nexport const isSingleAmbig = (validEmojiSize.height === invalidBoxSize.height) && !fixedWidthEmoji;\nif (isSingleAmbig) {\n  // This is somewhat unlikely, but possible. In this case, we can't tell single characters from\n  // emoji, because everything has the same height.\n  // console.warn(`unable to tell single char from emoji char`);\n}\n// _now_ set letterSpacing for rest\nmeasurer.style.letterSpacing = `${letterSpacing}px`;\n\n/**\n * @type {(null|function(string): number)}\n */\nconst fixedWidthMeasure = (function() {\n  if (!fixedWidthEmoji) {\n    return null;\n  }\n\n  // nb. The choice of canvasFontSize leverages weird Mac quirks. Using e.g. 1 or 100 doesn't\n  // work; 10.5 seems to work well, because other fixed-width single-chars are different size.\n  // Ostensibly, emoji don't like to render on pixel widths, and on macOS 10.13 it rounds up to 14.\n  const canvasFontSize = 10.5;\n\n  const canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));\n  const context = /** @type {!CanvasRenderingContext2D} */ (canvas.getContext('2d'));\n  context.font = `${canvasFontSize}px monospace`;\n  const expectedWidth = context.measureText('\\u{1f602}').width;  // fixed width of emoji\n\n  return function fixedWidthMeasure(s) {\n    const width = context.measureText(s).width;\n    return width / expectedWidth;\n  }\n}());\n\n/**\n * @param {string} s to measure\n * @return {number} the number (approx) of characters rendered\n */\nexport function countRenderPoints(s) {\n  measurer.textContent = s;\n  return Math.round(measurer.offsetWidth / (letterSpacing + fontSize));\n}\n\n/**\n * @param {string} s to examine\n * @return {number} the number of extra rendered chars to allow\n */\nconst countExtraAllowed = (function() {\n  if (!needsManWomanHack) {\n    return () => 0;\n  }\n\n  return (s) => {\n    let extra = 0;\n    let index = -1;\n    for (;;) {\n      index = s.indexOf('\\u{200d}\\u{d83d}', index+1);  // ZWJ plus first byte of person (man/woman)\n      if (index === -1) {\n        break;\n      }\n      const cand = s.charCodeAt(index+2);\n      if (cand === 56424 || cand === 56425) {\n        ++extra;\n      }\n    }\n    return extra;\n  }\n}());\n\n/**\n * @param {string} s\n * @return {boolean} whether this is a single valid emoji (width is single, and not an invalid box)\n */\nexport const isSingleValidEmoji = (function() {\n  if (fixedWidthEmoji) {\n    return function isSingleValidEmoji(s) {\n      return fixedWidthMeasure(s) === 1;\n    };\n  }\n\n  return function isSingleValidEmoji(s) {\n    measurer.textContent = s;\n    const rect = measure();\n\n    const expected = 1 + countExtraAllowed(s);\n    const len = Math.round(rect.width / (letterSpacing + fontSize));\n    if (len > expected) {\n      return false;  // expected single char\n    } else if (validEmojiSize.height !== rect.height) {\n      // nb. This isn't perfect, it's very plausible that there are some random Unicode points\n      // that on the user's system which have the same height as the emoji itself.\n      return false;  // not emoji height\n    }\n    return invalidBoxSize.width !== rect.width - letterSpacing;\n  }\n}());\n\n/**\n * @param {string} s\n * @return {boolean} whether this is the expected length of an emoji-only string\n */\nexport const isExpectedLength = (function() {\n  if (fixedWidthEmoji) {\n    return function isExpectedLength(s) {\n      const actual = fixedWidthMeasure(s);\n      const expected = emojiPointCount(s);\n      if (~~actual !== actual) {\n        return false;  // must be whole emoji chars\n      }\n      return actual <= expected;\n    };\n  }\n\n  // isExpectedLength implementation for variable width environments (anywhere but Apple or\n  // Android). Windows, Linux and others render emoji with variable width. But all platforms render\n  // emoji with fixed height.\n  // TODO: If we're wrong then remove the height checks.\n  return function isExpectedLength(s) {\n    measurer.textContent = s;\n    if (hider.offsetHeight !== validEmojiSize.height) {\n      return false;  // early out, text doesn't have emoji height\n    }\n\n    const points = jsdecode(s);\n    const expected = _emojiPointCount(points) + countExtraAllowed(s);\n    const renderPoints = countRenderPoints(s);\n    if (renderPoints > expected) {\n      return false;  // early out, catches uncombinables\n    }\n\n    // iterate through emoji parts, check all of them for validity\n    for (const part of _iterateEmoji(points)) {\n      if (part === null) {\n        return false;  // got invalid part\n      }\n\n      // special-case flags, which we get in bulk\n      if (isFlagPoint(part[0])) {\n        if (part[1] === runeVS16) {\n          continue;\n        } else if (part.length % 2) {\n          return false;  // flags must be pairs\n        }\n        for (let i = 0; i < part.length; i += 2) {\n          const text = String.fromCodePoint(part[i], part[i+1]);\n          if (!isSingleValidEmoji(text)) {\n            return false;\n          }\n        }\n        continue;\n      }\n\n      // check is single char\n      const text = String.fromCodePoint(...part);\n      if (!isSingleValidEmoji(text)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n","\nimport {cacheFor} from './cache.js';\nimport {jsdecode} from '../../node_modules/ok-emoji/src/string.js';\nimport {isSingleValidEmoji} from '../../node_modules/ok-emoji/src/measurer.js';\nimport * as emoji from '../../node_modules/ok-emoji/src/emoji.js';\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single emoji long\n */\nconst isSingle = cacheFor(isSingleValidEmoji);\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = isSingle('\\u{1f468}\\u{1f3fb}');\n\n/**\n * @type {!Array<number>}\n */\nconst skipDiversityList = [\n  0x1f91d,  // handshake\n  0x1f46a,  // nuclear family\n  0x1f93c,  // people wrestling\n  0x1f46b,  // m+w hands\n  0x1f46c,  // m+m hands\n  0x1f46d,  // w+w hands\n];\n\n/**\n * @param {number} p\n * @return {boolean} whether to skip diversity for this point\n */\nfunction skipDiversity(p) {\n  return skipDiversityList.indexOf(p) !== -1;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emoji which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  const list = [\n    0x1f468, 0x1f469, 0,        // man, woman (normal case)\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0x1f9d2,  // girl, boy, child\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0x1f46b,  // women/men holding hands; note this has 'mixed' for neutral\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return (point) => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single =\n          isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n ? isSingle(String.fromCodePoint(out.points.n)) : false;\n    }\n    return out;\n  };\n}());\n\n/**\n * @param {!Array<number>} points\n * @yields {{part: !Array<number>, trailer: boolean}}\n */\nfunction *reverseParts(points) {\n  let last = -1;\n\n  // nb. this actually works in reverse\n  do {\n    // ugh so many off by ones\n    const index = points.lastIndexOf(emoji.runeZWJ, last);\n    const from = index + 1;\n    const to = (last === -1 ? points.length : last + 1);\n    last = index - 1;\n\n    const part = points.slice(from, to);\n    if (part.length === 0) {\n      continue;  // ignore empty char\n    }\n\n    const x = {part: points.slice(from, to), trailer: from !== 0};\n    yield x;\n  } while (last !== -2);\n}\n\n/**\n * @param {!Array<number>} points\n * @return {!Array<!Array<number>>}\n */\nfunction splitPoints(points) {\n  let last = 0;\n  const out = [];\n\n  for (;;) {\n    const index = points.indexOf(emoji.runeZWJ, last);\n    const to = (index === -1 ? points.length : index);\n\n    const part = points.slice(last, to);\n    if (part.length !== 0) {\n      out.push(part);\n    }\n\n    if (index === -1) {\n      break;\n    }\n    last = index + 1;\n  }\n\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), due to the cost of measuring every individual character on some platforms.\n *\n * @param {string} s\n * @param {{tone: (undefined|number), gender: (undefined|string)}=} op\n * @return {\n *   out: (string|undefined),\n *   tone: boolean,\n *   gender: {single: boolean, double: boolean, neutral: boolean},\n * }\n */\nexport function modify(s, op=undefined) {\n  const stats = {tone: false, gender: {single: false, double: false, neutral: false}};\n\n  const all = op !== undefined ? [] : null;\nouter:\n  for (const points of emoji.iterateEmoji(s)) {\n    if (all) {\n      all.push(points);  // store for 2nd round\n    }\n\n    let genderable = 0;\n    let familyLike = false;\n\n    for (const {part, trailer} of reverseParts(points)) {\n      // check for early exhaustive answer\n      if (op === undefined &&\n        (stats.tone || !basicDiversity) &&\n        stats.gender.neutral && stats.gender.single && stats.gender.double) {\n        break outer;\n      }\n\n      const first = part[0];\n\n      if (emoji.isFlagPoint(first)) {\n        continue;\n      }\n\n      const localFamilyMember = isFamilyMember(first)\n      if (trailer && localFamilyMember) {\n        familyLike = true;   // familyLike is family member in later part of char\n      }\n\n      const localPersonGender = isPersonGender(first)\n      if (localFamilyMember || localPersonGender) {\n        stats.tone = !familyLike && basicDiversity;\n        stats.gender.single = true;\n        if (localPersonGender && ++genderable >= 2) {\n          stats.gender.double = true;\n        }\n        continue;  // nothing more to find out here\n      }\n\n      if (familyLike) {\n        continue;  // no more checks to do\n      }\n\n      // check for prescribed gender flips\n      const flip = genderFlip(first);\n      if (flip !== null) {\n        stats.gender.single |= flip.single;\n        stats.gender.neutral |= flip.neutral;\n      }\n\n      // measure if diversity is possible (only on first char)\n      if (basicDiversity && !stats.tone && !trailer && !skipDiversity(first)) {\n        const cand = String.fromCodePoint(first, 0x1f3fb);\n        stats.tone = isSingle(cand);\n      }\n\n      // measure if gender is possible\n      if (!stats.gender.neutral) {\n        const cand = String.fromCodePoint(first, emoji.runeZWJ, 0x2640, emoji.runeVS16);\n        const valid = isSingle(cand);\n        stats.gender.neutral = valid;\n        stats.gender.single = stats.gender.single || valid;\n      }\n    }\n  }\n\n  if (op === undefined) {\n    return stats;\n  }\n\n  if (op.tone !== undefined && stats.tone) {\n    // nb. tones are only ever valid in position 1\n    all.forEach((points) => {\n      if (emoji.isSkinTone(points[1])) {\n        // found one, either replace or clear\n        if (op.tone) {\n          // great, save in place\n          points[1] = op.tone;\n        } else {\n          const cand = String.fromCodePoint(points[0]);\n          if (!isSingle(cand)) {\n            points[1] = emoji.runeVS16;  // tone was holding this as emoji\n          } else {\n            points.splice(1, 1);  // just remove\n          }\n        }\n        return;  // in-place update\n      }\n\n      if (!op.tone) {\n        // just remove in case one's in a weird place\n        const update = points.filter((point) => !emoji.isSkinTone(point));\n        points.splice(0, points.length, ...update);\n        return;  // in-place update\n      }\n\n      if (skipDiversity(points[0])) {\n        return;  // skip\n      }\n\n      const cand = String.fromCodePoint(points[0], op.tone, ...points.slice(1));\n      if (!isSingle(cand)) {\n        return;\n      }\n      points.splice(1, 0, op.tone);\n    });\n  }\n\n  if (op.gender !== undefined) {\n    const splitAll = all.map((points) => splitPoints(points));\n    const updateSplitAll = splitAll.map((parts, i) => {\n      // check last point first\n      const hadTrailingGender = isPointGender(parts[parts.length - 1][0]);\n\n      // look for gendered emoji at start of all and flip\n      if (!hadTrailingGender) {\n        let localOp = [];\n        let foundAny = false;\n        for (let i = 0; i < parts.length; ++i) {\n          const part = parts[i];\n          const first = part[0];\n\n          const flip = genderFlip(first);\n          if (!flip) {\n            if (i === 0) {\n              break;  // genderable will always be first, give up\n            }\n            continue;\n          }\n\n          // if we're out of ops, split for more (this might still be blank, but reset anyway)\n          localOp = localOp.length ? localOp : op.gender.split('');\n          const next = localOp.shift();\n          if (foundAny && (!next || isFamilyMember(first))) {\n            break;  // if we've already matched some, and now have no more data / is family, fail\n          }\n\n          if (!next && flip.neutral) {\n            part[0] = flip.points.n;\n          } else if (next && flip.single) {\n            part[0] = (next === 'm' ? flip.points.m : flip.points.f);\n          }\n          foundAny = true;\n        }\n        if (foundAny) {\n          return parts;  // don't try to add a gender modifier\n        }\n\n        // now, either change trailing gender or try to add one\n        if (!op.gender) {\n          return null;  // nothing to do\n        }\n\n        // we need to see if it's possible, clone _whole_ emoji\n        const run = all[i].slice();\n        run.push(emoji.runeZWJ, 0x2640, emoji.runeVS16);\n        const cand = String.fromCodePoint(...run);\n        if (!isSingle(cand)) {\n          return null;\n        }\n        parts.push([0x2640, emoji.runeVS16]);  // we change this below\n      } else if (!op.gender) {\n        parts.pop();\n        return parts;\n      }\n\n      const last = parts[parts.length - 1];\n      last[0] = (op.gender[0] === 'm' ? 0x2642 : 0x2640);\n      return parts;\n    });\n\n    // remerge changed parts\n    updateSplitAll.forEach((parts, i) => {\n      if (parts === null) {\n        return;  // nothing changed here\n      }\n      const merged = [];\n      parts.forEach((part) => {\n        merged.push(...part, emoji.runeZWJ);\n      });\n      merged.pop();  // remove trailing ZWJ\n      all[i] = merged;\n    });\n  }\n\n  stats.out = all.map((points) => String.fromCodePoint(...points)).join('');\n  return stats;\n}\n","\nexport function cacheFor(fn, limit=4000) {\n  let cache = {};\n  let count = 0;\n\n  return (arg) => {\n    let result = cache[arg];\n    if (result === undefined) {\n      cache[arg] = result = fn(arg);\n      if (++count > limit) {\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}","\nimport * as emoji from '../../node_modules/ok-emoji/src/emoji.js';\n\n// TODO(samthor): Just use this on supported browsers.\n// const re = new RegExp(/(?:[\\p{Letter}\\p{Number}])/u);\n\nfunction letterAt(text, pos) {\n  const code = text.charCodeAt(pos);\n  const after = text.charCodeAt(pos + 1);\n\n  if (after === emoji.runeVS16) {\n    return false;  // VS16 follows\n  }\n\n  // return Boolean(re.exec(text.substr(pos, 1)));\n  return code < 5000 && code > 32;\n}\n\nexport function match(text, at) {\n  let from = at;\n  let to = at;\n\n  // are we at the end (only have spaces until end)?\n  const isAtEnd = text.substr(at).trim() === '';\n  const isNotWordAfter = isAtEnd || !letterAt(text, at);\n\n  if (isNotWordAfter) {\n    for (; to > 0; --to) {\n      if (text.charCodeAt(to - 1) > 32) {\n        break;\n      }\n    }\n    if (to < from) {\n      from = to;\n    }\n  }\n\n  // walk backwards while the previous character is a word\n  for (; from > 0; --from) {\n    if (!letterAt(text, from - 1)) {\n      break;\n    }\n  }\n\n  // walk forwards while the next char is not a space\n  for (; to < text.length; ++to) {\n    if (!letterAt(text, to)) {\n      break;\n    }\n  }\n\n  if (from > to) {\n    from = to;\n  }\n  return {from, to};\n}","\nimport * as modifier from './lib/modifier.js';\nimport * as word from './lib/word.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach((key) => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\nconst upgraded = new WeakMap();\n\nexport function cursorPosition(el) {\n  const fn = upgraded.get(el);\n  if (fn !== undefined) {\n    return fn();\n  }\n  return undefined;\n}\n\n// word focus handler\nfunction upgrade(el) {\n  if (upgraded.has(el)) {\n    return false;\n  }\n\n  // stores the faux-selection shown (different from actual selection in 'state')\n  const sel = {\n    from: el.selectionStart,\n    to: el.selectionEnd,\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  let suggest = null;\n  const autocomplete = document.createElement('div');\n  autocomplete.className = 'autocomplete sizer';\n  helper.appendChild(autocomplete);\n\n  // measures the width of text\n  const measureText = (function() {\n    const sizer = document.createElement('div');\n    sizer.className = 'sizer';\n    helper.appendChild(sizer);\n\n    const nonce = document.createElement('div');\n    nonce.className = 'nonce';\n\n    return (text) => {\n      sizer.textContent = text;\n      sizer.appendChild(nonce);\n      return nonce.offsetLeft;\n    }\n  }());\n\n  // record upgraded measurer for callers to find our pixel position\n  upgraded.set(el, () => {\n    const mid = ~~((el.selectionStart + el.selectionEnd) / 2)\n    return measureText(el.value.substr(0, mid)) - el.scrollLeft;\n  });\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', (ev) => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = () => {\n    if (sel.from >= sel.to) {\n      underline.hidden = true;\n      return false;\n    }\n    const {from, to} = sel;\n\n    // otherwise, record and draw the line\n    const left = measureText(el.value.substr(0, from));\n    const width = measureText(el.value.substr(from, to - from));\n\n    if (width <= 0) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', el.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = `translateX(${-el.scrollLeft}px)`;\n\n    // TODO(samthor): put in div with underline so alignment is free?\n    autocomplete.style.transform = `translateX(${-el.scrollLeft + left + width}px)`;\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    sel.from = from;\n    sel.to = Math.max(from, to);\n    if (from >= to) {\n      datasetSafeDelete(el, 'prefix', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // rerender autocomplete word if valid\n  const renderAutocomplete = () => {\n    const s = el.dataset['prefix'] || '';\n\n    const atEnd = el.value.substr(sel.to).trim().length === 0;\n    const valid = suggest !== null &&\n        s.length !== 0 &&\n        (suggest.name[0] === '^' || suggest.name.substr(0, s.length) === s) &&\n        atEnd;\n    if (!valid) {\n      autocomplete.textContent = '';\n      return false;\n    }\n    const display = (suggest.name[0] === '^' ? '' : suggest.name.substr(s.length)) + suggest.emoji;\n    autocomplete.textContent = display;\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = (permitNextChange) => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // we're pretending to be the user's selection\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // if it's invalid and we were permitted (this is used for faux-highlights), ignore\n    const {from, to} = word.match(el.value, state.start);\n    if (from >= to && permitNextChange) {\n      return false;  // we just got an emoji, retain implicit selection until next change\n    }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from).toLowerCase();\n    }\n    return false;\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  let previousDetail = {};\n  let heldScrollLeft = 0;\n  const mergedEventHandler = (events, permitNextChange) => {\n    if (events.has('select-all')) {\n      // custom event generated by page.js\n      el.setSelectionRange(0, el.value.length);\n    } else if (events.has('select-end')) {\n      // custom event generated by options.js\n      el.setSelectionRange(el.value.length, el.value.length);\n    } else if (events.has('focus')) {\n      // if there was a focus event, don't let the browser take over: reset previous known good\n      // this can be for two reasons: up/down arrow moves to start, or tab key selects all\n      if (events.has('mousedown') || events.has('touchstart')) {\n        // also fine, user chose this, they selected something\n      } else {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        el.setSelectionRange(state.start, state.end);\n      }\n    }\n\n    // some browsers set this to zero when we leave, restore it\n    if (events.has('blur') || events.has('focus')) {\n      // TODO(samthor): Safari flashes L/R on this. We probably don't care.\n      el.scrollLeft = heldScrollLeft;\n    }\n    heldScrollLeft = el.scrollLeft;\n\n    // run change handler: if true, nothing changed\n    // (nb. the logic before return is because autocompletes don't count for alreadyAtState)\n    const alreadyAtState = changeHandler(permitNextChange);\n\n    // clear suggestion if we tried to render it and it wasn't valid\n    if (!renderAutocomplete()) {\n      suggest = null;\n    }\n\n    // set dataset['copy'] to the value you'd copy if you hit enter right now\n    // TODO(samthor): Generate this only when we run a copy?\n    if (el.selectionStart !== el.selectionEnd) {\n      el.dataset['copy'] = el.value.substr(el.selectionStart, el.selectionEnd - el.selectionStart);\n    } else if (suggest !== null) {\n      el.dataset['copy'] = el.value.substr(0, sel.from) + el.value.substr(sel.to) + suggest.emoji;\n    } else {\n      el.dataset['copy'] = el.value;\n    }\n\n    // if nothing changed, don't trigger any option callbacks\n    if (alreadyAtState) { return; }\n\n    // send query: prefix or whole-word (unless nothing is focused)\n    const text = el.dataset['focus'] ? el.dataset['prefix'] || null : '';\n    const detail = {\n      text,\n      prefix: 'prefix' in el.dataset,\n      focus: el.dataset['focus'],\n      selection: (el.selectionStart !== el.selectionEnd),\n    };\n\n    // send event only if something has changed\n    if (detail.text !== previousDetail.text ||\n        detail.prefix !== previousDetail.prefix ||\n        detail.focus !== previousDetail.focus ||\n        detail.selection !== previousDetail.selection) {\n      previousDetail = detail;\n      el.dispatchEvent(new CustomEvent('query', {detail}));\n    }\n  };\n\n  // whether user typed space and nothing came out\n  let hasPendingSpace = false;\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = (ev) => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown touchstart select input select-all select-end blur';\n    rest.split(/\\s+/).forEach((event) => el.addEventListener(event, dedup, {passive: true}));\n    dedup();\n\n    // handle 'suggest' event: show default autocomplete option\n    el.addEventListener('suggest', (ev) => {\n      suggest = ev.detail;\n      if (hasPendingSpace) {\n        maybeReplace();\n      }\n      dedup();\n    });\n\n    // if a user is dragging around, this might be changing the offsetLeft (dragging input l/r)\n    el.addEventListener('mousemove', (ev) => {\n      if (ev.which) {\n        dedup();\n      }\n    });\n\n    // add 'selectionchange' (only valid on document) to listen to the initial long-press selection\n    // on Chrome (possibly others?) mobile: it doesn't generate 'select'.\n    document.addEventListener('selectionchange', (ev) => {\n      if (document.activeElement === el) {\n        dedup();\n      }\n    });\n  }());\n\n  function maybeReplace(expectSpace = false) {\n    if (el.selectionEnd < sel.to) {\n      // this was before the end of the selection, don't autocomplete\n      return false;\n    }\n\n    const text = el.dataset['prefix'] || '';\n    if (text.length === 0 || !suggest || !suggest.name.startsWith(text)) {\n      // no valid sugestion or no text anyway\n      return false;\n    }\n\n    const rest = el.value.substr(sel.to);\n    const mustBeSpace = rest.substr(0, el.selectionStart - sel.to);\n    const trimmed = mustBeSpace.trim();\n    if (trimmed.length !== 0) {\n      // this wasn't blank or space chars\n      return false;\n    } else if (expectSpace && !mustBeSpace.length) {\n      // there wasn't a space and we expected one\n      return false;\n    }\n\n    if (rest.trim().length !== 0 && suggest.name !== text) {\n      // we're not the end of the string, so only autocomplete if it's entirely typed\n      return false;\n    }\n\n    // dispatch change request on ourselves\n    ga('send', 'event', 'options', 'typing');\n    const detail = {\n      choice: suggest.emoji,\n    };\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    return true;\n  }\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', (ev) => {\n    hasPendingSpace = false;\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case 'ArrowDown':\n    case 'Down':\n    case 'ArrowUp':\n    case 'Up':\n      ev.preventDefault();  // disable normal up/down behavior to change focus\n      break;\n\n    case ' ':\n      const success = maybeReplace();\n      if (ev.shiftKey) {\n        ev.preventDefault();  // don't type space if shift held\n      }\n      if (!success) {\n        // hold this for when autocompletes arrive\n        hasPendingSpace = true;\n      }\n      break;\n    }\n  });\n\n  // add a non-deduped keyup handler, for space on mobile browsers ('dreaded keycode 229')\n  el.addEventListener('keyup', (ev) => {\n    // was it a 229 or no code, and was the typed character a space?\n    if (ev.keyCode === 229 || !ev.keyCode) {\n      // TODO: possibly record hasPendingSpace for future arriving suggestions\n      maybeReplace(true);\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = () => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = (call) => {\n    const previousScrollLeft = el.scrollLeft;\n    const {from, to} = sel;\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n    const dir = typer.selectionDirection;\n\n    const update = call(value);\n    if (update == null) { return false; }\n\n    const prev = document.activeElement;\n\n    // select the region and 'type' it with insertText to provide undo/redo history\n    // nb. selecting the typer means that undo will always make us selected; probably fine\n    typer.focus();\n    typer.selectionStart = from;\n    typer.selectionEnd = to;\n    const expected = typer.value.substr(0, from) + update + typer.value.substr(to);\n    if (!document.execCommand('insertText', false, update) || typer.value !== expected) {\n      // set manually: this is fallback / Firefox mode\n      typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n    }\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n\n    const drift = (where) => {\n      if (where >= to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    // pretend we were like this all along\n    [state.start, state.end] = [drift(start), drift(end)];\n    typer.setSelectionRange(state.start, state.end, dir);\n\n    // TODO(samthor): Safari refuses to make this focus after the first above.\n    prev && prev.focus();\n\n    permitNextChange = true;\n    el.scrollLeft = previousScrollLeft;  // before setRange, so the underline is correct\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus emoji, if any\n  el.addEventListener('modifier', (ev) => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus((value) => modifier.modify(value, arg).out);\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', (ev) => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(() => emoji)) { return; }\n\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\n/**\n * @fileoverview Async worker.\n */\n\nimport * as promises from './promises.js';\n\nconst allowedWorkTime = 4;\nconst maximumTaskFrame = 100;\n\nexport default class Worker {\n  constructor(fn) {\n    this.fn_ = fn;\n    this.queue_ = [];\n    this.waiting_ = null;\n\n    this.runner_().catch((err) => {\n      console.info('worker runner failed', err);\n      throw err;\n    });\n  }\n\n  async runner_() {\n    await new Promise((resolve) => this.waiting_ = resolve);\n    this.waiting_ = null;\n    await promises.idle();\n\n    for (;;) {\n      if (this.chunk_()) {\n        return this.runner_();\n      }\n      await promises.rAF();\n    }\n  }\n\n  /**\n   * Completes a chunk of work.\n   *\n   * @return {boolean} Whether work is done.\n   */\n  chunk_() {\n    const start = window.performance.now();\n\n    let done = 0;\n    while (this.queue_.length) {\n      const next = this.queue_.shift();\n      next.resolve(this.fn_(next.arg));\n      ++done;\n\n      if (done == maximumTaskFrame || window.performance.now() - start > allowedWorkTime) {\n        break;\n      }\n    }\n\n    return !this.queue_.length;\n  }\n\n  task(arg) {\n    return new Promise((resolve) => {\n      this.queue_.push({resolve, arg});\n      this.waiting_ && this.waiting_();\n    });\n  }\n}\n","\n/**\n * @fileoverview The validator runs constantly and validates emoji rendering.\n */\n\nimport {isExpectedLength} from '../../node_modules/ok-emoji/src/measurer.js';\nimport Worker from './worker.js';\n\nconst dummyString = 'a';  // change if we mess something up\n\nconst prefix = '-ok_';\nconst ls = window.localStorage;\nconst known = new Map();\n\nconst ignoreValid = (window.location.search.indexOf('ignore_valid') !== -1);\n\nfunction runner(emoji) {\n  // nb. Helper code for detecting text-only results from backend.\n  if (emoji.charCodeAt(0) === 0x200b) {\n    return true;\n  }\n  const out = isExpectedLength(emoji);\n  known.set(emoji, out);\n  if (out) {\n    ls[prefix + emoji] = dummyString;  // use dummy small string\n  }\n  return out;\n}\n\nconst worker = new Worker(runner);\nconst task = ignoreValid ? () => true : worker.task.bind(worker);\n\nfunction immediate(emoji) {\n  const immediate = known.get(emoji);\n  if (immediate !== undefined) {\n    return immediate;\n  }\n  if (ls[prefix + emoji] === dummyString) {\n    return true;\n  }\n  return undefined;\n}\n\n/**\n * As per isExpectedLength, but caches successful results.\n *\n * @param {string} string to check\n * @return {!Promise<boolean>} whether this is probably an emoji\n */\nexport async function valid(emoji) {\n  const result = immediate(emoji);\n  if (result !== undefined) {\n    return result;\n  }\n  return task(emoji);\n}\n\n/**\n * Async helper that finds the first valid autocomplete option. Uses a callback in order to hint\n * whether the result is coming in the current frame (before any await) or after (calls callback\n * with null first).\n *\n * @param {!Array<!Array<string>>} options\n * @param {function(?{name: string, emoji: string})} callback\n */\nexport async function findValidMatch(options, callback) {\n  let calledWithDelay = false;\n\n  for (let i = 0; i < options.length; ++i) {\n    const row = options[i];\n    for (let j = 1; j < row.length; ++j) {\n      const emoji = row[j];\n      let result = immediate(emoji);\n      if (result === undefined) {\n        // we have to wait for the runner, so call with a delay\n        if (!calledWithDelay) {\n          callback(null);\n          calledWithDelay = true;\n        }\n        result = await task(emoji);\n      }\n\n      if (result) {\n        return callback({name: row[0], emoji});\n      }\n    }\n  }\n\n  if (!calledWithDelay) {\n    callback(null);\n  }\n}\n","\n/**\n * @fileoverview Emojityper's suggestion handler. Handles creation, showing etc of autocomplete\n * buttons in the UI.\n */\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\nimport {valid, findValidMatch} from './lib/valid.js';\nimport * as promises from './lib/promises.js';\nimport * as eventlib from './lib/event.js';\nimport * as input from './input.js';\nimport * as copier from './lib/copier.js';\n\n/**\n * ButtonManager helps create and show emoji buttons in the UI.\n */\nclass ButtonManager {\n  constructor(holder) {\n    this.holder_ = holder;\n\n    /** @type {!Map<string, !HTMLElement>} */\n    this.options_ = new Map();\n\n    /** @type {!Map<string, !HTMLButtonElement>} */\n    this.buttons_ = new Map();\n\n    /** @type {!WeakMap<!HTMLButtonElement, !DocumentFragment>} */\n    this.buttonTarget_ = new WeakMap();\n\n    /** @type {!Array<!HTMLButtonElement} */\n    this.buttonPool_ = [];\n\n    window.requestIdleCallback(() => {\n      for (let i = 0; i < 10; ++i) {\n        this.buttonPool_.push(document.createElement('button'));\n      }\n    });\n\n    const modifierHolder = document.createElement('div');\n    this.holder_.appendChild(modifierHolder);\n\n    /** @type {function(this:ButtonManager, !Object): void} */\n    this.setModifier = (() => {\n      const genderOption = ButtonManager.optionType_('modifier', 'gender');\n      const toneOption = ButtonManager.optionType_('modifier', 'tone');\n      modifierHolder.appendChild(genderOption);\n      modifierHolder.appendChild(toneOption);\n\n      // helper to create buttons\n      const createModifierButton = (text, value=null) => {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.dataset['value'] = value;\n        return button;\n      };\n\n      // create gender options\n      const genders = [\n        createModifierButton('\\u{26AC}', ''),\n        createModifierButton('\\u{2640}', 'f'),\n        createModifierButton('\\u{2640}\\u{2642}', 'fm'),\n        createModifierButton('\\u{2642}', 'm'),\n        createModifierButton('\\u{2642}\\u{2640}', 'mf'),\n      ];\n\n      // create tone options\n      const tones = [\n        createModifierButton('\\u{2014}', ''),\n      ];\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        tones.push(createModifierButton(String.fromCodePoint(i), i));\n      }\n\n      // helper to add/remove\n      const updateStatus = (yes, node, owner) => {\n        yes ? owner.appendChild(node) : node.remove();\n      };\n      return function(info) {\n        const active =\n            modifierHolder.contains(document.activeElement) ? document.activeElement : null;\n        genders.forEach((node) => {\n          const l = node.dataset['value'].length;\n          const yes = (!l && info.gender.neutral)\n              || (l === 1 && info.gender.single)\n              || (l === 2 && info.gender.double);\n          updateStatus(yes, node, genderOption);\n        });\n        tones.forEach((node) => updateStatus(info.tone, node, toneOption));\n\n        // kick the elements: Safari needs this otherwise sometimes they remain hidden (!)\n        modifierHolder.insertBefore(genderOption, genderOption.nextSibling);\n        modifierHolder.insertBefore(toneOption, toneOption.nextSibling);\n\n        // refocus if one was focused\n        active && active.focus();\n      }\n    })();\n  }\n\n  static optionType_(type, value) {\n    const node = document.createElement('div');\n    node.className = 'options ' + type;\n    node.dataset[type] = value;\n    node.dataset['name'] = value;\n    return node;\n  }\n\n  optionForName_(name) {\n    const prev = this.options_.get(name);\n    if (prev) {\n      return prev;\n    }\n    const node = document.createElement('div');\n    node.className = 'options';\n    node.setAttribute('data-option', name);\n\n    if (name[0] === '^') {\n      node.classList.add('special');\n      name = name.substr(1);\n    }\n    node.setAttribute('data-name', name);  // presentation only\n    return node;\n  }\n\n  /**\n   * Creates a `button` with the textContent of the passed emoji. Starts removed from the page,\n   * but will (when valid) be placed in-order inside the specified `option`.\n   *\n   * @param {!HTMLElement} option to place inside\n   * @param {string} emoji\n   * @return {!HTMLButtonElement}\n   */\n  addEmojiTo_(option, emoji) {\n    let button = this.buttons_.get(emoji);\n    if (button) {\n      // if the button was known, check buttonTarget_: either it's the eventual placement, which\n      // we must replace, or it's a known good/bad already\n      const target = this.buttonTarget_.get(button);\n      if (target === null) {\n        return button;  // known invalid\n      } else if (target === undefined) {\n        option.appendChild(button);  // known good\n        return button;\n      }\n    } else {\n      button = this.buttonPool_.pop() || document.createElement('button');\n      button.textContent = emoji;\n      this.buttons_.set(emoji, button);\n\n      valid(emoji).then((isValid) => {\n        if (!isValid) {\n          return this.buttonTarget_.set(button, null);\n        }\n\n        const node = this.buttonTarget_.get(button);\n        if (!node) {\n          return;  // we were GC'ed before valid returned\n        }\n        node.parentNode.replaceChild(button, node);\n        this.buttonTarget_.delete(button);\n      });\n    }\n\n    const node = document.createTextNode('');  // empty placeholder to replace\n    this.buttonTarget_.set(button, node);\n    option.appendChild(node);\n\n    return button;\n  }\n\n  /**\n   * Updated displayed options with real results. These are expected the API format:\n   *    [[name,emoji,emoji,...],[name,emoji,...],...]\n   *\n   * This retains existing options if they are included in the named results.\n   *\n   * @param {!Array<!Array<string>>}\n   */\n  update(results) {\n    const options = new Map();\n    const buttons = new Map();\n    const previousActiveElement =\n        this.holder_.contains(document.activeElement) ? document.activeElement : null;\n\n    results.forEach((result) => {\n      const name = result[0];\n      const special = (name[0] === '^');\n\n      const option = this.optionForName_(name);\n      options.set(name, option);\n      this.options_.delete(name);\n      this.holder_.appendChild(option);  // reinsert in better order\n\n      // TODO(samthor): This is a bit hacky. This saves buttons that are part of these options,\n      // even if they haven't been sent to us again in results.\n      for (let i = 0; i < option.children.length; ++i) {\n        const b = option.children[i];\n        const emoji = b.textContent;\n        if (special || buttons.has(emoji)) {\n          b.remove();\n          this.buttonPool_.push(b);\n          --i;\n          continue;\n        }\n        buttons.set(emoji, b);\n      }\n\n      for (let i = 1, emoji; emoji = result[i]; ++i) {\n        if (buttons.has(emoji)) {\n          continue;  // already displayed by an option before us\n        }\n        // nb. addEmojiTo_ pulls old buttons from this.buttons_\n        buttons.set(emoji, this.addEmojiTo_(option, emoji));\n      }\n    });\n\n    // remove now-disused options\n    this.options_.forEach((option) => {\n      // TODO(samthor): Edge doesn't like ...HTMLCollection\n      for (let i = 0; i < option.children.length; ++i) {\n        this.buttonPool_.push(option.children[i]);\n      }\n      option.remove();\n    });\n    this.options_ = options;\n    this.buttons_ = buttons;\n\n    if (previousActiveElement) {\n      if (document.body.contains(previousActiveElement)) {\n        previousActiveElement.focus();\n      } else {\n        typer.focus();  // restore to main input\n      }\n    }\n  }\n}\n\n// stores the previous user-driven l/r position\nlet previousChooserLeft = undefined;\nlet duringNavigate = false;\n\n// if a button was focused, reset chooser unless we were going u/d\nchooser.addEventListener('focus', (ev) => {\n  if (!duringNavigate) {\n    previousChooserLeft = document.activeElement.getBoundingClientRect().left;\n  }\n}, true);\n\n/**\n * Navigates through candidates until we find the best not on our current row, and focuses it.\n *\n * @param {!IArrayLike<!Node>} cands\n * @return {boolean} true if we focused something new\n */\nfunction navigateChooserButtonVertical(cands) {\n  const best = {dist: Infinity, button: null};\n\n  const previousRect = document.activeElement.getBoundingClientRect();\n  // did we have a previous explicit l/r position?\n  const left = (previousChooserLeft !== undefined ? previousChooserLeft : previousRect.left);\n\n  let targetTop = undefined;\n  for (let i = 0; i < cands.length; ++i) {\n    const button = cands[i];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    } else if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (!best.button) {\n    return false;\n  }\n  duringNavigate = true;\n  try {\n    best.button.focus();\n  } finally {\n    duringNavigate = false;\n  }\n  return true;\n}\n\n// button click handler\nchooser.addEventListener('click', (ev) => {\n  previousChooserLeft = undefined;  // used a mouse or chose something\n  const isKeyboard = eventlib.isKeyboardClick(ev);\n\n  let label = undefined;\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    if (ev.shiftKey) {\n      return;  // don't do anything\n    }\n\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n    label = 'modifier';\n  } else if (b.parentNode.dataset['option']) {\n    if (ev.shiftKey) {\n      if (copier.copyText(b.textContent)) {\n        ga('send', 'event', 'options', 'copy');\n      }\n\n      // retain scroll position while refocusing on the suitable target\n      const scrollTop = document.scrollingElement.scrollTop;\n      isKeyboard ? b.focus() : typer.focus();\n      document.scrollingElement.scrollTop = scrollTop;\n      return;\n    }\n\n    // this clears the options on choice.\n    // TODO: retain all, and show what you typed as a hint autocomplete\n    const detail = {choice: b.textContent};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(b.parentNode.dataset['option'], detail.choice);\n    label = 'emoji';\n  } else {\n    // unknown\n  }\n  if (!label) { return; }\n\n  ga('send', 'event', 'options', 'click', label);\n\n  if (!isKeyboard) {\n    typer.focus();  // nb. we're actually double-refocusing\n  }\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', (ev) => {\n  if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    const typerRect = typer.getBoundingClientRect();\n    previousChooserLeft = typerRect.left + input.cursorPosition(typer);\n\n    if (navigateChooserButtonVertical(chooser.querySelectorAll('button'))) {\n      ga('send', 'event', 'options', 'keyboardnav');\n    }\n  } else if (ev.key === 'ArrowRight' || ev.key === 'Right') {\n    const l = typer.value.length;\n    if (typer.selectionEnd === l && typer.selectionStart === l) {\n      const first = chooser.querySelector('button');\n      first && first.focus();\n    }\n  }\n});\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', (ev) => {\n  const arrow = eventlib.arrowFromEvent(ev);\n  if (!arrow) { return; }\n\n  if (!chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (arrow === 'ArrowLeft') {\n    delta = -1;\n  } else if (arrow === 'ArrowRight') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    } else if (target < 0) {\n      typer.focus();\n      typer.dispatchEvent(new CustomEvent('select-end'));\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  let cands;\n  if (arrow === 'ArrowUp') {\n    cands = buttonArray.slice(0, index);\n    cands.reverse();\n  } else if (arrow === 'ArrowDown') {\n    cands = buttonArray.slice(index);\n  } else {\n    return;\n  }\n\n  if (!navigateChooserButtonVertical(cands)) {\n    if (arrow === 'ArrowUp') {\n      typer.focus();\n    }\n  }\n  if (arrow === 'ArrowDown') {\n    // don't allow arrow scrolling unless we're within 64 pixels of the screen end\n    const focusRect = document.activeElement.getBoundingClientRect();\n    const max = focusRect.top + focusRect.height;\n    if (window.innerHeight - max > 64) {\n      ev.preventDefault();\n    }\n  }\n});\n\n(function() {\n  const longTime = 2000;\n  const delayTime = 250;\n  const manager = new ButtonManager(chooser);\n\n  let previous = {};\n  let previousQueryAt = performance.now();\n  let previousResults = [];\n\n  let suggestInvoke = 0;\n  function findSuggest(q) {\n    const localSuggestInvoke = ++suggestInvoke;\n    if (!q) {\n      typer.dispatchEvent(new CustomEvent('suggest', {detail: null}));\n      return;\n    }\n\n    let exactMatch = null;\n    const localResults = previousResults.slice().filter((row) => {\n      if (q.length > 1 && row[0] === q) {\n        exactMatch = row;\n        return false;\n      }\n      return row[0].startsWith(q) || row[0][0] === '^';\n    });\n    exactMatch && localResults.unshift(exactMatch);\n\n    const callback = (result) => {\n      if (localSuggestInvoke === suggestInvoke) {\n        typer.dispatchEvent(new CustomEvent('suggest', {detail: result}));\n      }\n    };\n    findValidMatch(localResults, callback);\n  }\n\n  // handler for a prefix search\n  typer.addEventListener('query', (ev) => {\n    const query = ev.detail;\n    const now = performance.now();\n\n    // immediately inform manager of modifier buttons (gender, tone), if it's a full word search\n    const info = modifier.modify(!ev.detail.prefix && ev.detail.focus || '');\n    manager.setModifier(info);\n\n    if (previous.text !== query.text) {\n      // text changed, immediately run suggest code\n      findSuggest(query.text);\n    }\n\n    // TODO(samthor): This delays further requests. Ideally we want to 'subscribe' to a topic\n    // from the provider and just be fed updates as fast as we have them (including if we have\n    // a local cache). This way we avoid awkward delays and filtering oddities.\n    const initialMore = previous.text && query.text && previous.text.length !== 0 &&\n        previous.text.startsWith(query.text.substr(0, previous.text.length)) || false;\n\n    let immediate = false;\n    if (!previous.text || previous.prefix !== query.prefix) {\n      immediate = true;  // type changed, user expects snappiness\n    } else if (now - previousQueryAt > longTime) {\n      immediate = true;  // it's been a while\n    }\n    previous = query;\n    previousQueryAt = now;\n\n    const request = async (timeout=0, more=false) => {\n      if (timeout) {\n        await promises.rAF(timeout);\n        if (previous !== query) { return -1; }\n      }\n      const results = await provider.request(query.text, query.prefix, more);\n      if (previous !== query) { return -1; }\n\n      // find the first matching thing and suggest it as autocomplete\n      previousResults = results;\n      findSuggest(query.text);\n\n      return manager.update(results);\n    };\n\n    const p = request(immediate ? 0 : delayTime, initialMore).then((valid) => {\n      if (valid < 0) { return -2; }  // query changed\n\n      if (!query.text) {\n        // TODO: delay empty data by a decent time, except on small screens\n        const timeout = window.innerHeight <= 400 ? 0 : 750;\n        return request(timeout, true);\n      }\n\n      const timeout = Math.max(1000, 100 * Math.pow(valid, 0.75));\n      return request(timeout, true);\n    }).catch((err) => {\n      console.error('error doing request', err);\n    });\n  });\n}());\n","\n/**\n * @fileoverview Controls the size and `has-value` class of the body itself based on current input.\n */\n\nimport * as promises from './lib/promises.js';\n\nconst value = (ev) => {\n  const text = ev.detail.trim();\n  document.body.classList.toggle('has-value', Boolean(text));\n};\ntyper.addEventListener('value', value);\nvalue({detail: typer.value});\n\n// global return-to-typer\ndocument.body.addEventListener('keydown', (ev) => {\n  switch (ev.key) {\n  case 'Escape':\n    // #1: focus on typer\n    if (document.activeElement !== typer) {\n      typer.focus();\n      break;\n    }\n\n    // #2: clear selection\n    if (typer.selectionStart !== typer.selectionEnd) {\n      if (typer.selectionDirection === 'backward') {\n        typer.selectionStart = typer.selectionEnd;\n      } else {\n        typer.selectionEnd = typer.selectionStart;\n      }\n      break;\n    }\n\n    // #3: move to end of input\n    const l = typer.value.length;\n    typer.setSelectionRange(l, l);\n    break;\n  }\n});\n\nfunction isExtentNode(node) {\n  return node instanceof Element && node.classList.contains('extent');\n}\n\ndocument.addEventListener('selectionchange', (ev) => {\n  const s = window.getSelection();\n  const {anchorNode: a, focusNode: b} = s;\n  if (a !== b && isExtentNode(a) && isExtentNode(b)) {\n    s.removeAllRanges();  // remove immediately to prevent flash\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('select-all'));\n  }\n}, true);\n\ndocument.addEventListener('focusin', (ev) => {\n  promises.microtask().then(() => {\n    if (document.activeElement === document.body) {\n      typer.focus();\n    }\n  });\n});\n\n// set minHeight to actual viewport height, but allow for keyboard etc\nconst resize = (ev) => {\n  const height = window.innerHeight;\n  document.body.style.minHeight = `${height}px`;\n};\nwindow.addEventListener('resize', resize);\nwindow.addEventListener('load', resize);\nresize();\n\n// Link tracking\n\ndocument.body.addEventListener('click', (ev) => {\n  const target = ev.target && ev.target.closest('a[href]');\n  if (!target) { return; }\n\n  ga('send', 'event', 'outbound', 'click', target.href);\n});\n","\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('./sw.js').catch((err) => {\n    console.warn('failed to register SW', err);\n  });\n\n  const hadInitialController = Boolean(navigator.serviceWorker.controller);\n  navigator.serviceWorker.addEventListener('controllerchange', () => {\n    if (hadInitialController) {\n      // only reload if we had a SW on load\n      console.debug('got SW controllerchange, reload');\n      window.location.reload();\n    } else {\n      // this is the very first SW, so reloading doesn't help us\n    }\n  });\n}\n","\n/**\n * @fileoverview Initial payload entrypoint.\n */\n\nimport '../polyfill.js';\nimport '../loader.js';  // first, as this adds ga()\n\nimport '../buttons.js';\nimport '../input.js';\nimport '../options.js';\nimport '../page.js';\nimport '../sw.js';\n\n// global error handler for logs\nwindow.onerror = (msg, file, line, col, error) => {\n  console.info('got err', String(msg));\n  try {\n    ga('send', 'event', 'error', `${file},${line}:${col}`, String(msg), {nonInteraction: true});\n  } catch (e) {}\n};\n"],"names":["window","requestIdleCallback","callback","start","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","setTimeout","cancelIdleCallback","id","clearTimeout","sendBeacon","navigator","url","body","xhr","XMLHttpRequest","open","send","addEventListener","ev","parent","postMessage","requestAnimationFrame","scriptPWACompat","document","createElement","head","appendChild","outerHTML","currentScript","scriptExtended","src","getAttribute","type","_dev","scriptAnalytics","tempGA","push","arguments","Date","data","ga","apply","payload","console","debug","arrowKeys","isKeyboardClick","MouseEvent","screenX","detail","webkitForce","dummy","copyText","text","style","position","opacity","value","hidden","focus","selectionStart","selectionEnd","length","execCommand","e","all","Array","from","input","querySelectorAll","handler","trim","hasValue","Boolean","forEach","button","disabled","typer","jsdecode","s","len","points","i","raw","charCodeAt","extra","timeout","defaultText","textContent","copy","dataset","replace","copier","warn","info","classList","add","remove","maybeReleaseInputEnter","wasInputEnter","activeElement","key","repeat","click","preventDefault","eventlib","runeZWJ","runeVS16","isSkinTone","p","isFlagPoint","isTag","skippable","_emojiPointCount","halfCount","l","indexOf","_iterateEmoji","curr","flag","v","pending","ensure","off","cand","shift","tail","fixedWidthEmoji","exec","platform","userAgent","needsManWomanHack","letterSpacing","fontSize","hider","overflow","width","setAttribute","measurer","measure","getBoundingClientRect","offsetWidth","height","offsetHeight","display","whiteSpace","lineHeight","fontFamily","invalidBoxSize","validEmojiSize","fixedWidthMeasure","context","getContext","font","expectedWidth","measureText","countExtraAllowed","index","isSingleValidEmoji","rect","expected","round","isExpectedLength","actual","emojiPointCount","countRenderPoints","part","String","fromCodePoint","isSingle","limit","cache","count","arg","result","undefined","cacheFor","basicDiversity","skipDiversityList","skipDiversity","isFamilyMember","genderFlip","list","Map","f","m","n","j","has","Error","set","point","out","get","single","neutral","reverseParts","last","lastIndexOf","emoji","to","slice","x","trailer","modify","op","stats","tone","gender","double","outer","genderable","familyLike","first","localFamilyMember","localPersonGender","flip","valid","splice","update","filter","map","splitPoints","parts","isPointGender","pop","localOp","foundAny","next","split","run","merged","join","letterAt","pos","code","datasetSafeDelete","el","d","keys","upgraded","WeakMap","sel","helper","className","parentNode","insertBefore","underline","suggest","autocomplete","sizer","nonce","offsetLeft","mid","substr","scrollLeft","readyState","renderLine","left","transform","setRange","initialLength","state","end","changeHandler","permitNextChange","dispatchEvent","CustomEvent","at","word","toLowerCase","previousDetail","heldScrollLeft","mergedEventHandler","events","setSelectionRange","alreadyAtState","atEnd","name","renderAutocomplete","prefix","selection","hasPendingSpace","maybeReplace","expectSpace","startsWith","rest","mustBeSpace","choice","frame","Set","dedup","clear","event","passive","which","success","shiftKey","keyCode","dedupRenderLine","replaceFocus","call","previousScrollLeft","dir","selectionDirection","prev","drift","where","[object Object]","modifier","upgrade","allowedWorkTime","maximumTaskFrame","dummyString","ls","localStorage","known","ignoreValid","location","search","worker","constructor","this","fn_","queue_","waiting_","runner_","catch","err","Promise","resolve","promises","chunk_","done","task","immediate","ButtonManager","holder","holder_","options_","buttons_","buttonTarget_","buttonPool_","modifierHolder","setModifier","genderOption","optionType_","toneOption","createModifierButton","genders","tones","updateStatus","yes","node","owner","active","contains","nextSibling","optionForName_","addEmojiTo_","option","target","then","isValid","replaceChild","delete","createTextNode","results","options","buttons","previousActiveElement","special","children","b","previousChooserLeft","duringNavigate","navigateChooserButtonVertical","cands","best","dist","Infinity","previousRect","targetTop","candidateRect","top","abs","chooser","isKeyboard","label","localName","scrollTop","scrollingElement","provider","typerRect","querySelector","arrow","buttonArray","delta","reverse","focusRect","innerHeight","manager","previous","previousQueryAt","previousResults","suggestInvoke","findSuggest","q","localSuggestInvoke","exactMatch","localResults","row","unshift","calledWithDelay","findValidMatch","query","initialMore","request","async","more","pow","error","toggle","isExtentNode","Element","getSelection","a","anchorNode","focusNode","removeAllRanges","resize","minHeight","closest","href","serviceWorker","register","hadInitialController","controller","reload","onerror","msg","file","line","col","nonInteraction"],"mappings":"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"}